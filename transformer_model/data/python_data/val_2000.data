self , verbose self . __verbose = verbose
self return self . __state . page
self if self . __state . form is None : raise AttributeError ( " No form has been selected yet on this page . " ) return self . __state . form
self , type , name , value , ** kwargs return self . form . new_control ( type , name , value , ** kwargs )
self , url return urllib . parse . urljoin ( self . url , url )
self , key , pdf_file object_number = int ( self . get_value ( key , ' (\\\\d+) 0 R ' ) ) return type ( self ) ( object_number , pdf_file . read_object ( object_number ) )
element , box , get_image_from_uri , base_url if box . element_tag in HTML_HANDLERS : return HTML_HANDLERS [ element . tag ] ( element , box , get_image_from_uri , base_url ) else : return [ box ]
string return string . strip ( HTML_WHITESPACE )
self return get_html_metadata ( self . wrapper_element , self . base_url return get_html_metadata ( self . wrapper_element , self . base_url )
x , y , offset_x , offset_y , offset return x + offset_x * offset , y + offset_y * offset
self GzipFile . close ( self ) self . fileobj_to_close . close ( GzipFile . close ( self ) self . fileobj_to_close . close ( )
string return string if url_is_absolute ( string ) else path2url ( string )
data missing_padding = 4 - len ( data ) % 4 if missing_padding : data += b ' = ' * missing_padding return decodebytes ( data )
ffi , * names for name in names : try : return ffi . dlopen ( name ) except OSError : pass return ffi . dlopen ( names [ 0 ] )
self , wrap_mode pango . pango_layout_set_wrap ( self . layout , wrap_mode , wrap_mode pango . pango_layout_set_wrap ( self . layout , wrap_mode )
function FORMATTERS [ function . __name__ . replace ( ' _ ' , ' - ' ) ] = function return function
value , counter_style style = STYLES [ counter_style ] return style [ ' prefix ' ] + format ( value , counter_style ) + style [ ' suffix ' ]
self return ( return ( )
self return self . width + self . padding_left + self . padding_right
self return self . height + self . padding_top + self . padding_bottom
self return self . border_width ( ) + self . margin_left + self . margin_right
self return self . position_x + self . margin_left + self . padding_left + self . border_left_width
self return self . position_y + self . margin_top + self . padding_top + self . border_top_width
self return self . position_y + self . margin_top + self . border_top_width
self return self . rounded_box ( 0 , 0 , 0 , 0 )
self return not ( self . is_floated ( ) or self . is_absolutely_positioned ( ) or self . is_running ( ) )
self return self . childre return self . children
box , outer , width , left = True , right = True fixed = min_max ( box , width ) if outer : return margin_width ( box , fixed , left , right ) else : return fixed
self , available self . inner = min ( max ( self . min_content_size , available ) , self . max_content_size , available self . inner = min ( max ( self . min_content_size , available ) , self . max_content_size )
context , placeholder , containing_block , fixed_boxes assert not placeholder . _layout_done box = placeholder . _box placeholder . set_laid_out_box ( absolute_box_layout ( context , box , containing_block , fixed_boxes ) )
value , refer_to if value is None or value == ' auto ' : return value elif value . unit == ' px ' : return value . value else : assert value . unit == ' % ' return refer_to * value . value / 100 .
computer , name , value if value == ' normal ' : value = Dimension ( 1 , ' em ' ) return length ( computer , name , value , pixels_only = True )
computer , name , values return _content_list ( computer , values )
token if token . type == ' ident ' : return token . value
function @ functools . wraps ( function ) def keyword_validator ( tokens ) : """ Wrap a validator to call get_single_keyword on tokens . """ keyword = get_single_keyword ( tokens ) if function ( keyword ) : return keyword return keyword_validator
tokens , base_url parsed_tokens = [ get_content_list_token ( token , base_url ) for token in tokens ] if None not in parsed_tokens : return parsed_tokens
self , anchor_token anchor_name = self . anchor_name_from_token ( anchor_token ) if anchor_name : self . target_lookup_items . setdefault ( anchor_name , TargetLookupItem ( ) )
self if self . had_pending_targets : for item in self . target_lookup_items . values ( ) : for function in item . parse_again_functions . values ( ) : function ( ) self . had_pending_targets = False self . collecting = False
keyword return keyword in ( ' separate ' , ' collapse ' ord return keyword in ( ' separate ' , ' collapse ' )
keyword return keyword in ( ' show ' , ' hide ' )
token result = parse_color ( token ) if result == ' currentColor ' : return ' inherit ' else : return result
keyword return keyword in ( ' none ' , ' hidden ' , ' dotted ' , ' dashed ' , ' double ' , ' inset ' , ' outset ' , ' groove ' , ' ridge ' , ' solid ' )
keyword return keyword in ( ' none ' , ' dotted ' , ' dashed ' , ' double ' , ' inset ' , ' outset ' , ' groove ' , ' ridge ' , ' solid ' )
token length = get_length ( token , negative = False , percentage = True ) if length : return length font_size_keyword = get_keyword ( token ) if font_size_keyword in ( ' smaller ' , ' larger ' ) : return font_size_keyword if font_size_keyword in computed_values . FONT_SIZE_KEYWORDS : return font_size_keyword
keyword return keyword in ( ' ultra-condensed ' , ' extra-condensed ' , ' condensed ' , ' semi-condensed ' , ' normal ' , ' semi-expanded ' , ' expanded ' , ' extra-expanded ' , ' ultra-expanded ' )
token if token . type == ' number ' : return min ( 1 , max ( 0 , token . value ) )
token if get_keyword ( token ) == ' auto ' : return ' auto ' if token . type == ' number ' and token . int_value is not None : return token . int_value
keyword if keyword in ( ' solid ' , ' double ' , ' dotted ' , ' dashed ' , ' wavy ' ) : return keyword
keyword return keyword in ( ' normal ' , ' break-word ' )
token if token . type == ' number ' : return token . valun if token . type == ' number ' : return token . value
keyword return keyword in ( ' nowrap ' , ' wrap ' , ' wrap-reverse ' )
keyword return keyword in ( ' auto ' , ' flex-start ' , ' flex-end ' , ' center ' , ' baseline ' , ' stretch ' )
token if token . type == ' number ' and token . int_value is not None : value = token . int_value if value >= 1 : return value elif get_keyword ( token ) == ' none ' : return ' none '
property_name def expander_decorator ( function ) : """ Add ``function`` to the ``EXPANDERS`` . """ assert property_name not in EXPANDERS , property_name EXPANDERS [ property_name ] = function return function return expander_decorator
base_url , name , tokens keyword = overflow_wrap ( tokens ) if keyword is None : raise InvalidValues yield ' overflow-wrap ' , keyword
self return b ' ' . join ( self . chunks return b ' ' . join ( self . chunks )
name , expected_width , expected_height , expected_pixels , html assert_pixels ( name , expected_width , expected_height , expected_pixels , html , expected_width , expected_height , expected_pixels , html assert_pixels ( name , expected_width , expected_height , expected_pixels , html )
@ page , = render_pages ( ' <html style= " display: table " > ' ge , = render_pages ( ' <html style= " display: table " > ' )
hz return 2595 * numpy . log10 ( 1 + hz / 700 . 0 )
self , string if self . mode == ' digit2char ' : return convertDigit2Character ( string ) else : return convertCharacter2Digit ( string , string if self . mode == ' digit2char ' : return convertDigit2Character ( string ) else : return convertCharacter2Digit ( string )
string return _prepString ( string ng return _prepString ( string )
self , feature_dir , label_dir , mode , level return load_batched_data ( feature_dir , label_dir , batch_size , mode , level , feature_dir , label_dir , mode , level return load_batched_data ( feature_dir , label_dir , batch_size , mode , level )
self return self . hlirType . length * return self . hlirType . length * 8
self self . program += self . eo self . program += self . eol
self , addNewline self . append ( " ; " ) if addNewline : self . newline ( , addNewline self . append ( " ; " ) if addNewline : self . newline ( )
self self . append ( " { " ) self . newline ( ) self . increaseIndent ( self . append ( " { " ) self . newline ( ) self . increaseIndent ( )
self return self . widt return self . width
self , serializer assert isinstance ( serializer , ProgramSerializer ) serializer . append ( " 0 " , serializer assert isinstance ( serializer , ProgramSerializer ) serializer . append ( " 0 " )
self , node assert ( node not in self . nodes ) self . nodes [ node ] = Node ( node , node assert ( node not in self . nodes ) self . nodes [ node ] = Node ( node )
self , node return self . nodes [ node , node return self . nodes [ node ]
self , serializer , identifier , size raise CompilationException ( True , " Method must be overridden " , serializer , identifier , size raise CompilationException ( True , " Method must be overridden " )
self , serializer assert isinstance ( serializer , ProgramSerializer ) self . basetype . declareArray ( serializer , self . name , self . arraySize , serializer assert isinstance ( serializer , ProgramSerializer ) self . basetype . declareArray ( serializer , self . name , self . arraySize )
self , endpoint assert isinstance ( endpoint , Endpoint ) self . endpoints . append ( endpoint ) endpoint . set_parent ( self , endpoint assert isinstance ( endpoint , Endpoint ) self . endpoints . append ( endpoint ) endpoint . set_parent ( self )
self , name name = _assert_is_bytes ( name ) return self . get_syscall_prefix ( ) + nam , name name = _assert_is_bytes ( name ) return self . get_syscall_prefix ( ) + name
name , sym_re return set ( [ name for ( name , _ ) in BPF . get_user_functions_and_addresses ( name , sym_re ) ] , sym_re return set ( [ name for ( name , _ ) in BPF . get_user_functions_and_addresses ( name , sym_re ) ] )
self , nonblocking = False trace = self . trace_open ( nonblocking ) line = None try : line = trace . readline ( 1024 ) . rstrip ( ) except IOError : pass return line
self return len ( self . uprobe_fds )
self return len ( self . tracepoint_fds )
x return x << ( PAGE_SHIFT - 10 turn x << ( PAGE_SHIFT - 10 )
self , error raise ValueError ( " error parsing probe ' %s ' : %s " % ( self . raw_spec , error ) , error raise ValueError ( " error parsing probe ' %s ' : %s " % ( self . raw_spec , error ) )
self , ident return re . sub ( r ' [^A-Za-z0-9_] ' , ' _ ' , ident , ident return re . sub ( r ' [^A-Za-z0-9_] ' , ' _ ' , ident )
self text = return text % str ( self . length + 1 )
def if args . latency : print_latency_stats ( ) else : print_count_stats ( if args . latency : print_latency_stats ( ) else : print_count_stats ( )
signal , frame print ( al , frame print ( )
val ival = positive_int ( val ) if ival == 0 : raise argparse . ArgumentTypeError ( " must be nonzero " ) return ivaival = positive_int ( val ) if ival == 0 : raise argparse . ArgumentTypeError ( " must be nonzero " ) return ival
signal , frame print ( al , frame print ( )
n return ( ( 1 << n ) - 1 ) << ( 32 - n turn ( ( 1 << n ) - 1 ) << ( 32 - n )
val ival = positive_int ( val ) if ival == 0 : raise argparse . ArgumentTypeError ( " must be nonzero " ) return ivaival = positive_int ( val ) if ival == 0 : raise argparse . ArgumentTypeError ( " must be nonzero " ) return ival
signal , frame print ( al , frame print ( )
self return self . bpf [ " counts " return self . bpf [ " counts " ]
s return ' " {} " ' . format ( ' ' . join ( escape_character ( c ) for c in s ) turn ' " {} " ' . format ( ' ' . join ( escape_character ( c ) for c in s ) )
signal , frame print ( al , frame print ( )
self self . usdts = Non self . usdts = None
signal , frame print ( al , frame print ( )
self test_prog1 = b = BPF ( text = test_prog1 ) t = b [ " hash " ] self . assertEqual ( t . flags , 1 ) ;
self text = b = BPF ( text = text , debug = 0 ) fn = b . load_func ( " handle_packet " , BPF . SCHED_CLS )
self text = b = BPF ( text = text , debug = 0 ) fn = b . load_func ( " trace_entry " , BPF . KPROBE )
self bpf_text = b = BPF ( text = bpf_text ) b . load_func ( " trace_entry " , BPF . KPROBE ) b . load_func ( " trace_exit " , BPF . KPROBE )
self text = b = BPF ( text = text )
self text = b = BPF ( text = text ) b . attach_kprobe ( event = " __vfs_read " , fn_name = " trace_read_entry " )
self text = with self . assertRaises ( Exception ) : b = BPF ( text = text )
self text = b = BPF ( text = text )
self text = b = BPF ( text = text )
self text = b = BPF ( text = text ) fn = b . load_func ( " test " , BPF . SCHED_CLS )
self text = b = BPF ( text = text ) fn = b . load_func ( " test " , BPF . KPROBE )
self text = b = BPF ( text = text ) fn = b . load_func ( " test " , BPF . KPROBE )
self self . b = BPF ( text = )
self subprocess . check_output ( ' objcopy --add-gnu-debuglink=dummy . debug dummy ' . split ( ) subprocess . check_output ( ' objcopy --add-gnu-debuglink=dummy . debug dummy ' . split ( ) )
self self . assertEqual ( cfg . leaking_amount , self . run_leaker ( " calloc " ) self . assertEqual ( cfg . leaking_amount , self . run_leaker ( " calloc " ) )
self self . assertEqual ( cfg . leaking_amount , self . run_leaker ( " valloc " ) self . assertEqual ( cfg . leaking_amount , self . run_leaker ( " valloc " ) )
self self . run_with_int ( " capable . py " self . run_with_int ( " capable . py " )
self self . run_with_int ( " drsnoop . py " self . run_with_int ( " drsnoop . py " )
self self . run_with_int ( " execsnoop . py " self . run_with_int ( " execsnoop . py " )
self self . run_with_int ( " funccount . py __kmalloc -i 1 " self . run_with_int ( " funccount . py __kmalloc -i 1 " )
self self . run_with_int ( " funclatency . py __kmalloc -i 1 " self . run_with_int ( " funclatency . py __kmalloc -i 1 " )
self self . run_with_int ( " funcslower . py __kmalloc " self . run_with_int ( " funcslower . py __kmalloc " )
self self . run_with_int ( " gethostlatency . py " self . run_with_int ( " gethostlatency . py " )
self self . run_with_duration ( " memleak . py 1 1 " self . run_with_duration ( " memleak . py 1 1 " )
self self . run_with_int ( " pidpersec . py " self . run_with_int ( " pidpersec . py " )
self self . run_with_duration ( " runqlen . py 1 1 " self . run_with_duration ( " runqlen . py 1 1 " )
self self . run_with_duration ( " slabratetop . py 1 1 " self . run_with_duration ( " slabratetop . py 1 1 " )
self self . run_with_duration ( " softirqs . py 1 1 " ) pas self . run_with_duration ( " softirqs . py 1 1 " ) pass
self self . run_with_int ( " solisten . py " self . run_with_int ( " solisten . py " )
self self . run_with_int ( " syscount . py -i 1 " self . run_with_int ( " syscount . py -i 1 " )
self self . run_with_int ( " tcpretrans . py " self . run_with_int ( " tcpretrans . py " )
self , lic return ' ' ' #define BPF_LICENSE %s ' ' ' % ( lic , lic return ' ' ' #define BPF_LICENSE %s ' ' ' % ( lic )
self TestCommand . finalize_options ( self ) self . test_args = [ ] self . test_suite = Tru TestCommand . finalize_options ( self ) self . test_args = [ ] self . test_suite = True
self return self . fspath , 0 , " usecase: %s " % self . nam return self . fspath , 0 , " usecase: %s " % self . name
self , arg print ( arg )
dict_1 , dict_2 return dict ( ( str ( key ) , dict_1 . get ( key ) or dict_2 . get ( key ) ) for key in set ( dict_2 ) | set ( dict_1 ) )
pretrained = False , ** kwargs model = MobileNetV2 ( n_class = 1000 , ** kwargs ) if pretrained : model . load_state_dict ( load_url ( model_urls [ ' mobilenetv2 ' ] ) , strict = False ) return model
pretrained = False , ** kwargs model = ResNet ( Bottleneck , [ 3 , 4 , 23 , 3 ] , ** kwargs ) if pretrained : model . load_state_dict ( load_url ( model_urls [ ' resnet101 ' ] ) , strict = False ) return model
self return len ( self . _registry return len ( self . _registry )
self os . environ = self . _enviro os . environ = self . _environ
self py = create_tmp_test ( ) read_fd , write_fd = os . pipe ( ) python ( py . name , _out = write_fd ) out = os . read ( read_fd , 10 ) self . assertEqual ( out , b " hi world\ " )
self py = create_tmp_test ( ) self . assertRaises ( sh . ErrorReturnCode , python , py . name )
self from sh import ErrorReturnCode py = create_tmp_test ( ) self . assertRaises ( ErrorReturnCode , python , py . name ) try : python ( py . name ) except Exception as e : self . assertEqual ( e . exit_code , 3 )
self py = create_tmp_test ( ) data = b ' 1234 ' out = python ( py . name , _in = data ) self . assertEqual ( out , " 1234 " )
self py = create_tmp_test ( ) out = python . bake ( py . name ) . bake ( " bake1 " ) . bake ( " bake2 " ) ( ) self . assertEqual ( " [ ' bake1 ' , ' bake2 ' ] " , out )
self py = create_tmp_test ( " exit(0) " ) sh . python ( py . name , _fg = True py = create_tmp_test ( " exit(0) " ) sh . python ( py . name , _fg = True )
self py = create_tmp_test ( ) p = python ( py . name , _ok_code = 49 , _bg = True ) self . assertEqual ( 49 , p . exit_code )
self return raise NotImplementedError ( " what ' s the best way to test a different \\ ' _encoding ' special keyword argument? " return raise NotImplementedError ( " what ' s the best way to test a different \\ ' _encoding ' special keyword argument? " )
self py = create_tmp_test ( ) out = python ( py . name , _in = " test\ " , _tty_in = True ) self . assertEqual ( " test\ " , out )
self import sh _sh = sh ( ) omg = _sh from omg import pytho import sh _sh = sh ( ) omg = _sh from omg import python
self , f self . _register ( f , select . POLLOUT , f self . _register ( f , select . POLLOUT )
self , msg , * args self . log . debug ( self . _format_msg ( msg , * args ) , msg , * args self . log . debug ( self . _format_msg ( msg , * args ) )
self , msg , * args self . log . error ( self . _format_msg ( msg , * args ) , msg , * args self . log . error ( self . _format_msg ( msg , * args ) )
self , msg , * args self . log . exception ( self . _format_msg ( msg , * args ) , msg , * args self . log . exception ( self . _format_msg ( msg , * args ) )
self exc = None try : exc = self . _output_thread_exc_queue . get ( False ) except Empty : pass return ex exc = None try : exc = self . _output_thread_exc_queue . get ( False ) except Empty : pass return exc
self exc = None try : exc = self . _bg_thread_exc_queue . get ( False ) except Empty : pass return ex exc = None try : exc = self . _bg_thread_exc_queue . get ( False ) except Empty : pass return exc
self , buf self . _stdin_stream . stream_bufferer . change_buffering ( buf , buf self . _stdin_stream . stream_bufferer . change_buffering ( buf )
self , buf self . _stderr_stream . stream_bufferer . change_buffering ( buf , buf self . _stderr_stream . stream_bufferer . change_buffering ( buf )
self return " " . encode ( self . call_args [ " encoding " ] ) . join ( self . _stdout return " " . encode ( self . call_args [ " encoding " ] ) . join ( self . _stdout )
self self . log . debug ( " killing " ) self . signal ( signal . SIGKILL self . log . debug ( " killing " ) self . signal ( signal . SIGKILL )
ev , timeout = None triggered = ev . wait ( timeout ) if IS_PY26 : triggered = ev . is_set ( ) return triggere, timeout = None triggered = ev . wait ( timeout ) if IS_PY26 : triggered = ev . is_set ( ) return triggered
path orig_path = os . getcwd ( ) os . chdir ( path ) try : yield finally : os . chdir ( orig_path )
pieces if " + " in pieces . get ( " closest-tag " , " " ) : return " . " return " + "
parser parser . addoption ( " --runslow " , action = " store_true " , help = " run slow tests " er parser . addoption ( " --runslow " , action = " store_true " , help = " run slow tests " )
x return getattr ( x , " __dask_optimize__ " , dont_optimize turn getattr ( x , " __dask_optimize__ " , dont_optimize )
d return type ( d ) . __name__ , normalize_token ( list ( d . items ( ) ) turn type ( d ) . __name__ , normalize_token ( list ( d . items ( ) ) )
s return normalize_token ( sorted ( s , key = str ) turn normalize_token ( sorted ( s , key = str ) )
buf return mmh3 . hash_bytes ( buf )
buf , hasher = None h = hash_buffer ( buf , hasher ) s = binascii . b2a_hex ( h ) return s . decode ( )
dsk , dependencies = None return _toposort ( dsk , dependencies = dependencies )
q while True : try : return q . get ( block = True , timeout = 0 . 1 ) except Empty : pasile True : try : return q . get ( block = True , timeout = 0 . 1 ) except Empty : pass
ind , coll if isinstance ( ind , list ) : return tuple ( [ nested_get ( i , coll ) for i in ind ] ) else : return coll [ ind ]
dsk , keys , ** kwargs kwargs . pop ( " num_workers " , None ) return get_async ( apply_sync , 1 , dsk , keys , ** kwargs )
x return x - turn x - 1
self , toplevel , func = None def wrapper ( func ) : self . _lazy [ toplevel ] = func return func return wrapper ( func ) if func is not None else wrapper
tup , loc , val L = list ( tup ) L [ loc ] = val return tuple ( L )
cls , op raise NotImplementedError
x try : return str ( hash ( x ) ) except TypeError : return str ( hash ( str ( x ) ) y : return str ( hash ( x ) ) except TypeError : return str ( hash ( str ( x ) ) )
self return self . layer return self . layers
self return [ value for _ , value in self . items ( ) return [ value for _ , value in self . items ( ) ]
lol , nblocks f = lambda t : ( t [ 0 ] , ) + tuple ( 0 if d == 1 else i for i , d in zip ( t [ 1 : ] , nblocks ) ) return homogeneous_deepmap ( f , lol )
self return self [ 0 ]
self , key , dsk , state self . starttimes [ key ] = default_timer ( , key , dsk , state self . starttimes [ key ] = default_timer ( )
m return getattr , ( m . __objclass__ , m . __name__ turn getattr , ( m . __objclass__ , m . __name__ )
method def _inner ( self , other ) : return method ( other , self ) return _inner
vcs , method def decorate ( f ) : """ Store f in HANDLERS[vcs][method] . """ if vcs not in HANDLERS : HANDLERS [ vcs ] = { } HANDLERS [ vcs ] [ method ] = f return f return decorate
pieces if " + " in pieces . get ( " closest-tag " , " " ) : return " . " return " + "
cb if isinstance ( cb , Callback ) : return cb . _callback elif isinstance ( cb , tuple ) : return cb else : raise TypeError ( " Callbacks must be either `Callback` or `tuple` " )
self return self . map_partitions ( getattr , " index " , token = self . _name + " -index " , meta = self . _meta . index )
self return IndexCallable ( self . _partitions )
self , cond , other = np . nan return map_partitions ( M . where , self , cond , other , cond , other = np . nan return map_partitions ( M . where , self , cond , other )
self return self . map_partitions ( M . isnull return self . map_partitions ( M . isnull )
cls , name , op raise NotImplementedError
self , columns_or_index if isinstance ( columns_or_index , list ) : return any ( self . _is_index_level_reference ( n ) for n in columns_or_index ) else : return self . _is_index_level_reference ( columns_or_index )
self return CategoricalAccessor ( self return CategoricalAccessor ( self )
self return StringAccessor ( self )
self , q = 0 . 5 , method = " default " return quantile ( self , q , method = method )
self return sel return self
self return self . _meta . get_dtype_counts ( return self . _meta . get_dtype_counts ( )
self , threshold return self . map_partitions ( M . clip_upper , threshold = threshold , threshold return self . map_partitions ( M . clip_upper , threshold = threshold )
self , index = False from . io import to_bag return to_bag ( self , index )
self , decimals = 0 return elemwise ( M . round , self , decimals , decimals = 0 return elemwise ( M . round , self , decimals )
func , * args , ** kwargs with raise_on_meta_error ( funcname ( func ) , udf = kwargs . pop ( " udf " , False ) ) : return func ( * _extract_meta ( args , True ) , ** _extract_meta ( kwargs , True ) )
x get_parallel_type ( x ) return isinstance ( x , parallel_types ( ) )
index , concat_result final_series = concat_result . sort_index ( ) final_series = index . to_series ( ) . map ( final_series ) return final_seriex , concat_result final_series = concat_result . sort_index ( ) final_series = index . to_series ( ) . map ( final_series ) return final_series
g , levels return g . groupby ( level = levels , sort = False ) . sum ( levels return g . groupby ( level = levels , sort = False ) . sum ( )
g , levels return levels return g
df , sum_column , count_column return df [ sum_column ] / df [ count_column , sum_column , count_column return df [ sum_column ] / df [ count_column ]
self , arg , split_every = None , split_out = 1 return self . aggregate ( arg , split_every = split_every , split_out = split_out , arg , split_every = None , split_out = 1 return self . aggregate ( arg , split_every = split_every , split_out = split_out )
self , iindexer iindexer = _maybe_partial_time_string ( self . obj . _meta_nonempty . index , iindexer , kind = " loc " ) return iindexer
self , ** kwargs if self . known : return self . _series categories = self . _property_map ( " categories " ) . unique ( ) . compute ( ** kwargs ) return self . set_categories ( categories . values )
self if not self . known : return self . _series out = self . _series . copy ( ) out . _meta = clear_known_categories ( out . _meta ) return out
self return self . _delegate_property ( self . _series . _meta , " cat " , " ordered " return self . _delegate_property ( self . _series . _meta , " cat " , " ordered " )
df , npartitions return hash_object_dispatch ( df , index = False ) % int ( npartitions )
args list ( args ) return list ( args ) return 0
self return self . _call_method ( " cov " return self . _call_method ( " cov " )
self , ddof = 1 return self . _call_method ( " std " , ddof = 1 , ddof = 1 return self . _call_method ( " std " , ddof = 1 )
self , quantile return self . _call_method ( " quantile " , quantile , quantile return self . _call_method ( " quantile " , quantile )
self , * others , ** kwargs return self . str . cat ( others = others , ** kwargs , * others , ** kwargs return self . str . cat ( others = others , ** kwargs )
self return self . _agg ( " first " return self . _agg ( " first " )
self return self . _agg ( " mean " return self . _agg ( " mean " )
self return self . _agg ( " max " return self . _agg ( " max " )
self return self . _agg ( " ohlc " return self . _agg ( " ohlc " )
self return self . _agg ( " var " return self . _agg ( " var " )
df , openfile , kwargs with openfile as f : df . to_json ( f , ** kwargs , openfile , kwargs with openfile as f : df . to_json ( f , ** kwargs )
n , rstate return rstate . choice ( names , size = n rstate return rstate . choice ( names , size = n )
pd_to_hdf , lock , args , kwargs = None if lock : lock . acquire ( ) try : pd_to_hdf ( * args , ** kwargs ) finally : if lock : lock . release ( ) return None
def if SKIP_FASTPARQUET : pytest . skip ( SKIP_FASTPARQUET_REASON if SKIP_FASTPARQUET : pytest . skip ( SKIP_FASTPARQUET_REASON )
def assert shuffle ( d , d . b ) . npartitions == d . npartitionassert shuffle ( d , d . b ) . npartitions == d . npartitions
def assert_eq ( d . index , full . index assert_eq ( d . index , full . index )
df_left return dd . from_pandas ( df_left , npartitions = 1 , sort = False eft return dd . from_pandas ( df_left , npartitions = 1 , sort = False )
self self . _results . clear ( ) del self . results [ : ] self . _dsk = { }
self self . results = [ self . results = [ ]
start , end , min_span return start , max ( end , start + min_span )
dsk return valmap ( lazify_task , dsk )
self return ( self . dask , self . key return ( self . dask , self . key )
self , split_every = None return self . reduction ( count , sum , split_every = split_every )
grouper , group , p , barrier_token d = groupby ( grouper , p . get ( group , lock = False ) ) return list ( d . items ( ) )
f , iters , iter_kwarg_keys = None , kwargs = None if kwargs : f = partial ( f , ** kwargs ) iters = [ iter ( a ) for a in iters ] return _MapChunk ( f , iters , kwarg_keys = iter_kwarg_keys )
lazy_file with lazy_file as f : for line in f : yield lin_file with lazy_file as f : for line in f : yield line
def assert b . __dask_keys__ ( ) == sorted ( dsk . keys ( ) assert b . __dask_keys__ ( ) == sorted ( dsk . keys ( ) )
dsk return dsk , { k : get_dependencies ( dsk , k ) for k in dsk return dsk , { k : get_dependencies ( dsk , k ) for k in dsk }
@ assert get_context ( ) is multiprocessing with pytest . warns ( UserWarning ) : with dask . config . set ( { " multiprocessing . context " : " forkserver " } ) : assert get_context ( ) is multiprocessing
a , b return all ( a . get ( k ) == v for k , v in b . items ( ) )
def assert sizeof ( 1 ) == getsizeof ( 1 assert sizeof ( 1 ) == getsizeof ( 1 )
a from crick import TDigest t = TDigest ( ) t . update ( a ) return om crick import TDigest t = TDigest ( ) t . update ( a ) return t
self return tuple ( map ( len , self . chunks ) return tuple ( map ( len , self . chunks ) )
self return self . _chunk return self . _chunks
self return self . dtype . itemsize
self , columns = None , index = None from . . dataframe import from_dask_array return from_dask_array ( self , columns = columns , index = index )
self return IndexCallable ( self . _vindex )
self return sel return self
self , k , axis = - 1 , split_every = None from . reductions import topk return topk ( self , k , axis = axis , split_every = split_every )
self , axis = None from . routines import squeeze return squeeze ( self , axis , axis = None from . routines import squeeze return squeeze ( self , axis )
self , axis1 , axis2 from . routines import swapaxes return swapaxes ( self , axis1 , axis2 , axis1 , axis2 from . routines import swapaxes return swapaxes ( self , axis1 , axis2 )
x , out , index , lock , return_stored return load_store_chunk ( x , out , index , lock , return_stored , False out , index , lock , return_stored return load_store_chunk ( x , out , index , lock , return_stored , False )
a if type ( a ) is list : return tuple ( [ len ( a ) ] + list ( shapelist ( a [ 0 ] ) ) ) else : return ( )
x return x [ None , . . . turn x [ None , . . . ]
a , fill_value = None a = asanyarray ( a ) return a . map_blocks ( np . ma . filled , fill_value = fill_value fill_value = None a = asanyarray ( a ) return a . map_blocks ( np . ma . filled , fill_value = fill_value )
x , v1 , v2 x = asanyarray ( x ) return x . map_blocks ( np . ma . masked_inside , v1 , v2 v1 , v2 x = asanyarray ( x ) return x . map_blocks ( np . ma . masked_inside , v1 , v2 )
a a = asanyarray ( a ) return a . map_blocks ( np . ma . getmaskarray = asanyarray ( a ) return a . map_blocks ( np . ma . getmaskarray )
old_chunks , new_chunks old_to_new = _old_to_new ( old_chunks , new_chunks ) cross1 = product ( * old_to_new ) cross = chain ( tuple ( product ( * cr ) ) for cr in cross1 ) return cross
it total = 0 for x in it : total_previous = total total += x yield ( total_previous , total otal = 0 for x in it : total_previous = total total += x yield ( total_previous , total )
last , new return ( last [ 1 ] , last [ 1 ] + new , new return ( last [ 1 ] , last [ 1 ] + new )
a , b import scipy . linalg return scipy . linalg . solve_triangular ( a , b , lower = True b import scipy . linalg return scipy . linalg . solve_triangular ( a , b , lower = True )
a , axis = 0 return da . sum ( a * a , axis )
a , axis = 0 s = da . sum ( a , axis ) return s * s
m return flip ( m , 0 turn flip ( m , 0 )
a , * choices return np . choose ( a , choices * choices return np . choose ( a , choices )
a , choices return elemwise ( variadic_choose , a , * choices choices return elemwise ( variadic_choose , a , * choices )
indices , func_kwargs return np . stack ( np . unravel_index ( indices , ** func_kwargs ) ces , func_kwargs return np . stack ( np . unravel_index ( indices , ** func_kwargs ) )
target , source = None target . __doc__ = skip_doctest ( source . __doc__ ) return targeet , source = None target . __doc__ = skip_doctest ( source . __doc__ ) return target
x , y res1 = x // y res2 = x % y return res1 , res y res1 = x // y res2 = x % y return res1 , res2
where return _expander ( tuple ( where ) )
self , seed = None self . _numpy_state . seed ( seed , seed = None self . _numpy_state . seed ( seed )
def assert_eq ( da . ones ( 4 , chunks = 2 ) [ . . . ] , np . ones ( 4 ) assert_eq ( da . ones ( 4 , chunks = 2 ) [ . . . ] , np . ones ( 4 ) )
def with pytest . raises ( ValueError ) : da . indices ( ( 1 , ) , chunks = tuple ( ) with pytest . raises ( ValueError ) : da . indices ( ( 1 , ) , chunks = tuple ( ) )
shape x = da . random . random ( shape ) assert np . shape ( x ) == shape x = da . random . random ( shape ) assert np . shape ( x ) == shape
self , stage self . stats . update ( stage ) self . stats_queue . put ( self . stats , stage self . stats . update ( stage ) self . stats_queue . put ( self . stats )
self , obs return self . _features . transform_obs ( obs , obs return self . _features . transform_obs ( obs )
def app . run ( main app . run ( main )
def app . run ( main app . run ( main )
self , replay_path with gfile . Open ( self . abs_replay_path ( replay_path ) , " rb " ) as f : return f . read ( )
cls return cls . __name_return cls . __name__
cls if sys . platform == " cygwin " : return if sys . platform == " cygwin " : return 1
self , names , expected_output self . assertEqual ( sc2_env . crop_and_deduplicate_names ( names ) , expected_output , names , expected_output self . assertEqual ( sc2_env . crop_and_deduplicate_names ( names ) , expected_output )
self return [ process . port for process in self . _processes ]
self return self . _controllers [ 0 ] . data ( return self . _controllers [ 0 ] . data ( )
self return self . _versio return self . _version
cls , obj return cls ( obj . x , obj . y )
cls return cls ( random . random ( ) , random . random ( ) )
self , other dx = self . x - other . x dy = self . y - other . y return math . sqrt ( dx ** 2 + dy ** 2 )
self return Point ( abs ( self . x ) , abs ( self . y ) )
self return math . sqrt ( self . x ** 2 + self . y ** 2 )
self , angle = 180 return self . rotate_deg ( random . uniform ( - angle , angle ) , angle = 180 return self . rotate_deg ( random . uniform ( - angle , angle ) )
self , pt , radius return self . dist ( pt ) < radius
self return Point ( self . l + self . r , self . t + self . b ) / return Point ( self . l + self . r , self . t + self . b ) / 2
self return self . b - self . return self . b - self . t
self return Point ( self . r , self . t return Point ( self . r , self . t )
self return Point ( self . l , self . b return Point ( self . l , self . b )
self return Rect ( self . tl . round ( ) , self . br . round ( ) return Rect ( self . tl . round ( ) , self . br . round ( ) )
self , pt return ( self . l < pt . x and self . r > pt . x and self . t < pt . y and self . b > pt . y )
self self . obs . player_common . idle_worker_count = 1 self . assertAvail ( [ " select_idle_worker " ] self . obs . player_common . idle_worker_count = 1 self . assertAvail ( [ " select_idle_worker " ] )
self self . obs . player_common . warp_gate_count = 1 self . assertAvail ( [ " select_warp_gates " ] self . obs . player_common . warp_gate_count = 1 self . assertAvail ( [ " select_warp_gates " ] )
self with self . assertRaises ( TypeError ) : features . _to_point ( ( 32 , None ) with self . assertRaises ( TypeError ) : features . _to_point ( ( 32 , None ) )
self with self . assertRaises ( ValueError ) : features . Dimensions ( screen = 64 , minimap = - 32 with self . assertRaises ( ValueError ) : features . Dimensions ( screen = 64 , minimap = - 32 )
self with self . assertRaises ( ValueError ) : features . parse_agent_interface_format ( with self . assertRaises ( ValueError ) : features . parse_agent_interface_format ( )
self return self . _minima return self . _minimap
self return self . _action_spac return self . _action_space
self return self . _camera_width_world_unit return self . _camera_width_world_units
self return self . _use_raw_unit return self . _use_raw_units
self return self . _raw_resolutio return self . _raw_resolution
self return self . _use_raw_action return self . _use_raw_actions
self return self . _use_unit_count return self . _use_unit_counts
self return self . _action_delay_f return self . _action_delay_fn
self return self . _allow_cheating_layer return self . _allow_cheating_layers
error_enum def decorator ( func ) : @ functools . wraps ( func ) def _check_error ( * args , ** kwargs ) : return check_error ( func ( * args , ** kwargs ) , error_enum ) return _check_error return decorator
self return self . status == protocol . Status . ende return self . status == protocol . Status . ended
self return self . _client . send ( game_info = sc_pb . RequestGameInfo ( ) )
self return self . _client . send ( available_maps = sc_pb . RequestAvailableMaps ( ) return self . _client . send ( available_maps = sc_pb . RequestAvailableMaps ( ) )
self return self . _client . send ( leave_game = sc_pb . RequestLeaveGame ( ) )
self self . num = 0 self . min = 1000000000 self . max = 0 self . sum = 0 self . sum_sq = self . num = 0 self . min = 1000000000 self . max = 0 self . sum = 0 self . sum_sq = 0
self return 0 if self . num == 0 else self . sum / self . nu return 0 if self . num == 0 else self . sum / self . num
self return self . _statu return self . _status
self , s , * args r sys . stderr . write ( ( s + " \ " ) % args ) sys . stderr . flush ( )
self , request with sw ( " serialize_request " ) : request_str = request . SerializeToString ( ) with sw ( " write_request " ) : with catch_websocket_connection_errors ( ) : self . _sock . send ( request_str )
action , action_space if action_space == ActionSpace . FEATURES : return action . action_feature_layer elif action_space == ActionSpace . RGB : return action . action_render else : raise ValueError ( " Unexpected value for action_space: %s " % action_space )
action , action_space , control_group_act , control_group_id del action_space select = action . action_ui . control_group select . action = control_group_act select . control_group_index = control_group_id
action , action_space , build_queue_id del action_space action . action_ui . production_panel . unit_index = build_queue_id
action , action_space , ability_id del action_space action . action_ui . toggle_autocast . ability_id = ability_id
action , ability_id , unit_tags action_cmd = action . action_raw . toggle_autocast action_cmd . ability_id = ability_id if not isinstance ( unit_tags , ( tuple , list ) ) : unit_tags = [ unit_tags ] action_cmd . unit_tags . extend ( unit_tags )
cls def factory ( i , name ) : return cls ( i , name , ( 0 , 0 ) , lambda a : point . Point ( * a ) . floor ( ) , None , None ) return factory
cls , id_ , name , function_type , avail_fn = always return cls ( id_ , name , 0 , 0 , function_type , FUNCTION_TYPES [ function_type ] , avail_fn , True )
cls , id_ , name , args return cls ( id_ , name , None , None , None , args , None , False )
self self . _queued_hotkey = " " self . _queued_action = Non self . _queued_hotkey = " " self . _queued_action = None
def raise ValueError ( raise ValueError ( )
self with self . assertRaises ( ValueError ) : portspicker . pick_contiguous_unused_ports ( 0 with self . assertRaises ( ValueError ) : portspicker . pick_contiguous_unused_ports ( 0 )
self , names with self . assertRaises ( ValueError ) : named_array . NamedNumpyArray ( [ 1 , 3 , 6 ] , names , names with self . assertRaises ( ValueError ) : named_array . NamedNumpyArray ( [ 1 , 3 , 6 ] , names )
self self . assertEqual ( 10 , point . Point ( 5 , 10 ) . max_dim ( ) self . assertEqual ( 10 , point . Point ( 5 , 10 ) . max_dim ( ) )
self , pt for transform in self . transforms : pt = transform . fwd_pt ( pt ) return p , pt for transform in self . transforms : pt = transform . fwd_pt ( pt ) return pt
self , dist return dis , dist return dist
self , pt return pt . floor ( , pt return pt . floor ( )
self , pt return pt . floor ( ) + 0 . , pt return pt . floor ( ) + 0 . 5
self return vars ( self return vars ( self )
self , feature_units self . _feature_units = feature_units return sel , feature_units self . _feature_units = feature_units return self
self super ( TestCase , self ) . setUp ( ) stopwatch . sw . clear ( ) stopwatch . sw . enable ( super ( TestCase , self ) . setUp ( ) stopwatch . sw . clear ( ) stopwatch . sw . enable ( )
v return " . " . join ( v . split ( " . " ) [ : 2 ] turn " . " . join ( v . split ( " . " ) [ : 2 ] )
configlist , item for file in configlist : if file . startswith ( item ) : return configlist . index ( file ) return Noniglist , item for file in configlist : if file . startswith ( item ) : return configlist . index ( file ) return None
self return trch . Parameter_hasValue ( self . param return trch . Parameter_hasValue ( self . param )
self return trch . Parameter_isHidden ( self . param return trch . Parameter_isHidden ( self . param )
self return trch . Parameter_isValid ( self . param return trch . Parameter_isValid ( self . param )
self trch . Parameter_resetValue ( self . param trch . Parameter_resetValue ( self . param )
self , value trch . Parameter_LocalFile_setValue ( self . param , os . path . normpath ( value ) , value trch . Parameter_LocalFile_setValue ( self . param , os . path . normpath ( value ) )
self return str ( trch . Parameter_Port_getValue ( self . param ) return str ( trch . Parameter_Port_getValue ( self . param ) )
self , value trch . Parameter_Port_setValue ( self . param , int ( value ) , value trch . Parameter_Port_setValue ( self . param , int ( value ) )
self return str ( trch . Parameter_S16_getValue ( self . param ) return str ( trch . Parameter_S16_getValue ( self . param ) )
self return str ( trch . Parameter_S64_getValue ( self . param ) return str ( trch . Parameter_S64_getValue ( self . param ) )
self return str ( trch . Parameter_S8_getValue ( self . param ) return str ( trch . Parameter_S8_getValue ( self . param ) )
self , value trch . Parameter_Socket_setValue ( self . param , int ( value ) , value trch . Parameter_Socket_setValue ( self . param , int ( value ) )
self , value trch . Parameter_String_setValue ( self . param , value , value trch . Parameter_String_setValue ( self . param , value )
self return str ( trch . Parameter_U32_getValue ( self . param ) return str ( trch . Parameter_U32_getValue ( self . param ) )
self , value trch . Parameter_U64_setValue ( self . param , long ( value ) , value trch . Parameter_U64_setValue ( self . param , long ( value ) )
self return self . TcpPort_List_getValue ( return self . TcpPort_List_getValue ( )
self return trch . Paramgroup_getName ( self . group return trch . Paramgroup_getName ( self . group )
self return trch . Paramgroup_getNumParameters ( self . group return trch . Paramgroup_getNumParameters ( self . group )
self return trch . Paramgroup_isValid ( self . group return trch . Paramgroup_isValid ( self . group )
self , name return trch . Paramgroup_matchName ( self . group , str ( name ) , name return trch . Paramgroup_matchName ( self . group , str ( name ) )
self return trch . Paramchoice_isValid ( self . choice return trch . Paramchoice_isValid ( self . choice )
self , value trch . Paramchoice_setValue ( self . choice , str ( value ) , value trch . Paramchoice_setValue ( self . choice , str ( value ) )
self v = self . getDefaultValue ( ) if not v : v = ' ' self . setValue ( v v = self . getDefaultValue ( ) if not v : v = ' ' self . setValue ( v )
self return ' choice ' return ' choice '
self return self . configVersio return self . configVersion
self , name if self . findParamchoice ( name ) : return True else : return Fals , name if self . findParamchoice ( name ) : return True else : return False
self , name if self . findParameter ( name ) : return True else : return Fals , name if self . findParameter ( name ) : return True else : return False
self , name return self . findOption ( name ) . getDescription ( , name return self . findOption ( name ) . getDescription ( )
self , name return self . findOption ( name ) . getType ( , name return self . findOption ( name ) . getType ( )
self , name return self . findOption ( name ) . getAttributeList ( , name return self . findOption ( name ) . getAttributeList ( )
str , iswordfun return [ x for x in word_pattern . split ( markwords ( str , iswordfun ) ) if x != " " , iswordfun return [ x for x in word_pattern . split ( markwords ( str , iswordfun ) ) if x != " " ]
self , rect , attr = None , fill = ' ' ' ' ' Fill Rectangle . ' ' ' raise NotImplementedErro , rect , attr = None , fill = ' ' ' ' ' Fill Rectangle . ' ' ' raise NotImplementedError
self , visible = None , size = None pas , visible = None , size = None pass
self self . bell_count += self . bell_count += 1
self , text self . text += tex , text self . text += text
def import _dsz if _dsz . dszObj . check_for_stop ( ) : return True else : return Falsimport _dsz if _dsz . dszObj . check_for_stop ( ) : return True else : return False
str dsz . ui . Echo ( str , dsz . ERROR , checkForStop = False dsz . ui . Echo ( str , dsz . ERROR , checkForStop = False )
demarsh import socket return socket . ntohl ( demarsh . GetU32 ( ) rsh import socket return socket . ntohl ( demarsh . GetU32 ( ) )
def import mcl_platform . tasking return mcl_platform . tasking . GetContext ( import mcl_platform . tasking return mcl_platform . tasking . GetContext ( )
status import mcl_platform . tasking mcl_platform . tasking . TaskSetStatus ( status us import mcl_platform . tasking mcl_platform . tasking . TaskSetStatus ( status )
self , data self . data = dat , data self . data = data
self , path self . m_xml . AddSubElementWithText ( ' SearchPath ' , ' %s ' % path , path self . m_xml . AddSubElementWithText ( ' SearchPath ' , ' %s ' % path )
subdir = None import mcl_platform . tasking . resource return mcl_platform . tasking . resource . GetDir ( subdir ir = None import mcl_platform . tasking . resource return mcl_platform . tasking . resource . GetDir ( subdir )
self return self . m_nam return self . m_name
self return self . m_namespac return self . m_namespace
self return self . m_namespaceDef return self . m_namespaceDefs
self , text self . m_text = XmlOutput . CleanText ( text , text self . m_text = XmlOutput . CleanText ( text )
self return self . m_nanosecond return self . m_nanoseconds
self return self . m_isVali return self . m_isValid
self , addr self . address = add , addr self . address = addr
self if self . m_type == self . IPADDR_TYPE_IPV4 : return self . m_ipv4 else : return self . m_ipv if self . m_type == self . IPADDR_TYPE_IPV4 : return self . m_ipv4 else : return self . m_ipv6
self , scope_id self . m_ipv6_scope_id = scope_i , scope_id self . m_ipv6_scope_id = scope_id
self , key , instance = - 1 return self . _GetCacheEntryData ( key , MSG_TYPE_BOOL , instance , key , instance = - 1 return self . _GetCacheEntryData ( key , MSG_TYPE_BOOL , instance )
self , key , msg , endianess = MSG_TYPE_MODIFIER_NATIVE_ENDIAN self . Add ( MSG_TYPE_MSG , key , msg . Serialize ( ) , endianess , key , msg , endianess = MSG_TYPE_MODIFIER_NATIVE_ENDIAN self . Add ( MSG_TYPE_MSG , key , msg . Serialize ( ) , endianess )
self , key , data , endianess = MSG_TYPE_MODIFIER_NATIVE_ENDIAN self . Add ( MSG_TYPE_U8 , key , data , endianess , key , data , endianess = MSG_TYPE_MODIFIER_NATIVE_ENDIAN self . Add ( MSG_TYPE_U8 , key , data , endianess )
self , key , data , endianess = MSG_TYPE_MODIFIER_NATIVE_ENDIAN self . Add ( MSG_TYPE_U16 , key , data , endianess , key , data , endianess = MSG_TYPE_MODIFIER_NATIVE_ENDIAN self . Add ( MSG_TYPE_U16 , key , data , endianess )
self , prefix , suffix , subDir = None , utf8 = True raise RuntimeError ( ' DataHandlerOutput . CreateLogFile must be overriden ' , prefix , suffix , subDir = None , utf8 = True raise RuntimeError ( ' DataHandlerOutput . CreateLogFile must be overriden ' )
self return self . m_dat return self . m_data
self return self . m_priorit return self . m_priority
