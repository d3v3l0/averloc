response text = response . text . lstrip ( ) . lower ( ) return text . startswith ( ' <html ' ) or text . startswith ( ' <!doctype ' )
self , data for ( name , value ) in data . items ( ) : try : self . set checkbox ( { name : value } , uncheck other boxes = false ) continue except invalid form method : pass try : self . set radio ( { name : value } ) continue except invalid form method : pass raise link not found error ( " no input checkbox/radio named " + name )
self return self . state . url
self , url , * args , ** kwargs if self . verbose == 1 : sys . stdout . write ( ' . ' ) sys . stdout . flush ( ) elif self . verbose >= 2 : print ( url ) resp = self . get ( url , * args , ** kwargs ) self . state = browser state ( page = resp . soup , url = resp . url , request = resp . request ) return resp
self , page text , url = none , soup config = none soup config = soup config or self . soup config self . state = browser state ( page = bs4 . beautiful soup ( page text , ** soup config ) , url = url )
httpbin browser = mechanicalsoup . browser ( ) resp = browser . get ( httpbin + " /cookies/set?k1=v1&k2=v2 " ) assert resp . json ( ) == { ' cookies ' : { ' k1 ' : ' v1 ' , ' k2 ' : ' v2 ' } } jar = browser . get cookiejar ( ) assert jar . get ( ' k1 ' ) == ' v1 ' assert jar . get ( ' k2 ' ) == ' v2 '
def with pytest . raises ( mechanicalsoup . link not found error ) : raise mechanicalsoup . utils . link not found error with pytest . raises ( exception ) : raise mechanicalsoup . utils . link not found errowith pytest . raises ( mechanicalsoup . link not found error ) : raise mechanicalsoup . utils . link not found error with pytest . raises ( exception ) : raise mechanicalsoup . utils . link not found error
httpbin browser = mechanicalsoup . stateful browser ( raise on 404 = true ) with pytest . raises ( mechanicalsoup . link not found error ) : resp = browser . open ( httpbin + " /nosuchpage " ) resp = browser . open ( httpbin . url ) assert resp . status code == 20bin browser = mechanicalsoup . stateful browser ( raise on 404 = true ) with pytest . raises ( mechanicalsoup . link not found error ) : resp = browser . open ( httpbin + " /nosuchpage " ) resp = browser . open ( httpbin . url ) assert resp . status code == 200
def with mechanicalsoup . stateful browser ( ) as browser : assert browser . session is not none assert browser . session is none
httpbin browser = mechanicalsoup . stateful browser ( ) open legacy httpbin ( browser , httpbin ) tmpdir = tempfile . mkdtemp ( ) tmpfile = tmpdir + ' /existing . png ' with open ( tmpfile , " w " ) as f : f . write ( " initial content " ) current url = browser . url current page = browser . page response = browser . download link ( ' image/png ' , tmpfile ) assert browser . url == current url assert browser . page == current page assert os . path . isfile ( tmpfile ) assert file get contents ( tmpfile ) == response . content assert response . content [ : 4 ] == b ' \\x89 png '
self return self . get value ( ' type ' , ' /(\\\\w+) ' ) . decode ( ' ascii ' )
self , key , pdf file object number = int ( self . get value ( key , ' (\\\\d+) 0 r ' ) ) return type ( self ) ( object number , pdf file . read object ( object number ) )
element , box , get image from uri , base url if isinstance ( box , boxes . table cell box ) : # html 4 . 01 gives special meaning to colspan=0 # http://www . w3 . org/ tr/html401/struct/tables . html#adef rowspan # but html 5 removed it # http://www . w3 . org/ tr/html5/tabular data . html#attr tdth colspan # rowspan=0 is still there though . integer attribute ( element , box , ' colspan ' ) integer attribute ( element , box , ' rowspan ' , minimum = 0 ) return [ box ]
string return string . strip ( html whitespace )
base url , url , allow relative , context , context args if url is absolute ( url ) : return iri to uri ( url ) elif base url : return iri to uri ( urljoin ( base url , url ) ) elif allow relative : return iri to uri ( url ) else : logger . error ( ' relative uri reference without a base uri: ' + context , * context args ) return none
self return self . padding height ( ) + self . border top width + self . border bottom width
counter name , lookup counter values , anchor name , missing target counters if counter name not in lookup counter values : missing counters = missing target counters . setdefault ( anchor name , [ ] ) if counter name not in missing counters : missing counters . append ( counter name )
box , has non whitespace = re . compile ( ' \\\\ s ' ) . search return isinstance ( box , boxes . text box ) and not has non whitespace ( box . text )
context , box , available width return min ( max ( min content width ( context , box , outer = false ) , available width ) , max content width ( context , box , outer = false ) )
self return self . padding plus border + self . margin a + self . margin return self . padding plus border + self . margin a + self . margin b
self if self . min content size is none : self . min content size = min content width ( self . context , self . box , outer = false ) return self . min content siz if self . min content size is none : self . min content size = min content width ( self . context , self . box , outer = false ) return self . min content size
box , containing block for side in [ ' top ' , ' right ' , ' bottom ' , ' left ' ] : if getattr ( box , ' margin ' + side ) == ' auto ' : setattr ( box , ' margin ' + side , 0 ) inline replaced box width height ( box , containing block )
box , containing block replaced box width . without min max ( box , containing block ) block level width . without min max ( box , containing block , containing block replaced box width . without min max ( box , containing block ) block level width . without min max ( box , containing block )
seq return zip ( reversed ( range ( len ( seq ) ) ) , reversed ( seq ) )
computer , name , values for type , value in values : if type in ( ' linear gradient ' , ' radial gradient ' ) : value . stop positions = tuple ( length ( computer , name , pos ) if pos is not none else none for pos in value . stop positions ) if type == ' radial gradient ' : value . center , = compute position ( computer , name , ( value . center , ) ) if value . size type == ' explicit ' : value . size = length or percentage tuple ( computer , name , value . size ) return values
token keyword = get keyword ( token ) if keyword in ( ' open quote ' , ' close quote ' , ' no open quote ' , ' no close quote ' ) : return keyword
tokens , base url parsed tokens = [ get content list token ( token , base url ) for token in tokens ] if none not in parsed tokens : return parsed tokens
token return parse color ( token n return parse color ( token )
token if token . type == ' ident ' : return ' auto ' if token . lower value == ' auto ' else token . value
token length = get length ( token , percentage = true ) if length : return length if get keyword ( token ) == ' auto ' : return ' auto '
keyword return keyword in ( ' inline ' , ' block ' , ' inline block ' , ' list item ' , ' none ' , ' table ' , ' inline table ' , ' table caption ' , ' table row group ' , ' table header group ' , ' table footer group ' , ' table row ' , ' table column group ' , ' table column ' , ' table cell ' , ' flex ' , ' inline flex ' )
keyword return keyword in ( ' left ' , ' right ' , ' none ' )
tokens if len ( tokens ) == 1 and tokens [ 0 ] . type == ' string ' : return tokens [ 0 ] . value elif tokens and all ( token . type == ' ident ' for token in tokens ) : return ' ' . join ( token . value for token in tokens )
token if get keyword ( token ) == ' normal ' : return ' normal ' if token . type == ' number ' and token . value >= 0 : return dimension ( token . value , none ) if token . type == ' percentage ' and token . value >= 0 : return dimension ( token . value , ' % ' ) elif token . type == ' dimension ' and token . value >= 0 : return get length ( token )
keyword return keyword in ( ' auto ' , ' visible ' , ' hidden ' , ' scroll ' )
keyword return keyword in ( ' flex start ' , ' flex end ' , ' center ' , ' space between ' , ' space around ' , ' space evenly ' , ' stretch ' )
tokens return properties . font feature settings ( tokens )
tokens if len ( tokens ) == 1 : keyword = get keyword ( tokens [ 0 ] ) if keyword in ( ' normal ' , ' none ' , ' inherit ' ) : return [ ] values = [ ] for name , sub tokens in expand font variant ( tokens ) : try : values . append ( properties . validate non shorthand ( none , ' font variant ' + name , sub tokens , required = true ) ) except invalid values : return none return values
source , contexts page , = render pages ( source ) html , = page . children assert serialize stacking ( stacking context . from box ( html , page ) ) == contextce , contexts page , = render pages ( source ) html , = page . children assert serialize stacking ( stacking context . from box ( html , page ) ) == contexts
self return [ test ua stylesheet return [ test ua stylesheet ]
def page , = parse ( ' ' ' <style> html { var: 10px } p { width: var( var) } </style> <p></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 1page , = parse ( ' ' ' <style> html { var: 10px } p { width: var( var) } </style> <p></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 10
@ page , = render pages ( ' ' ' <style> p { text align: center; width: 0 } span { display: inline block } </style> <p><span>aaaaaaaaaaaaaaaaaaaaaaaaaa</span></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children span , = paragraph . children assert span . position x == ge , = render pages ( ' ' ' <style> p { text align: center; width: 0 } span { display: inline block } </style> <p><span>aaaaaaaaaaaaaaaaaaaaaaaaaa</span></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children span , = paragraph . children assert span . position x == 0
@ page , = render pages ( ' ' ' <div style= " top:100%; float:left " > ' ' ' ge , = render pages ( ' ' ' <div style= " top:100%; float:left " > ' ' ' )
@ assert pixels ( ' border current color ' , 2 , 2 , green 2x2 , ' ' ' <style> @page { size: 2px } html { color: red; border color: current color } body { color: lime; border: 1px solid; border color: inherit; margin: 0 } </style> <body> ' ' ' sert pixels ( ' border current color ' , 2 , 2 , green 2x2 , ' ' ' <style> @page { size: 2px } html { color: red; border color: current color } body { color: lime; border: 1px solid; border color: inherit; margin: 0 } </style> <body> ' ' ' )
@ assert pixels ( ' outline current color ' , 2 , 2 , green 2x2 , ' ' ' <style> @page { size: 2px } html { color: red; outline color: current color } body { color: lime; outline: 1px solid; outline color: inherit; margin: 1px } </style> <body> ' ' ' sert pixels ( ' outline current color ' , 2 , 2 , green 2x2 , ' ' ' <style> @page { size: 2px } html { color: red; outline color: current color } body { color: lime; outline: 1px solid; outline color: inherit; margin: 1px } </style> <body> ' ' ' )
@ assert pixels ( ' image translate x rotate90 ' , 12 , 12 , ' ' ' bb br bbbb bbbb bbbb ' ' ' , ' ' ' <style> @page { size: 12px; margin: 2px; background: #fff; } div { transform: translate x(3px) rotate(90deg); font size: 0; width: 4px } </style> <div><img src= " pattern . png " ></div> ' ' ' sert pixels ( ' image translate x rotate90 ' , 12 , 12 , ' ' ' bb br bbbb bbbb bbbb ' ' ' , ' ' ' <style> @page { size: 12px; margin: 2px; background: #fff; } div { transform: translate x(3px) rotate(90deg); font size: 0; width: 4px } </style> <div><img src= " pattern . png " ></div> ' ' ' )
@ assert pixels ( ' image in inline block ' , 8 , 8 , centered image , ' ' ' <style> @page { size: 8px } body { margin: 2px 0 0 2px; background: #fff; font size: 0 } </style> <div style= " display: inline block " > <p><img src=pattern . png></p> </div> ' ' ' sert pixels ( ' image in inline block ' , 8 , 8 , centered image , ' ' ' <style> @page { size: 8px } body { margin: 2px 0 0 2px; background: #fff; font size: 0 } </style> <div style= " display: inline block " > <p><img src=pattern . png></p> </div> ' ' ' )
@ assert pixels ( ' linear gradient ' , 9 , 5 , ' ' ' bb brrrrrr bb brrrrrr bb brrrrrr bb brrrrrr bb brrrrrr ' ' ' , ' ' ' <style>@page { size: 9px 5px; background: linear gradient( to right , blue 3px , blue 3px , red 3px , red 3px ) ' ' ' sert pixels ( ' linear gradient ' , 9 , 5 , ' ' ' bb brrrrrr bb brrrrrr bb brrrrrr bb brrrrrr bb brrrrrr ' ' ' , ' ' ' <style>@page { size: 9px 5px; background: linear gradient( to right , blue 3px , blue 3px , red 3px , red 3px ) ' ' ' )
@ pages = render pages ( ' ' ' <style> @page { size: 100px 100px } section { page: small } </style> <div> <section>large</section> </div> ' ' ' ) page1 , = pages assert ( page1 . width , page1 . height ) == ( 100 , 100 ges = render pages ( ' ' ' <style> @page { size: 100px 100px } section { page: small } </style> <div> <section>large</section> </div> ' ' ' ) page1 , = pages assert ( page1 . width , page1 . height ) == ( 100 , 100 )
@ pages = render pages ( ' ' ' <style> @page { size: 100px 100px } @page narrow { margin: 1px } section { page: small } </style> <div> <section>large</section> </div> ' ' ' ) page1 , = pages assert ( page1 . width , page1 . height ) == ( 100 , 100 ges = render pages ( ' ' ' <style> @page { size: 100px 100px } @page narrow { margin: 1px } section { page: small } </style> <div> <section>large</section> </div> ' ' ' ) page1 , = pages assert ( page1 . width , page1 . height ) == ( 100 , 100 )
@ page , = render pages ( ' <div style= " display: flex; margin: auto " > ' ) page , = render pages ( ' <div style= " display: flex; flex direction: column; margin: auto " > ' ge , = render pages ( ' <div style= " display: flex; margin: auto " > ' ) page , = render pages ( ' <div style= " display: flex; flex direction: column; margin: auto " > ' )
source , lines count page , = parse ( ' <html style= " width: 5em; font family: ahem " > ' + ' <style>@font face {src:url( ahem . ttf); font family:ahem}</style> ' + source ) html , = page . children body , = html . children lines = body . children assert len ( lines ) == lines counce , lines count page , = parse ( ' <html style= " width: 5em; font family: ahem " > ' + ' <style>@font face {src:url( ahem . ttf); font family:ahem}</style> ' + source ) html , = page . children body , = html . children lines = body . children assert len ( lines ) == lines count
@ page , = render pages ( ' ' ' <table style= " width: 300px " > <td style= " width: 400px " ></td> </table> ' ' ' ge , = render pages ( ' ' ' <table style= " width: 300px " > <td style= " width: 400px " ></td> </table> ' ' ' )
@ page , = render pages ( ' ' ' <table style= " width: 300px; margin: 100px " > <td style= " width: 400px " ></td> </table> ' ' ' ) html , = page . children body , = html . children table wrapper , = body . children assert table wrapper . margin width ( ) == 60ge , = render pages ( ' ' ' <table style= " width: 300px; margin: 100px " > <td style= " width: 400px " ></td> </table> ' ' ' ) html , = page . children body , = html . children table wrapper , = body . children assert table wrapper . margin width ( ) == 600
self , inputs , state with tf . variable scope ( ' layer normalization ' ) : gain = tf . get variable ( ' gain ' , shape = [ self . num units ] , initializer = tf . ones initializer ( ) ) bias = tf . get variable ( ' bias ' , shape = [ self . num units ] , initializer = tf . zeros initializer ( ) ) output = ln ( linear ( [ inputs , state ] , self . num units , true ) , gain , bias ) return output , output
self return self . num unit return self . num units
c str for i in u ' \u5341\u767e\u5343\u4e07\u4ebf ' : if i in c str : return false return trur for i in u ' \u5341\u767e\u5343\u4e07\u4ebf ' : if i in c str : return false return true
self return self . output vector le return self . output vector len
self , add newline self . append ( " ; " ) if add newline : self . newline ( , add newline self . append ( " ; " ) if add newline : self . newline ( )
width return ( width + 7 ) / h return ( width + 7 ) / 8
self , serializer assert isinstance ( serializer , program serializer ) serializer . append ( " 0 " , serializer assert isinstance ( serializer , program serializer ) serializer . append ( " 0 " )
self , node return self . nodes [ node , node return self . nodes [ node ]
self , serializer assert isinstance ( serializer , program serializer . program serializer ) serializer . append ( self . config . get includes ( ) , serializer assert isinstance ( serializer , program serializer . program serializer ) serializer . append ( self . config . get includes ( ) )
self , serializer assert isinstance ( serializer , program serializer . program serializer ) for p in self . parsers : p . serialize ( serializer , self , serializer assert isinstance ( serializer , program serializer . program serializer ) for p in self . parsers : p . serialize ( serializer , self )
self , serializer assert isinstance ( serializer , program serializer ) serializer . append format ( " {0}(\\ " {1}\\ " ) " , self . section , self . entry section , serializer assert isinstance ( serializer , program serializer ) serializer . append format ( " {0}(\\ " {1}\\ " ) " , self . section , self . entry section )
self return self . nam return self . name
self , destination assert isinstance ( destination , endpoint ) command = [ " arp " , " s " , str ( destination . ipaddress ) , str ( destination . mac addr ) ] self . execute ( command , destination assert isinstance ( destination , endpoint ) command = [ " arp " , " s " , str ( destination . ipaddress ) , str ( destination . mac addr ) ] self . execute ( command )
self self . message ( " configuring switch " ) self . run method in node ( self . switch , " setup switch " , [ ] self . message ( " configuring switch " ) self . run method in node ( self . switch , " setup switch " , [ ] )
kind , file , error if kind in files failed : files failed [ kind ] . append ( ( file , error ) ) else : files failed [ kind ] = [ ( file , error ) , file , error if kind in files failed : files failed [ kind ] . append ( ( file , error ) ) else : files failed [ kind ] = [ ( file , error ) ]
self return " %s:%s " % ( self . provider , self . name return " %s:%s " % ( self . provider , self . name )
self , probe , fn name if lib . bcc usdt enable probe ( self . context , probe . encode ( ' ascii ' ) , fn name . encode ( ' ascii ' ) ) != 0 : print ( ) sys . exit ( 1 )
filename if filename : if not os . path . isfile ( filename ) : argv0 = arg string ( sys . argv [ 0 ] ) t = b " / " . join ( [ os . path . abspath ( os . path . dirname ( argv0 . str ( ) ) ) , filename ] ) if os . path . isfile ( t ) : filename = t else : raise exception ( " could not find file %s " % filename ) return filename
self , tp = b " " tp = assert is bytes ( tp ) if tp not in self . tracepoint fds : raise exception ( " tracepoint %s is not attached " % tp ) res = lib . bpf close perf event fd ( self . tracepoint fds [ tp ] ) if res < 0 : raise exception ( " failed to detach bpf from tracepoint " ) ( tp category , tp name ) = tp . split ( b ' : ' ) res = lib . bpf detach tracepoint ( tp category , tp name ) if res < 0 : raise exception ( " failed to detach bpf from tracepoint " ) del self . tracepoint fds [ tp ]
self return len ( self . tracepoint fds )
self , leaf str leaf = self . leaf ( ) res = lib . bpf table leaf sscanf ( self . bpf . module , self . map id , leaf str , ct . byref ( leaf ) ) if res < 0 : raise exception ( " could not scanf leaf " ) return lea , leaf str leaf = self . leaf ( ) res = lib . bpf table leaf sscanf ( self . bpf . module , self . map id , leaf str , ct . byref ( leaf ) ) if res < 0 : raise exception ( " could not scanf leaf " ) return leaf
addr dq = ' ' for i in range ( 0 , 4 ) : dq = dq + str ( addr & 0xff ) if ( i != 3 ) : dq = dq + ' . ' addr = addr >> 8 return d dq = ' ' for i in range ( 0 , 4 ) : dq = dq + str ( addr & 0xff ) if ( i != 3 ) : dq = dq + ' . ' addr = addr >> 8 return dq
signal value , frame print ( al value , frame print ( )
def print ( " usage: %s [time] " % argv [ 0 ] ) exit ( print ( " usage: %s [time] " % argv [ 0 ] ) exit ( )
self , err raise value error ( " error in probe ' %s ' : %s " % ( self . spec , err ) , err raise value error ( " error in probe ' %s ' : %s " % ( self . spec , err ) )
self text = text = text % ( self . length , self . preds [ 0 ] [ 1 ] , self . preds [ 0 ] [ 0 ] , self . preds [ 0 ] [ 1 ] ) for tup in self . preds [ 1 : ] : text += """ else if (p >conds met == %s && %s) { p >stack[%s] = p >curr call; p >conds met++; } """ % ( tup [ 1 ] , tup [ 0 ] , tup [ 1 ] ) return text
self text = return text % str ( self . length + 1 )
self , func paren index = func . find ( " ( " ) potential id = func [ : paren index ] pattern = ' [ a z a z][ a z a z0 9]*$ ' if re . match ( pattern , potential id ) : return true return fals , func paren index = func . find ( " ( " ) potential id = func [ : paren index ] pattern = ' [ a z a z][ a z a z0 9]*$ ' if re . match ( pattern , potential id ) : return true return false
signal , frame print ( al , frame print ( )
val ival = positive int ( val ) if ival == 0 : raise argparse . argument type error ( " must be nonzero " ) return ivaival = positive int ( val ) if ival == 0 : raise argparse . argument type error ( " must be nonzero " ) return ival
location for idx in range ( 0 , location . num arguments ) : arg = location . get argument ( idx ) print ( " argument #%d %s " % ( idx + 1 , arg ) tion for idx in range ( 0 , location . num arguments ) : arg = location . get argument ( idx ) print ( " argument #%d %s " % ( idx + 1 , arg ) )
pid try : with open ( " /proc/%d/status " % pid ) as status : for line in status : if line . startswith ( " p pid: " ) : return int ( line . split ( ) [ 1 ] ) except io error : pass return try : with open ( " /proc/%d/status " % pid ) as status : for line in status : if line . startswith ( " p pid: " ) : return int ( line . split ( ) [ 1 ] ) except io error : pass return 0
self return self . bpf [ " counts " return self . bpf [ " counts " ]
s return ' " {} " ' . format ( ' ' . join ( escape character ( ord ( c ) ) for c in s ) turn ' " {} " ' . format ( ' ' . join ( escape character ( ord ( c ) ) for c in s ) )
signal , frame print ( al , frame print ( )
signal , frame print ( al , frame print ( )
addr dq = ' ' for i in range ( 0 , 4 ) : dq = dq + str ( addr & 0xff ) if ( i != 3 ) : dq = dq + ' . ' addr = addr >> 8 return d dq = ' ' for i in range ( 0 , 4 ) : dq = dq + str ( addr & 0xff ) if ( i != 3 ) : dq = dq + ' . ' addr = addr >> 8 return dq
self text = % ( self . begin , self . begin save , self . end , args . minimum * 1000000 , self . end save ) return text
self for probe in self . probes : probe . cleanup ( ) self . bpf . cleanup ( ) self . bpf = non for probe in self . probes : probe . cleanup ( ) self . bpf . cleanup ( ) self . bpf = none
def print ( " usage: %s [ i <if name>] " % argv [ 0 ] ) print ( " " ) print ( " try ' %s h ' for more options . " % argv [ 0 ] ) exit ( print ( " usage: %s [ i <if name>] " % argv [ 0 ] ) print ( " " ) print ( " try ' %s h ' for more options . " % argv [ 0 ] ) exit ( )
def print ( " usage: %s [ i <if name>] " % argv [ 0 ] ) print ( " " ) print ( " try ' %s h ' for more options . " % argv [ 0 ] ) exit ( print ( " usage: %s [ i <if name>] " % argv [ 0 ] ) print ( " " ) print ( " try ' %s h ' for more options . " % argv [ 0 ] ) exit ( )
addr dq = b ' ' for i in range ( 0 , 4 ) : \\t\\t dq = dq + str ( addr & 0xff ) . encode ( ) if ( i != 3 ) : \\t\\t\\t dq = dq + b ' . ' addr = addr >> 8 return d dq = b ' ' for i in range ( 0 , 4 ) : \\t\\t dq = dq + str ( addr & 0xff ) . encode ( ) if ( i != 3 ) : \\t\\t\\t dq = dq + b ' . ' addr = addr >> 8 return dq
@ global counter global b print ( " counter = %d vs %d " % ( counter , b [ " counters " ] [ ct . c int ( 0 ) ] . value ) obal counter global b print ( " counter = %d vs %d " % ( counter , b [ " counters " ] [ ct . c int ( 0 ) ] . value ) )
self b = bpf ( text = text , debug = 0 ) self . stats = b . get table ( " stats " ) b . attach kprobe ( event = " finish task switch " , fn name = " count sched " b = bpf ( text = text , debug = 0 ) self . stats = b . get table ( " stats " ) b . attach kprobe ( event = " finish task switch " , fn name = " count sched " )
self test prog1 = bpf ( text = test prog1 )
self text = b = bpf ( text = text , debug = 0 ) fn = b . load func ( " count sched " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " count tcp " , bpf . kprobe )
self text = b = bpf ( text = text , debug = 0 ) fns = b . load funcs ( bpf . kprobe )
self text = b = bpf ( text = text , debug = 0 ) fn = b . load func ( " trace entry " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self self . b . cleanup ( self . b . cleanup ( )
self b = bcc . bpf ( text = ) stub = b [ " stub " ] stack traces = b [ " stack traces " ] stack entries = b [ " stack entries " ] try : x = stub [ stub . key ( 1 ) ] except : pass k = stack entries . key ( 1 ) self . assert in ( k , stack entries ) stackid = stack entries [ k ] self . assert is not none ( stackid ) stack = stack traces [ stackid ] . ip self . assert equal ( b . ksym ( stack [ 0 ] ) , b " htab map lookup elem " )
self self . app . kill ( ) self . app . wait ( ) self . app2 . kill ( ) self . app2 . wait ( ) self . app3 . kill ( ) self . app3 . wait ( ) os . unlink ( self . ftemp . name self . app . kill ( ) self . app . wait ( ) self . app2 . kill ( ) self . app2 . wait ( ) self . app3 . kill ( ) self . app3 . wait ( ) os . unlink ( self . ftemp . name )
self self . assert equal ( cfg . leaking amount , self . run leaker ( " calloc " ) self . assert equal ( cfg . leaking amount , self . run leaker ( " calloc " ) )
self self . run with duration ( " biolatency . py 1 1 " self . run with duration ( " biolatency . py 1 1 " )
self self . run with duration ( " dcstat . py 1 1 " self . run with duration ( " dcstat . py 1 1 " )
self self . run with duration ( " memleak . py 1 1 " self . run with duration ( " memleak . py 1 1 " )
self self . run with int ( " opensnoop . py " self . run with int ( " opensnoop . py " )
self self . run with duration ( " profile . py 1 " self . run with duration ( " profile . py 1 " )
self self . run with int ( " shmsnoop . py " self . run with int ( " shmsnoop . py " )
self self . run with int ( " statsnoop . py " self . run with int ( " statsnoop . py " )
self self . run with int ( " tcpaccept . py " self . run with int ( " tcpaccept . py " )
self self . run with int ( " tcpretrans . py " self . run with int ( " tcpretrans . py " )
self self . run with int ( " trace . py do sys open " self . run with int ( " trace . py do sys open " )
self self . run with int ( " ttysnoop . py /dev/console " self . run with int ( " ttysnoop . py /dev/console " )
self b = bpf ( text = self . gpl only text + self . license ( ' gpl ' ) , cflags = [ " dbpf license= gpl " ] ) self . load bpf code ( b b = bpf ( text = self . gpl only text + self . license ( ' gpl ' ) , cflags = [ " dbpf license= gpl " ] ) self . load bpf code ( b )
self return self . long or self . shor return self . long or self . short
self return self . pop ( 0 ) if len ( self ) else non return self . pop ( 0 ) if len ( self ) else none
pretrained = false , ** kwargs model = res net ( basic block , [ 2 , 2 , 2 , 2 ] , ** kwargs ) if pretrained : model . load state dict ( load url ( model urls [ ' resnet18 ' ] ) ) return model
pretrained = false , ** kwargs model = res net ( bottleneck , [ 3 , 4 , 6 , 3 ] , ** kwargs ) if pretrained : model . load state dict ( load url ( model urls [ ' resnet50 ' ] ) , strict = false ) return model
self , master msg self . activated = true intermediates = [ ( 0 , master msg ) ] for i in range ( self . nr slaves ) : intermediates . append ( self . queue . get ( ) ) results = self . master callback ( intermediates ) assert results [ 0 ] [ 0 ] == 0 , ' the first result should belongs to the master . ' for i , res in results : if i == 0 : continue self . registry [ i ] . result . put ( res ) for i in range ( self . nr slaves ) : assert self . queue . get ( ) is true return results [ 0 ] [ 1 ]
modules master copy = modules [ 0 ] nr modules = len ( list ( master copy . modules ( ) ) ) ctxs = [ callback context ( ) for in range ( nr modules ) ] for i , module in enumerate ( modules ) : for j , m in enumerate ( module . modules ( ) ) : if hasattr ( m , ' data parallel replicate ' ) : m . data parallel replicate ( ctxs [ j ] , i )
self , dest , delta , alpha = 1 , beta = 1 , bias = 0 return dest * alpha + delta * beta + bias
self from sh import error return code 2 py = create tmp test ( ) self . assert raises ( error return code 2 , python , py . name )
self py = create tmp test ( ) num args = int ( python ( py . name , long option = " one two three " , nothing = false ) ) self . assert equal ( num args , 3 ) num args = int ( python ( py . name , " long option " , " one ' s two ' s three ' s " ) ) self . assert equal ( num args , 3 )
self py = create tmp test ( ) self . assert true ( python ( py . name , s = true ) . strip ( ) == " true " ) self . assert true ( python ( py . name , s = false ) . strip ( ) == " false " ) self . assert true ( python ( py . name ) . strip ( ) == " false " )
self from sh import ls , wc c1 = int ( wc ( ls ( " a1 " , piped = true ) , l = true ) . strip ( ) ) c2 = len ( os . listdir ( " . " ) ) self . assert equal ( c1 , c2 from sh import ls , wc c1 = int ( wc ( ls ( " a1 " , piped = true ) , l = true ) . strip ( ) ) c2 = len ( os . listdir ( " . " ) ) self . assert equal ( c1 , c2 )
self py = create tmp test ( " exit(0) " ) sh . python ( py . name , fg = true py = create tmp test ( " exit(0) " ) sh . python ( py . name , fg = true )
self from sh import command py = create tmp test ( , " \u5b57 " , delete = false ) try : py . close ( ) os . chmod ( py . name , int ( 0o755 ) ) cmd = command ( py . name ) # all of these should behave just fine str ( cmd ) repr ( cmd ) unicode ( cmd ) running = cmd ( ) str ( running ) repr ( running ) unicode ( running ) str ( running . process ) repr ( running . process ) unicode ( running . process ) finally : os . unlink ( py . name )
self out = string io ( ) def fn ( ) : import sh sh = sh ( out = out ) self . assert raises ( runtime error , fn out = string io ( ) def fn ( ) : import sh sh = sh ( out = out ) self . assert raises ( runtime error , fn )
self , f , events self . set fileobject ( f ) fd = self . get file descriptor ( f ) self . poll . register ( fd , events , f , events self . set fileobject ( f ) fd = self . get file descriptor ( f ) self . poll . register ( fd , events )
self , msg , * args if self . context : msg = " %s: %s " % ( self . context , msg ) return msg % arg , msg , * args if self . context : msg = " %s: %s " % ( self . context , msg ) return msg % args
self self . wait ( ) return self . process . stder self . wait ( ) return self . process . stderr
self exc = none try : exc = self . bg thread exc queue . get ( false ) except empty : pass return ex exc = none try : exc = self . bg thread exc queue . get ( false ) except empty : pass return exc
def def test ( importer ) : return importer . class . name == module importer from variables . name already registered = any ( [ true for i in sys . meta path if test ( i ) ] ) if not already registered : importer = module importer from variables ( restrict to = [ " self wrapper " ] , ) sys . meta path . insert ( 0 , importer ) return not already registered
vcs , method def decorate ( f ) : """ store f in handlers[vcs][method] . """ if vcs not in handlers : handlers [ vcs ] = { } handlers [ vcs ] [ method ] = f return f return decorate
def return get versions ( ) [ " version " ]
parser parser . addoption ( " runslow " , action = " store true " , help = " run slow tests " er parser . addoption ( " runslow " , action = " store true " , help = " run slow tests " )
vals from . highlevelgraph import high level graph graphs = [ v . dask graph ( ) for v in vals ] keys = [ v . dask keys ( ) for v in vals ] if any ( isinstance ( graph , high level graph ) for graph in graphs ) : graph = high level graph . merge ( * graphs ) else : graph = merge ( * graphs ) return graph , keys
args , ** kwargs if kwargs : args = args + ( kwargs , ) return md5 ( str ( tuple ( map ( normalize token , args ) ) ) . encode ( ) ) . hexdigest ( )
d return normalize token ( sorted ( d . items ( ) , key = str ) turn normalize token ( sorted ( d . items ( ) , key = str ) )
buf h = cityhash . city hash128 ( buf ) return h . to bytes ( 16 , " little " )
dsk , func , place return fuse selections ( dsk , getitem , func , lambda a , b : tuple ( b [ : place ] ) + ( a [ 2 ] , ) + tuple ( b [ place + 1 : ] ) , )
dsk dependencies = { k : get dependencies ( dsk , task = v ) for k , v in dsk . items ( ) } dependents = reverse dict ( dependencies ) return dependencies , dependents
key , task info , dumps , loads , get id , pack exception try : task , data = loads ( task info ) result = execute task ( task , data ) id = get id ( ) result = dumps ( ( result , id ) ) failed = false except base exception as e : result = pack exception ( e , dumps ) failed = true return key , result , failed
self d = { " x " : 1 , " y " : ( inc , " x " ) , " z " : ( add , ( inc , " x " ) , " y " ) } assert self . get ( d , " z " ) == d = { " x " : 1 , " y " : ( inc , " x " ) , " z " : ( add , ( inc , " x " ) , " y " ) } assert self . get ( d , " z " ) == 4
n , k , base return n // base ** k % base
num for x in [ " bytes " , " kb " , " mb " , " gb " , " tb " ] : if num < 1024 . 0 : return " %3 . 1f %s " % ( num , x ) num /= 1024 . for x in [ " bytes " , " kb " , " mb " , " gb " , " tb " ] : if num < 1024 . 0 : return " %3 . 1f %s " % ( num , x ) num /= 1024 . 0
s typ = type ( s ) return ( all ( hasattr ( s , name ) for name in ( " name " , " dtype " ) ) and " index " in typ . name . lower ( ) )
self , filename = " dask . pdf " , format = none , ** kwargs from . dot import graphviz to file g = to graphviz ( self , ** kwargs ) return graphviz to file ( g , filename , format , filename = " dask . pdf " , format = none , ** kwargs from . dot import graphviz to file g = to graphviz ( self , ** kwargs ) return graphviz to file ( g , filename , format )
i , prefix = " " return prefix + " %d " % prefix = " " return prefix + " %d " % i
self , dsk self . durations = dict ( ) overlap = set ( dsk ) & set ( self . cache . data ) for key in overlap : dsk [ key ] = self . cache . data [ key , dsk self . durations = dict ( ) overlap = set ( dsk ) & set ( self . cache . data ) for key in overlap : dsk [ key ] = self . cache . data [ key ]
m return getattr , ( m . objclass , m . name turn getattr , ( m . objclass , m . name )
def return multiprocessing . current process ( ) . idenreturn multiprocessing . current process ( ) . ident
def if sys . platform == " win32 " : # just do the default , since we can ' t change it: if config . get ( " multiprocessing . context " , none ) is not none : warn ( context unsupported , user warning ) return multiprocessing context name = config . get ( " multiprocessing . context " , none ) return multiprocessing . get context ( context name )
pieces if pieces [ " closest tag " ] : rendered = pieces [ " closest tag " ] rendered += " %d g%s " % ( pieces [ " distance " ] , pieces [ " short " ] ) else : # exception #1 rendered = pieces [ " short " ] if pieces [ " dirty " ] : rendered += " dirty " return rendered
o return getsizeof ( o turn getsizeof ( o )
self callback . active . remove ( self . callback callback . active . remove ( self . callback )
e , dumps return e , sys . exc info ( ) [ 2 dumps return e , sys . exc info ( ) [ 2 ]
self return [ none , none ]
self , axis = none , limit = none return self . fillna ( method = " ffill " , limit = limit , axis = axis , axis = none , limit = none return self . fillna ( method = " ffill " , limit = limit , axis = axis )
self , filename , * args , ** kwargs from . io import to json return to json ( self , filename , * args , ** kwargs )
self , axis = none , skipna = true , out = none return self . cum agg ( " cummax " , chunk = m . cummax , aggregate = methods . cummax aggregate , axis = axis , skipna = skipna , chunk kwargs = dict ( axis = axis , skipna = skipna ) , out = out , , axis = none , skipna = true , out = none return self . cum agg ( " cummax " , chunk = m . cummax , aggregate = methods . cummax aggregate , axis = axis , skipna = skipna , chunk kwargs = dict ( axis = axis , skipna = skipna ) , out = out , )
self , cond , other = np . nan return map partitions ( m . mask , self , cond , other , cond , other = np . nan return map partitions ( m . mask , self , cond , other )
self return self . map partitions ( m . isnull return self . map partitions ( m . isnull )
self return categorical accessor ( self return categorical accessor ( self )
self return string accessor ( self )
self , q = 0 . 5 , method = " default " return quantile ( self , q , method = method )
self , n = 5 , split every = none return aca ( self , chunk = m . nsmallest , aggregate = m . nsmallest , meta = self . meta , token = " series nsmallest " , split every = split every , n = n , , n = 5 , split every = none return aca ( self , chunk = m . nsmallest , aggregate = m . nsmallest , meta = self . meta , token = " series nsmallest " , split every = split every , n = n , )
self , lag = 1 , split every = false if not isinstance ( lag , integral ) : raise type error ( " lag must be an integer " ) return self . corr ( self if lag == 0 else self . shift ( lag ) , split every = split every , lag = 1 , split every = false if not isinstance ( lag , integral ) : raise type error ( " lag must be an integer " ) return self . corr ( self if lag == 0 else self . shift ( lag ) , split every = split every )
self , split every = false return self . reduction ( methods . index count , np . sum , token = " index count " , meta = int , split every = split every , , split every = false return self . reduction ( methods . index count , np . sum , token = " index count " , meta = int , split every = split every , )
self , decimals = 0 return elemwise ( m . round , self , decimals , decimals = 0 return elemwise ( m . round , self , decimals )
x , fn = none , skipna = true if len ( x ) == 0 : return x return ( x . groupby ( level = 0 ) . apply ( idxmaxmin row , fn = fn , skipna = skipna ) . reset index ( level = 1 , drop = true ) fn = none , skipna = true if len ( x ) == 0 : return x return ( x . groupby ( level = 0 ) . apply ( idxmaxmin row , fn = fn , skipna = skipna ) . reset index ( level = 1 , drop = true ) )
x get parallel type ( x ) return isinstance ( x , parallel types ( ) )
x if is scalar ( x ) : return nonempty scalar ( x ) else : raise type error ( " expected pandas like index , series , data frame , or scalar , " " got {0} " . format ( typename ( type ( x ) ) ) )
s return dask is index like ( s turn dask is index like ( s )
index if isinstance ( index , ( tuple , list ) ) and len ( index ) > 1 : return list ( range ( len ( index ) ) ) else : return 0
grouped , columns if " groupby " in type ( grouped ) . name . lower ( ) : if columns is not none : if isinstance ( columns , ( tuple , list , set , pd . index ) ) : columns = list ( columns ) return grouped [ columns ] return grouped
df , levels , name return df . groupby ( level = levels , sort = false ) [ name ] . nunique ( , levels , name return df . groupby ( level = levels , sort = false ) [ name ] . nunique ( )
self , split every = none , split out = 1 return self . aca agg ( token = " first " , func = m . first , split every = split every , split out = split out , split every = none , split out = 1 return self . aca agg ( token = " first " , func = m . first , split every = split every , split out = split out )
n , to binary = false if n < 32 : group size = 2 else : group size = int ( math . log ( n ) ) num groups = n // group size if to binary or num groups < 16 : return 2 ** int ( math . log ( n / group size , 2 ) ) else : return num groups
s , divisions partitions = divisions . searchsorted ( s , side = " right " ) 1 partitions [ ( s >= divisions . iloc [ 1 ] ) . values ] = len ( divisions ) 2 return partition divisions partitions = divisions . searchsorted ( s , side = " right " ) 1 partitions [ ( s >= divisions . iloc [ 1 ] ) . values ] = len ( divisions ) 2 return partitions
self return self . call method ( " mean " return self . call method ( " mean " )
df , index , columns , values return pd . pivot table ( df , index = index , columns = columns , values = values , aggfunc = " count " ) . astype ( np . float64 , index , columns , values return pd . pivot table ( df , index = index , columns = columns , values = values , aggfunc = " count " ) . astype ( np . float64 )
dfs , axis = 0 , join = " outer " , uniform = false , filter warning = true if len ( dfs ) == 1 : return dfs [ 0 ] else : func = concat dispatch . dispatch ( type ( dfs [ 0 ] ) ) return func ( dfs , axis = axis , join = join , uniform = uniform , filter warning = filter warning )
frame , id vars = none , value vars = none , var name = none , value name = " value " , col level = none from dask . dataframe . core import no default return frame . map partitions ( m . melt , meta = no default , id vars = id vars , value vars = value vars , var name = var name , value name = value name , col level = col level , token = " melt " , )
obj , accessor , attr , args , kwargs out = getattr ( getattr ( obj , accessor , obj ) , attr ) ( * args , ** kwargs ) return maybe wrap pandas ( obj , out , accessor , attr , args , kwargs out = getattr ( getattr ( obj , accessor , obj ) , attr ) ( * args , ** kwargs ) return maybe wrap pandas ( obj , out )
series , index return series . str [ index ]
self , * others , ** kwargs return self . str . cat ( others = others , ** kwargs , * others , ** kwargs return self . str . cat ( others = others , ** kwargs )
self return self . agg ( " first " return self . agg ( " first " )
df , openfile , kwargs with openfile as f : df . to json ( f , ** kwargs , openfile , kwargs with openfile as f : df . to json ( f , ** kwargs )
path , key , lock , kwargs if lock : lock . acquire ( ) try : result = pd . read hdf ( path , key , ** kwargs ) finally : if lock : lock . release ( ) return result
token , result return none
def df = pd . data frame ( { " x " : [ 1 ] } , index = [ 1 ] ) ddf = dd . from pandas ( df , npartitions = 1 ) assert ddf . divisions == ( 1 , 1 ) assert eq ( ddf , df df = pd . data frame ( { " x " : [ 1 ] } , index = [ 1 ] ) ddf = dd . from pandas ( df , npartitions = 1 ) assert ddf . divisions == ( 1 , 1 ) assert eq ( ddf , df )
reader , files b = files [ " 2014 01 01 . csv " ] df = pandas read text ( reader , b , b " " , { } , { " amount " : " float " } ) assert df . amount . dtype == " float "er , files b = files [ " 2014 01 01 . csv " ] df = pandas read text ( reader , b , b " " , { } , { " amount " : " float " } ) assert df . amount . dtype == " float "
dd read , files with filetexts ( files , mode = " b " ) : with pytest . raises ( value error ) : dd read ( " 2014 01 * . csv " , include path column = " name " ead , files with filetexts ( files , mode = " b " ) : with pytest . raises ( value error ) : dd read ( " 2014 01 * . csv " , include path column = " name " )
def with filetext ( csv text ) as fn : f = dd . read csv ( fn , skiprows = range ( 5 ) ) result = f expected = pd . read csv ( fn , skiprows = range ( 5 ) ) assert eq ( result , expected with filetext ( csv text ) as fn : f = dd . read csv ( fn , skiprows = range ( 5 ) ) result = f expected = pd . read csv ( fn , skiprows = range ( 5 ) ) assert eq ( result , expected )
compression with tmpdir ( ) as path : dd . to json ( ddf , path , compression = compression ) actual = dd . read json ( os . path . join ( path , " * " ) , compression = compression ) assert eq ( df , actual . compute ( ) , check index = false ression with tmpdir ( ) as path : dd . to json ( ddf , path , compression = compression ) actual = dd . read json ( os . path . join ( path , " * " ) , compression = compression ) assert eq ( df , actual . compute ( ) , check index = false )
def df = dd . demo . make timeseries ( ) assert 1 < df . npartitions < 1000 assert len ( df . columns ) > 1 assert len ( set ( df . dtypes ) ) > df = dd . demo . make timeseries ( ) assert 1 < df . npartitions < 1000 assert len ( df . columns ) > 1 assert len ( set ( df . dtypes ) ) > 1
x return np . fabs ( x x . mean ( ) ) . mean ( turn np . fabs ( x x . mean ( ) ) . mean ( )
def meta = meta nonempty ( np . float64 ( 1 . 0 ) ) assert isinstance ( meta , np . float64 ) x = pd . timestamp ( 2000 , 1 , 1 ) meta = meta nonempty ( x ) assert meta is meta = meta nonempty ( np . float64 ( 1 . 0 ) ) assert isinstance ( meta , np . float64 ) x = pd . timestamp ( 2000 , 1 , 1 ) meta = meta nonempty ( x ) assert meta is x
def assert eq ( d . index , full . index assert eq ( d . index , full . index )
def x = dd . from pandas ( pd . data frame ( { " a " : range ( 10 ) } ) , npartitions = 2 ) . a . sum ( ) x . compute ( bogus keyword = 10 x = dd . from pandas ( pd . data frame ( { " a " : range ( 10 ) } ) , npartitions = 2 ) . a . sum ( ) x . compute ( bogus keyword = 10 )
obj , attr try : yield finally : try : delattr ( obj , attr ) except attribute error : pass obj . accessors . discard ( attr )
self , dsk self . dsk . update ( dsk , dsk self . dsk . update ( dsk )
self , dsk , state , failed t = default timer ( ) for k , ( metric , start ) in self . cache . items ( ) : self . results . append ( cache data ( k , dsk [ k ] , metric , start , t ) ) self . cache . clear ( , dsk , state , failed t = default timer ( ) for k , ( metric , start ) in self . cache . items ( ) : self . results . append ( cache data ( k , dsk [ k ] , metric , start , t ) ) self . cache . clear ( )
self , ** kwargs from . profile visualize import visualize return visualize ( self , ** kwargs )
data out = io . bytes io ( ) with zipfile . zip file ( file = out , mode = " w " ) as z : with z . open ( " myfile " , " w " ) as zf : zf . write ( data ) out . seek ( 0 ) return out . read ( )
def with filetexts ( csv files , mode = " b " ) : , , paths = get fs token paths ( " . * . csv " ) assert len ( paths ) == 2 , , paths = get fs token paths ( [ " . * . csv " ] ) assert len ( paths ) == 2
self , optimize graph = true from dask . delayed import delayed dsk = self . dask graph ( ) if optimize graph : dsk = self . dask optimize ( dsk , self . dask keys ( ) ) return delayed ( self . key , dsk )
self , predicate name = " filter {0} {1} " . format ( funcname ( predicate ) , tokenize ( self , predicate ) ) dsk = dict ( ( ( name , i ) , ( reify , ( filter , predicate , ( self . name , i ) ) ) ) for i in range ( self . npartitions ) ) graph = high level graph . from collections ( name , dsk , dependencies = [ self ] ) return type ( self ) ( graph , name , self . npartitions )
self , split every = none return self . reduction ( count , sum , split every = split every )
self , other assert isinstance ( other , bag ) name = " product " + tokenize ( self , other ) n , m = self . npartitions , other . npartitions dsk = dict ( ( ( name , i * m + j ) , ( list , ( itertools . product , ( self . name , i ) , ( other . name , j ) ) ) , ) for i in range ( n ) for j in range ( m ) ) graph = high level graph . from collections ( name , dsk , dependencies = [ self , other ] ) return type ( self ) ( graph , name , n * m )
seq , key = none key2 = key if key is not none and not callable ( key ) : key2 = lambda x : x [ key ] return list ( unique ( seq , key = key2 ) , key = none key2 = key if key is not none and not callable ( key ) : key2 = lambda x : x [ key ] return list ( unique ( seq , key = key2 ) )
fs , path , compression from dask . bytes . core import open file with open file ( fs , path , compression = compression ) as f : head = read header ( f ) size = fs . info ( path ) [ " size " ] return head , size
lazy file with lazy file as f : for line in f : yield lin file with lazy file as f : for line in f : yield line
def assert b . dask keys ( ) == sorted ( dsk . keys ( ) assert b . dask keys ( ) == sorted ( dsk . keys ( ) )
def a = db . from sequence ( range ( 1000 ) , npartitions = 5 ) assert 10 < len ( list ( a . random sample ( 0 . 1 , 42 ) ) ) < 300
def a = db . from sequence ( range ( 50 ) , npartitions = 5 ) with pytest . raises ( value error ) : a . random sample ( 1 ) with pytest . raises ( value error ) : a . random sample ( 1 . 1 )
def a = db . from sequence ( range ( 50 ) , npartitions = 5 ) b = a . random sample ( 0 . 2 ) assert list ( b ) == list ( b )
@ a = db . from url ( [ " http://google . com " , " http://github . com " ] ) assert a . npartitions == 2 b = db . from url ( " http://raw . githubusercontent . com/dask/dask/master/ readme . rst " ) assert b . npartitions == 1 assert b " dask\ " in b . take ( 10 = db . from url ( [ " http://google . com " , " http://github . com " ] ) assert a . npartitions == 2 b = db . from url ( " http://raw . githubusercontent . com/dask/dask/master/ readme . rst " ) assert b . npartitions == 1 assert b " dask\ " in b . take ( 10 )
l , reverse = false return sorted ( l , reverse = reverse ) == reverse = false return sorted ( l , reverse = reverse ) == l
def def unrelated function ( a ) : return np . array ( [ a ] ) def my small function ( a , b ) : return a + b b = dumps ( my small function ) assert b " my small function " in b assert b " unrelated function " not in b assert b " numpy " not in b
def dsk = { " x " : ( bad , ) } try : get ( dsk , " x " ) except exception as e : assert isinstance ( e , value error ) assert " 12345 " in str ( e dsk = { " x " : ( bad , ) } try : get ( dsk , " x " ) except exception as e : assert isinstance ( e , value error ) assert " 12345 " in str ( e )
def return lambda x : x + return lambda x : x + 1
@ def check for pytest ( ) : import sys return " fake module for test " in sys . modules sys . modules [ " fake module for test " ] = 1 try : with dask . config . set ( { " multiprocessing . context " : " spawn " } ) : result = get ( { " x " : ( check for pytest , ) } , " x " ) assert not result finally : del sys . modules [ " fake module for test " ]
tmpdir pytest . importorskip ( " graphviz " ) fn = str ( tmpdir ) a = da . ones ( 10 , chunks = ( 5 , ) ) b = a + 1 c = a + 2 d = b + c d . dask . visualize ( fn ) assert os . path . exists ( fn ir pytest . importorskip ( " graphviz " ) fn = str ( tmpdir ) a = da . ones ( 10 , chunks = ( 5 , ) ) b = a + 1 c = a + 2 d = b + c d . dask . visualize ( fn ) assert os . path . exists ( fn )
def try : import pandas as pd except import error : return else : df = pd . data frame ( ) assert subs ( df , " x " , 1 ) is dtry : import pandas as pd except import error : return else : df = pd . data frame ( ) assert subs ( df , " x " , 1 ) is df
def pd = pytest . importorskip ( " pandas " ) df = pd . data frame ( { " x " : [ 1 , 2 , 3 ] } ) assert sizeof ( df [ [ " x " , " x " , " x " ] ] ) > sizeof ( df pd = pytest . importorskip ( " pandas " ) df = pd . data frame ( { " x " : [ 1 , 2 , 3 ] } ) assert sizeof ( df [ [ " x " , " x " , " x " ] ] ) > sizeof ( df )
def a = delayed ( 1 ) b = delayed ( 2 ) c = delayed ( sum ) ( [ a , b ] ) assert c . compute ( ) == a = delayed ( 1 ) b = delayed ( 2 ) c = delayed ( sum ) ( [ a , b ] ) assert c . compute ( ) == 3
def v1 = delayed ( add , pure = true ) ( 1 , 2 ) v2 = delayed ( add , pure = true ) ( 1 , 2 ) assert v1 . key == v2 . key myrand = delayed ( random ) assert myrand ( ) . key != myrand ( ) . kev1 = delayed ( add , pure = true ) ( 1 , 2 ) v2 = delayed ( add , pure = true ) ( 1 , 2 ) assert v1 . key == v2 . key myrand = delayed ( random ) assert myrand ( ) . key != myrand ( ) . key
path perm orig = stat . s imode ( os . stat ( path ) . st mode ) perm new = perm orig ^ stat . s iread try : os . chmod ( path , perm new ) yield finally : os . chmod ( path , perm orig perm orig = stat . s imode ( os . stat ( path ) . st mode ) perm new = perm orig ^ stat . s iread try : os . chmod ( path , perm new ) yield finally : os . chmod ( path , perm orig )
inp , out try : os . environ [ " foo " ] = " foo " assert expand environment variables ( inp ) == out finally : del os . environ [ " foo " , out try : os . environ [ " foo " ] = " foo " assert expand environment variables ( inp ) == out finally : del os . environ [ " foo " ]
def assert " temporary directory " in dask . config . confiassert " temporary directory " in dask . config . config
def foo = dispatch ( ) foo . register ( int , lambda a , b = 10 : a + b ) assert foo ( 1 , b = 20 ) == 2foo = dispatch ( ) foo . register ( int , lambda a , b = 10 : a + b ) assert foo ( 1 , b = 20 ) == 21
def example = res = skip doctest ( example ) assert ( res == """ >>> xxx # doctest: + skip>>>>>> # comment>>> xxx # doctest: + skip """ ) assert skip doctest ( none ) == " " example = """ >>> 1 + 2 # doctest: + ellipses3 """ expected = """ >>> 1 + 2 # doctest: + ellipses , + skip3 """ res = skip doctest ( example ) assert res == expected
def np = pytest . importorskip ( " numpy " ) vfunc = np . vectorize ( int ) assert funcname ( vfunc ) == " vectorize int " func = functools . partial ( np . add , out = none ) vfunc = np . vectorize ( func ) assert funcname ( vfunc ) == " vectorize add "np = pytest . importorskip ( " numpy " ) vfunc = np . vectorize ( int ) assert funcname ( vfunc ) == " vectorize int " func = functools . partial ( np . add , out = none ) vfunc = np . vectorize ( func ) assert funcname ( vfunc ) == " vectorize add "
def c = cache ( 10000 , limit = 1 ) assert isinstance ( c . cache , cachey . cache ) assert c . cache . available bytes == 10000 assert c . cache . limit == c = cache ( 10000 , limit = 1 ) assert isinstance ( c . cache , cachey . cache ) assert c . cache . available bytes == 10000 assert c . cache . limit == 1
duration , size , * args sleep ( duration ) return [ 0 ] * siztion , size , * args sleep ( duration ) return [ 0 ] * size
def from textwrap import dedent defn = dedent ( ) main = sys . modules [ " main " ] exec ( compile ( defn , " <test> " , " exec " ) , main . dict ) f = main . inc t = normalize token ( f ) assert b " cloudpickle " in t
def assert head ( ( inc , 1 ) ) == inc assert head ( ( add , 1 , 2 ) ) == add assert head ( ( add , ( inc , 1 ) , ( inc , 1 ) ) ) == add assert head ( [ 1 , 2 , 3 ] ) == lisassert head ( ( inc , 1 ) ) == inc assert head ( ( add , 1 , 2 ) ) == add assert head ( ( add , ( inc , 1 ) , ( inc , 1 ) ) ) == add assert head ( [ 1 , 2 , 3 ] ) == list
sd x = sd [ " x " ] if isinstance ( x , list ) : return x else : return ( list , x = sd [ " x " ] if isinstance ( x , list ) : return x else : return ( list , x )
a from crick import t digest t = t digest ( ) t . update ( a ) return om crick import t digest t = t digest ( ) t . update ( a ) return t
x if is dask collection ( x ) : return x elif isinstance ( x , str ) and re . match ( r " \\d+ " , x ) : return delayed ( x ) elif isinstance ( x , list ) and len ( x ) >= 10 : return delayed ( x ) elif sizeof ( x ) > 1e6 : return delayed ( x ) else : return x
self return tuple ( map ( len , self . chunks ) return tuple ( map ( len , self . chunks ) )
self , axis = none , keepdims = false , split every = none , out = none from . reductions import max return max ( self , axis = axis , keepdims = keepdims , split every = split every , out = out , axis = none , keepdims = false , split every = none , out = none from . reductions import max return max ( self , axis = axis , keepdims = keepdims , split every = split every , out = out )
self from . ufunc import imag return imag ( self from . ufunc import imag return imag ( self )
self , min = none , max = none from . ufunc import clip return clip ( self , min , max , min = none , max = none from . ufunc import clip return clip ( self , min , max )
a s = np . asarray ( a . shape , dtype = int ) return s [ len ( s ) * ( none , ) + ( slice ( none ) , ) = np . asarray ( a . shape , dtype = int ) return s [ len ( s ) * ( none , ) + ( slice ( none ) , ) ]
func , shape , dtype = none , name = none , args = ( ) , kwargs = { } name = name or " from func " + tokenize ( func , shape , dtype , args , kwargs ) if args or kwargs : func = partial ( func , * args , ** kwargs ) dsk = { ( name , ) + ( 0 , ) * len ( shape ) : ( func , ) } chunks = tuple ( ( i , ) for i in shape ) return array ( dsk , name , chunks , dtype )
shape , seq if len ( shape ) == 1 : return list ( seq ) else : n = int ( len ( seq ) / shape [ 0 ] ) return [ reshapelist ( shape [ 1 : ] , part ) for part in partition ( n , seq ) ]
x , depth , boundary = none axes = coerce depth ( x . ndim , depth ) boundary2 = coerce boundary ( x . ndim , boundary ) return trim internal ( x , axes = axes , boundary = boundary2 )
dtype , index dt = np . dtype ( [ ( name , dtype [ name ] ) for name in index ] ) return de , index dt = np . dtype ( [ ( name , dtype [ name ] ) for name in index ] ) return dt
a , fill value = none a = asanyarray ( a ) return a . map blocks ( np . ma . fix invalid , fill value = fill value fill value = none a = asanyarray ( a ) return a . map blocks ( np . ma . fix invalid , fill value = fill value )
x if " cupy " in str ( type ( x ) ) : # todo: avoid explicit reference to cupy return x . get ( ) else : return " cupy " in str ( type ( x ) ) : # todo: avoid explicit reference to cupy return x . get ( ) else : return x
dsk if not isinstance ( dsk , high level graph ) : return assert all ( isinstance ( k , ( tuple , str ) ) for k in dsk . layers ) freqs = frequencies ( concat ( dsk . dicts . values ( ) ) ) non one = { k : v for k , v in freqs . items ( ) if v != 1 } assert not non one , non one
n , q , oversampling = 10 , min subspace size = 20 return min ( max ( min subspace size , q + oversampling ) , n )
a import scipy . linalg return scipy . linalg . cholesky ( a , lower = true port scipy . linalg return scipy . linalg . cholesky ( a , lower = true )
a , s , axes if s is none : s = [ a . chunks [ axis ] [ 0 ] for axis in axes ] s = list ( s ) s [ 1 ] = s [ 1 ] // 2 + 1 chunks = list ( a . chunks ) for i , axis in enumerate ( axes ) : chunks [ axis ] = ( s [ i ] , ) return chunks
a , decimals = 0 return a . map blocks ( np . round , decimals = decimals , dtype = a . dtype decimals = 0 return a . map blocks ( np . round , decimals = decimals , dtype = a . dtype )
array return array . reshape ( ( 1 , ) y return array . reshape ( ( 1 , ) )
values import pandas as pd return np . asarray ( pd . isnull ( values ) es import pandas as pd return np . asarray ( pd . isnull ( values ) )
a , k , axis , keepdims assert keepdims is true a = topk ( a , k , axis , keepdims ) axis = axis [ 0 ] a = np . sort ( a , axis = axis ) if k < 0 : return a return a [ tuple ( slice ( none , none , 1 ) if i == axis else slice ( none ) for i in range ( a . ndim ) ) ]
a , idx return a , idx
x , dtype , order = " c " if order == " c " : x = np . ascontiguousarray ( x ) return x . view ( dtype ) else : x = np . asfortranarray ( x ) return x . t . view ( dtype ) . dtype , order = " c " if order == " c " : x = np . ascontiguousarray ( x ) return x . view ( dtype ) else : x = np . asfortranarray ( x ) return x . t . view ( dtype ) . t
self , loc = 0 . 0 , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " logistic " , loc , scale , size = size , chunks = chunks , loc = 0 . 0 , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " logistic " , loc , scale , size = size , chunks = chunks )
self , n , pvals , size = none , chunks = " auto " return self . wrap ( " multinomial " , n , pvals , size = size , chunks = chunks , extra chunks = ( ( len ( pvals ) , ) , ) , , n , pvals , size = none , chunks = " auto " return self . wrap ( " multinomial " , n , pvals , size = size , chunks = chunks , extra chunks = ( ( len ( pvals ) , ) , ) , )
self , loc = 0 . 0 , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " normal " , loc , scale , size = size , chunks = chunks , loc = 0 . 0 , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " normal " , loc , scale , size = size , chunks = chunks )
def a = normal ( loc = 10 . 0 , scale = 0 . 1 , size = ( 10 , 10 ) , chunks = ( 5 , 5 ) ) assert isinstance ( a , array ) x = np . array ( a ) assert 8 < x . mean ( ) < 1a = normal ( loc = 10 . 0 , scale = 0 . 1 , size = ( 10 , 10 ) , chunks = ( 5 , 5 ) ) assert isinstance ( a , array ) x = np . array ( a ) assert 8 < x . mean ( ) < 12
def name = da . random . normal ( 0 , 1 , size = ( 1000 , ) , chunks = ( 500 , ) ) . name assert name . startswith ( " normal " ) assert len ( key split ( name ) ) < 1name = da . random . normal ( 0 , 1 , size = ( 1000 , ) , chunks = ( 500 , ) ) . name assert name . startswith ( " normal " ) assert len ( key split ( name ) ) < 10
func x = da . ones ( ( 10 , 10 ) , chunks = ( 4 , 4 ) ) func ( x , axis = 0 , out = x ) assert eq ( x , func ( np . ones ( ( 10 , 10 ) ) , axis = 0 ) x = da . ones ( ( 10 , 10 ) , chunks = ( 4 , 4 ) ) func ( x , axis = 0 , out = x ) assert eq ( x , func ( np . ones ( ( 10 , 10 ) ) , axis = 0 ) )
size np . random . seed ( 1 ) a = np . random . randint ( 1 , 21 , ( size , size ) ) l a = np . tril ( a ) return l a . dot ( l a . t np . random . seed ( 1 ) a = np . random . randint ( 1 , 21 , ( size , size ) ) l a = np . tril ( a ) return l a . dot ( l a . t )
def x = da . ones ( 10 , chunks = ( 5 , ) ) index = np . arange ( 15 ) % 10 y = x [ index ] assert y . chunks == ( ( 5 , 5 , 5 ) , x = da . ones ( 10 , chunks = ( 5 , ) ) index = np . arange ( 15 ) % 10 y = x [ index ] assert y . chunks == ( ( 5 , 5 , 5 ) , )
def ones ( ( 1000000 , 1000000 ) , chunks = ( 100000 , 100000 ) ) ones ( shape = ( 1000000 , 1000000 ) , chunks = ( 100000 , 100000 ) ones ( ( 1000000 , 1000000 ) , chunks = ( 100000 , 100000 ) ) ones ( shape = ( 1000000 , 1000000 ) , chunks = ( 100000 , 100000 ) )
def m = np . ma . masked array ( [ 1 , 2 , 3 ] , mask = [ true , true , false ] , fill value = 10 ) dm = da . from array ( m , chunks = ( 2 , ) , asarray = false ) assert eq ( dm , m m = np . ma . masked array ( [ 1 , 2 , 3 ] , mask = [ true , true , false ] , fill value = 10 ) dm = da . from array ( m , chunks = ( 2 , ) , asarray = false ) assert eq ( dm , m )
def x = da . ones ( ( 24 , 24 ) , chunks = ( 4 , 8 ) ) y = x . rechunk ( x . chunks ) assert x is x = da . ones ( ( 24 , 24 ) , chunks = ( 4 , 8 ) ) y = x . rechunk ( x . chunks ) assert x is y
old chunks , new chunks , itemsize = 1 , block size limit = 1e7 return plan rechunk ( old chunks , new chunks , itemsize = itemsize , block size limit = block size limit chunks , new chunks , itemsize = 1 , block size limit = 1e7 return plan rechunk ( old chunks , new chunks , itemsize = itemsize , block size limit = block size limit )
x , chunks dd = pytest . importorskip ( " dask . dataframe " ) y = dd . from array ( x ) . values result = y . rechunk ( chunks ) expected = x . rechunk ( chunks ) assert chunks match ( result . chunks , expected . chunks ) assert eq ( result , expected chunks dd = pytest . importorskip ( " dask . dataframe " ) y = dd . from array ( x ) . values result = y . rechunk ( chunks ) expected = x . rechunk ( chunks ) assert chunks match ( result . chunks , expected . chunks ) assert eq ( result , expected )
def x = da . ones ( 16 , chunks = 2 ) y = x . rechunk ( 8 ) dsk = y . dask graph ( ) assert len ( dsk ) <= 8 + x = da . ones ( 16 , chunks = 2 ) y = x . rechunk ( 8 ) dsk = y . dask graph ( ) assert len ( dsk ) <= 8 + 2
def assert index subs ( tuple ( " ij " ) , { " i " : " j " , " j " : " i " } ) == tuple ( " ji " assert index subs ( tuple ( " ij " ) , { " i " : " j " , " j " : " i " } ) == tuple ( " ji " )
def x = da . arange ( 10 , chunks = 5 ) with pytest . raises ( not implemented error ) : x . map overlap ( lambda x : x + len ( x ) , depth = { 0 : ( 0 , 2 ) } , boundary = " reflect " , dtype = x . dtype x = da . arange ( 10 , chunks = 5 ) with pytest . raises ( not implemented error ) : x . map overlap ( lambda x : x + len ( x ) , depth = { 0 : ( 0 , 2 ) } , boundary = " reflect " , dtype = x . dtype )
def a = array ( { } , " x " , chunks = ( 3 , 3 ) , shape = ( 10 , 10 ) , dtype = " f8 " ) assert a . chunks == ( ( 3 , 3 , 3 , 1 ) , ( 3 , 3 , 3 , 1 ) a = array ( { } , " x " , chunks = ( 3 , 3 ) , shape = ( 10 , 10 ) , dtype = " f8 " ) assert a . chunks == ( ( 3 , 3 , 3 , 1 ) , ( 3 , 3 , 3 , 1 ) )
def x = da . ones ( ( 5 , 5 ) , chunks = ( 2 , 2 ) ) assert eq ( x . reshape ( ( 25 , ) ) , x . reshape ( 25 ) x = da . ones ( ( 5 , 5 ) , chunks = ( 2 , 2 ) ) assert eq ( x . reshape ( ( 25 , ) ) , x . reshape ( 25 ) )
def x = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) dx = da . from array ( x , chunks = 1 ) assert eq ( x , dx ) assert len ( dx . dask ) == 1 assert dx . dask [ dx . name , 0 , 0 ] is x
def x = np . random . randn ( 2 , 4 , 3 ) d = da . from array ( x , chunks = ( none , 2 , none ) ) assert d . chunks == da . from array ( x , chunks = ( 2 , 2 , 3 ) ) . chunkx = np . random . randn ( 2 , 4 , 3 ) d = da . from array ( x , chunks = ( none , 2 , none ) ) assert d . chunks == da . from array ( x , chunks = ( 2 , 2 , 3 ) ) . chunks
def assert ( da . ones ( 5 , chunks = 2 ) + 1 ) . name . startswith ( " add " assert ( da . ones ( 5 , chunks = 2 ) + 1 ) . name . startswith ( " add " )
def x = da . arange ( 5 , chunks = 1 ) [ : 0 ] y = da . blockwise ( identity , " i " , x , " i " , dtype = x . dtype ) assert eq ( x , y x = da . arange ( 5 , chunks = 1 ) [ : 0 ] y = da . blockwise ( identity , " i " , x , " i " , dtype = x . dtype ) assert eq ( x , y )
def zarr = pytest . importorskip ( " zarr " ) a = zarr . array ( [ 1 , 2 , 3 ] ) assert da . from zarr ( a , name = " foo " ) . name == " foo "zarr = pytest . importorskip ( " zarr " ) a = zarr . array ( [ 1 , 2 , 3 ] ) assert da . from zarr ( a , name = " foo " ) . name == " foo "
request return request . paraest return request . param
def x = sparse . coo . from numpy ( np . eye ( 1 ) ) y = da . utils . meta from array ( x , ndim = 2 ) assert isinstance ( y , sparse . coo x = sparse . coo . from numpy ( np . eye ( 1 ) ) y = da . utils . meta from array ( x , ndim = 2 ) assert isinstance ( y , sparse . coo )
shape x = da . random . random ( shape ) assert np . shape ( x ) == shape x = da . random . random ( shape ) assert np . shape ( x ) == shape
def , da inputs = numpy and dask inputs ( " a " ) with pytest . raises ( type error ) : da . einsum ( " a " , * da inputs , foo = 1 , bar = 2 , da inputs = numpy and dask inputs ( " a " ) with pytest . raises ( type error ) : da . einsum ( " a " , * da inputs , foo = 1 , bar = 2 )
a , returned d a = da . from array ( a , chunks = 2 ) np avg = np . average ( a , returned = returned ) da avg = da . average ( d a , returned = returned ) assert eq ( np avg , da avg returned d a = da . from array ( a , chunks = 2 ) np avg = np . average ( a , returned = returned ) da avg = da . average ( d a , returned = returned ) assert eq ( np avg , da avg )
width , height , connections d = { ( ' x ' , 0 , i ) : i for i in range ( width ) } for j in range ( 1 , height ) : d . update ( { ( ' x ' , j , i ) : ( noop , [ ( ' x ' , j 1 , randint ( 0 , width ) ) for in range ( connections ) ] ) for i in range ( width ) } ) return d , [ ( ' x ' , height 1 , i ) for i in range ( width ) ]
width , height d = { ( ' x ' , 0 , i ) : i for i in range ( width ) } for j in range ( 1 , height ) : d . update ( { ( ' x ' , j , i ) : ( noop , [ ( ' x ' , j 1 , k ) for k in range ( width ) ] ) for i in range ( width ) } ) return d , [ ( ' x ' , height 1 , i ) for i in range ( width ) ]
self , stage self . stats . update ( stage ) self . stats queue . put ( self . stats , stage self . stats . update ( stage ) self . stats queue . put ( self . stats )
obs , filter fn = none , owner = none , unit type = none , tag = none if unit type and not isinstance ( unit type , ( list , tuple ) ) : unit type = ( unit type , ) return { u . tag : u for u in obs . observation . raw data . units if ( ( filter fn is none or filter fn ( u ) ) and ( owner is none or u . owner == owner ) and ( unit type is none or u . unit type in unit type ) and ( tag is none or u . tag == tag ) ) }
self , obs return self . features . transform obs ( obs , obs return self . features . transform obs ( obs )
self , obs , act , * args return self . controller . act ( self . features . transform action ( obs . observation , actions . functions [ act ] ( * args ) , skip available = true ) , obs , act , * args return self . controller . act ( self . features . transform action ( obs . observation , actions . functions [ act ] ( * args ) , skip available = true ) )
paths for path in paths : if not os . path . exists ( path ) : os . makedirs ( path s for path in paths : if not os . path . exists ( path ) : os . makedirs ( path )
cls if platform . system ( ) == " darwin " : return if platform . system ( ) == " darwin " : return 1
target , args t = threading . thread ( target = target , args = args ) t . daemon = true t . start ( ) return et , args t = threading . thread ( target = target , args = args ) t . daemon = true t . start ( ) return t
self self . env . episode length = float ( ' inf ' ) self . test episode ( self . env self . env . episode length = float ( ' inf ' ) self . test episode ( self . env )
self self . controller . close ( ) self . controller = non self . controller . close ( ) self . controller = none
self return self . map nam return self . map name
self self . assert equal ( self . env . observation spec ( ) , self . mock env . observation spec ( ) self . assert equal ( self . env . observation spec ( ) , self . mock env . observation spec ( ) )
self , * args , ** kwargs return self . env . action spec ( * args , ** kwargs , * args , ** kwargs return self . env . action spec ( * args , ** kwargs )
self return self . env . stat return self . env . state
self return point ( int ( math . ceil ( self . x ) ) , int ( math . ceil ( self . y ) ) )
self return math . sqrt ( self . x ** 2 + self . y ** 2 )
self return point ( self . y , self . x )
self , pt , radius return self . dist ( pt ) < radius
self return self . return self . r
self size = self . size return size . x * size . size = self . size return size . x * size . y
self return rect ( self . tl . floor ( ) , self . br . floor ( ) return rect ( self . tl . floor ( ) , self . br . floor ( ) )
self self . obs . ui data . multi . units . add ( unit type = 1 ) self . assert avail ( [ " select unit " ] self . obs . ui data . multi . units . add ( unit type = 1 ) self . assert avail ( [ " select unit " ] )
self with self . assert raises ( value error ) : features . dimensions ( minimap = ( 64 , 67 ) with self . assert raises ( value error ) : features . dimensions ( minimap = ( 64 , 67 ) )
self with self . assert raises ( value error ) : features . dimensions ( screen = 64 , minimap = ( 1 , 2 , 3 ) with self . assert raises ( value error ) : features . dimensions ( screen = 64 , minimap = ( 1 , 2 , 3 ) )
self agent interface format = features . parse agent interface format ( feature screen = 32 , feature minimap = ( 24 , 24 ) , camera width world units = 77 ) self . assert equal ( agent interface format . camera width world units , 77 agent interface format = features . parse agent interface format ( feature screen = 32 , feature minimap = ( 24 , 24 ) , camera width world units = 77 ) self . assert equal ( agent interface format . camera width world units , 77 )
self for ability id , funcs in six . iteritems ( actions . ability ids ) : self . assert len ( { f . general id for f in funcs } , 1 , " multiple generals for %s " % ability id for ability id , funcs in six . iteritems ( actions . ability ids ) : self . assert len ( { f . general id for f in funcs } , 1 , " multiple generals for %s " % ability id )
self , plane if self . clip : plane = np . clip ( plane , 0 , self . scale 1 ) return self . palette [ plane , plane if self . clip : plane = np . clip ( plane , 0 , self . scale 1 ) return self . palette [ plane ]
self return self . feature dimension return self . feature dimensions
self return self . action dimension return self . action dimensions
self , req start replay return self . client . send ( start replay = req start replay )
self res = self . client . send ( save replay = sc pb . request save replay ( ) ) return res . data
self return self . client . send ( ping = sc pb . request ping ( ) return self . client . send ( ping = sc pb . request ping ( ) )
s stopwatch = stop watch ( ) for line in s . splitlines ( ) : if line . strip ( ) : parts = line . split ( none ) name = parts [ 0 ] if name != " % " : # ie not the header line rest = ( float ( v ) for v in parts [ 2 : ] ) stopwatch . times [ parts [ 0 ] ] . merge ( stat . build ( * rest ) ) return stopwatch
self , request if flags . sc2 verbose protocol : self . log ( " [%s] writing request: %s \%s " , self . port , request . which oneof ( " request " ) , self . packet str ( request ) ) self . write ( request )
action , action space , build queue id del action space action . action ui . production panel . unit index = build queue id
action del actioon del action
val if isinstance ( val , ( int , float ) ) : return val if isinstance ( val , six . string types ) : return val if ( isinstance ( val , numpy . number ) or isinstance ( val , numpy . ndarray ) and not val . shape ) : # numpy . array(1) return val . item ( ) if isinstance ( val , ( list , tuple , numpy . ndarray ) ) : return [ numpy to python ( v ) for v in val ] raise value error ( " unknown value . type: %s , repr: %s " % ( type ( val ) , repr ( val ) ) )
cls , function , arguments , raw = false args type = raw arguments if raw else arguments if isinstance ( arguments , dict ) : arguments = args type ( ** arguments ) elif not isinstance ( arguments , args type ) : arguments = args type ( * arguments ) return cls ( function , arguments )
self , color , world loc , world radius , thickness = 0 if world radius > 0 : center = self . world to surf . fwd pt ( world loc ) . round ( ) radius = max ( 1 , int ( self . world to surf . fwd dist ( world radius ) ) ) pygame . draw . circle ( self . surf , color , center , radius , thickness if thickness < radius else 0 )
self , array with sw ( " make surface " ) : raw surface = pygame . surfarray . make surface ( array . transpose ( [ 1 , 0 , 2 ] ) ) with sw ( " draw " ) : pygame . transform . scale ( raw surface , self . surf . get size ( ) , self . surf )
self return self . surf . world to obs . fwd pt ( self . world pos return self . surf . world to obs . fwd pt ( self . world pos )
self if self . obs queue : self . obs queue . put ( none ) self . render thread . join ( ) self . obs queue = none self . render thread = none if self . video writer : self . video writer . close ( ) self . video writer = non if self . obs queue : self . obs queue . put ( none ) self . render thread . join ( ) self . obs queue = none self . render thread = none if self . video writer : self . video writer . close ( ) self . video writer = none
self self . queued hotkey = " " self . queued action = non self . queued hotkey = " " self . queued action = none
self , shift action = sc pb . action ( ) action . action ui . select warp gates . selection add = shift return action
self action = sc pb . action ( ) action . action ui . select larva . set in parent ( ) return action
self , fn = none out = { } for cmd in self . obs . observation . abilities : ability = ability ( cmd , self . static data . abilities ) if not fn or fn ( ability ) : out [ ability . ability id ] = ability return list ( out . values ( ) )
self for u in sorted ( self . obs . observation . raw data . units , key = lambda u : ( u . pos . z , u . owner != 16 , u . radius , u . tag ) ) : yield u , point . point . build ( u . pos )
self return color ( int ( math . floor ( self . r ) ) , int ( math . floor ( self . g ) ) , int ( math . floor ( self . b ) ) return color ( int ( math . floor ( self . r ) ) , int ( math . floor ( self . g ) ) , int ( math . floor ( self . b ) ) )
scale return piece wise linear ( scale , [ ( 0 , color ( 0 , 0 . 5 , 0 . 4 ) * 255 ) , ( 1 , color ( 1 , 1 , 0 . 4 ) * 255 ) ] e return piece wise linear ( scale , [ ( 0 , color ( 0 , 0 . 5 , 0 . 4 ) * 255 ) , ( 1 , color ( 1 , 1 , 0 . 4 ) * 255 ) ] )
scale = none return categorical ( static data . unit types , scale )
self , num ports reserved = portspicker . pick contiguous unused ports ( num ports ) self . assert len ( reserved , num ports ) portspicker . return ports ( reserved , num ports reserved = portspicker . pick contiguous unused ports ( num ports ) self . assert len ( reserved , num ports ) portspicker . return ports ( reserved )
self , a , b np . testing . assert array equal ( a , b , a , b np . testing . assert array equal ( a , b )
self , names with self . assert raises ( value error ) : named array . named numpy array ( [ 1 , 3 , 6 ] , names , names with self . assert raises ( value error ) : named array . named numpy array ( [ 1 , 3 , 6 ] , names )
self , dist raise not implemented error ( , dist raise not implemented error ( )
self , dist return dis , dist return dist
self , proto value = proto for k in self . path : if isinstance ( k , int ) : value = value [ k ] else : value = getattr ( value , k ) return value
self return self . proto return self . proto a
self return self . remove return self . removed
self , unit self . single select = unit return sel , unit self . single select = unit return self
args , ** kwargs try : return next ( iter ( get units ( * args , ** kwargs ) . values ( ) ) ) except stop iteration : return none
self if hasattr ( self , " controllers " ) and self . controllers : for c in self . controllers : c . quit ( ) self . controllers = none if hasattr ( self , " sc2 procs " ) and self . sc2 procs : for p in self . sc2 procs : p . close ( ) self . sc2 procs = none if hasattr ( self , " ports " ) and self . ports : portspicker . return ports ( self . ports ) self . ports = none self . parallel = none
self self . debug ( 0 , game state = sc debug . god ) self . debug ( 1 , game state = sc debug . god )
self return self . builder . build ( ) . observatio return self . builder . build ( ) . observation
unit type , obs unit layer = obs . feature screen . unit type y , x = ( unit layer == unit type ) . nonzero ( ) if not y . any ( ) : return none , none return [ int ( x . mean ( ) ) , int ( y . mean ( ) ) type , obs unit layer = obs . feature screen . unit type y , x = ( unit layer == unit type ) . nonzero ( ) if not y . any ( ) : return none , none return [ int ( x . mean ( ) ) , int ( y . mean ( ) ) ]
self , replay data start replay = sc pb . request start replay ( replay data = replay data , map data = self . map data , options = self . config . interface , disable fog = false , observed player id = self . config . player id ) self . controller . start replay ( start replay , replay data start replay = sc pb . request start replay ( replay data = replay data , map data = self . map data , options = self . config . interface , disable fog = false , observed player id = self . config . player id ) self . controller . start replay ( start replay )
self return trch . parameter has valid value ( self . param return trch . parameter has valid value ( self . param )
self return [ param ( self . get name ( ) , self . get value ( ) ) return [ param ( self . get name ( ) , self . get value ( ) ) ]
self , type return trch . parameter match type ( self . param , type , type return trch . parameter match type ( self . param , type )
self return trch . parameter i pv6 get value ( self . param return trch . parameter i pv6 get value ( self . param )
self return os . path . normpath ( trch . parameter local file get value ( self . param ) return os . path . normpath ( trch . parameter local file get value ( self . param ) )
self return str ( trch . parameter port get value ( self . param ) return str ( trch . parameter port get value ( self . param ) )
self return str ( trch . parameter s64 get value ( self . param ) return str ( trch . parameter s64 get value ( self . param ) )
self return str ( trch . parameter socket get value ( self . param ) return str ( trch . parameter socket get value ( self . param ) )
self tokens = trch . parameter i pv4 list get value ( self . param ) twrapped = [ " ' " + x + " ' " for x in tokens ] return ' [ ' + ' , ' . join ( twrapped ) + ' ] ' tokens = trch . parameter i pv4 list get value ( self . param ) twrapped = [ " ' " + x + " ' " for x in tokens ] return ' [ ' + ' , ' . join ( twrapped ) + ' ] '
self , value arg = self . tokenize list ( value ) trch . parameter i pv6 list set value ( self . param , arg , value arg = self . tokenize list ( value ) trch . parameter i pv6 list set value ( self . param , arg )
self tokens = trch . parameter local file list get value ( self . param ) twrapped = [ " ' " + x + " ' " for x in tokens ] return ' [ ' + ' , ' . join ( twrapped ) + ' ] ' tokens = trch . parameter local file list get value ( self . param ) twrapped = [ " ' " + x + " ' " for x in tokens ] return ' [ ' + ' , ' . join ( twrapped ) + ' ] '
self , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter port list set value ( self . param , tokens , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter port list set value ( self . param , tokens )
self tokens = trch . parameter port list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] ' tokens = trch . parameter port list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] '
self , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter socket list set value ( self . param , tokens , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter socket list set value ( self . param , tokens )
self tokens = trch . parameter u16 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] ' tokens = trch . parameter u16 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] '
self , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter u8 list set value ( self . param , tokens , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter u8 list set value ( self . param , tokens )
self return self . is valid ( return self . is valid ( )
self return trch . paramchoice has valid value ( self . choice return trch . paramchoice has valid value ( self . choice )
self , value trch . paramchoice set value ( self . choice , str ( value ) , value trch . paramchoice set value ( self . choice , str ( value ) )
self , name return self . find option ( name ) . get description ( , name return self . find option ( name ) . get description ( )
self , name return self . find option ( name ) . get format ( , name return self . find option ( name ) . get format ( )
self , name if self . has value ( name ) : return self . find option ( name ) . get value ( ) else : return " " , name if self . has value ( name ) : return self . find option ( name ) . get value ( ) else : return " "
self return self . name
self names = [ ] classes = [ self . class ] while classes : aclass = classes . pop ( 0 ) if aclass . bases : classes = classes + list ( aclass . bases ) names = names + dir ( aclass ) return name names = [ ] classes = [ self . class ] while classes : aclass = classes . pop ( 0 ) if aclass . bases : classes = classes + list ( aclass . bases ) names = names + dir ( aclass ) return names
self return " %s %s " % ( self . prefix , self . error return " %s %s " % ( self . prefix , self . error )
self , current ' ' ' move forward through the history list , fetching the next command . ' ' ' if self . history cursor < len ( self . history ) 1 : self . history cursor += 1 current . set line ( self . history [ self . history cursor ] . get line text ( ) , current ' ' ' move forward through the history list , fetching the next command . ' ' ' if self . history cursor < len ( self . history ) 1 : self . history cursor += 1 current . set line ( self . history [ self . history cursor ] . get line text ( ) )
self , partial ' ' ' search backward through the history for the string of characters between the start of the current line and the point . this is a non incremental search . by default , this command is unbound . ' ' ' q = self . search ( 1 , partial ) return , partial ' ' ' search backward through the history for the string of characters between the start of the current line and the point . this is a non incremental search . by default , this command is unbound . ' ' ' q = self . search ( 1 , partial ) return q
self , rect , attr = none , fill = ' ' ' ' ' fill rectangle . ' ' ' raise not implemented erro , rect , attr = none , fill = ' ' ' ' ' fill rectangle . ' ' ' raise not implemented error
self , attr = none , fill = ' ' ' ' ' fill the entire screen . ' ' ' raise not implemented erro , attr = none , fill = ' ' ' ' ' fill the entire screen . ' ' ' raise not implemented error
self t = self . t l = lineobj . read line text buffer ( t , point = len ( t ) ) for i in range ( len ( t ) ) : l . point = i l . point = lineobj . end of line self . assert equal ( len ( t ) , l . point t = self . t l = lineobj . read line text buffer ( t , point = len ( t ) ) for i in range ( len ( t ) ) : l . point = i l . point = lineobj . end of line self . assert equal ( len ( t ) , l . point )
self t = self . t l = lineobj . read line text buffer ( t , point = len ( t ) ) for i in range ( len ( t ) ) : l . point = i l . point = lineobj . start of line self . assert equal ( 0 , l . point t = self . t l = lineobj . read line text buffer ( t , point = len ( t ) ) for i in range ( len ( t ) ) : l . point = i l . point = lineobj . start of line self . assert equal ( 0 , l . point )
name def get ( self ) : return self . info [ name ] def set ( self , value ) : self . info [ name ] = value return property ( get , set def get ( self ) : return self . info [ name ] def set ( self , value ) : self . info [ name ] = value return property ( get , set )
str from mcl . object . xml output import xml output xml = xml output ( ) xml . start ( ' error string ' ) xml . set text ( str ) output xml ( xml from mcl . object . xml output import xml output xml = xml output ( ) xml . start ( ' error string ' ) xml . set text ( str ) output xml ( xml )
demarsh import socket val1 = socket . ntohl ( demarsh . get u32 ( ) ) val2 = socket . ntohl ( demarsh . get u32 ( ) ) return val2 << 32 | valrsh import socket val1 = socket . ntohl ( demarsh . get u32 ( ) ) val2 = socket . ntohl ( demarsh . get u32 ( ) ) return val2 << 32 | val1
self , data self . data = dat , data self . data = data
self , dest self . dest = des , dest self . dest = dest
self , depth = 0 if depth != 0 : self . m xml . add sub element with text ( ' search recursive ' , ' %u ' % depth ) else : self . m xml . add sub element ( ' search recursive ' , depth = 0 if depth != 0 : self . m xml . add sub element with text ( ' search recursive ' , ' %u ' % depth ) else : self . m xml . add sub element ( ' search recursive ' )
res name = none import mcl platform . tasking . resource return mcl platform . tasking . resource . get name ( res name ame = none import mcl platform . tasking . resource return mcl platform . tasking . resource . get name ( res name )
self return self . m second return self . m seconds
self , key , instance = 1 try : entry = self . find cache entry ( key , instance ) return { ' key ' : entry [ ' key ' ] , ' type ' : entry [ ' type ' ] } except : return none return non , key , instance = 1 try : entry = self . find cache entry ( key , instance ) return { ' key ' : entry [ ' key ' ] , ' type ' : entry [ ' type ' ] } except : return none return none
self , key , data , endianess = msg type modifier native endian self . add ( msg type s64 , key , data , endianess , key , data , endianess = msg type modifier native endian self . add ( msg type s64 , key , data , endianess )
self , str if str == none : str = ' ' self . add u32 ( len ( str ) + 1 ) for c in str : self . m data . append ( ord ( c ) ) self . m data . append ( 0 ) retur , str if str == none : str = ' ' self . add u32 ( len ( str ) + 1 ) for c in str : self . m data . append ( ord ( c ) ) self . m data . append ( 0 ) return
self return self . m dat return self . m data
self , error str from mcl . object . xml output import xml output xml = xml output ( ) xml . start ( ' error string ' ) xml . set text ( error str ) self . record xml ( xml , error str from mcl . object . xml output import xml output xml = xml output ( ) xml . start ( ' error string ' ) xml . set text ( error str ) self . record xml ( xml )
self , ids self . m task ids = id , ids self . m task ids = ids
self , index if index < len ( self . m help ) : return self . m help [ index ] else : return ' ' , index if index < len ( self . m help ) : return self . m help [ index ] else : return ' '
self return len ( self . m help return len ( self . m help )
self return self . m int valu return self . m int value
self return self . m bool valu return self . m bool value
self , data name , value self . m set data [ data name ] = valu , data name , value self . m set data [ data name ] = value
self return self . m argument return self . m arguments
self self . m found = tru self . m found = true
namespace , module , caller globals temp = import ( namespace + module , caller globals , locals ( ) , [ module ] , 1 ) reload ( temp ) for name in temp . dict . keys ( ) : if not name . startswith ( ' ' ) : caller globals [ name ] = temp . dict [ name space , module , caller globals temp = import ( namespace + module , caller globals , locals ( ) , [ module ] , 1 ) reload ( temp ) for name in temp . dict . keys ( ) : if not name . startswith ( ' ' ) : caller globals [ name ] = temp . dict [ name ]
def dsz . dsz obj . flags normalize ( dsz . dsz obj . flags normalize ( )
ms , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) dsz . dsz obj . sleep ( ms , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) dsz . dsz obj . sleep ( ms )
self return is alive ( self . id return is alive ( self . id )
self return dsz . cmd . data . get ( ' command meta data:: child:: id ' , dsz . type int , self . id return dsz . cmd . data . get ( ' command meta data:: child:: id ' , dsz . type int , self . id )
self self . directory item = list ( ) try : for x in dsz . cmd . data . get ( ' directory item ' , dsz . type object ) : self . directory item . append ( objects . directory item ( x ) ) except : pas self . directory item = list ( ) try : for x in dsz . cmd . data . get ( ' directory item ' , dsz . type object ) : self . directory item . append ( objects . directory item ( x ) ) except : pass
self try : self . user = who am i . user ( dsz . cmd . data . get ( ' user ' , dsz . type object ) [ 0 ] ) except : self . user = none retur try : self . user = who am i . user ( dsz . cmd . data . get ( ' user ' , dsz . type object ) [ 0 ] ) except : self . user = none return
self try : self . version item = version . version item ( dsz . cmd . data . get ( ' version item ' , dsz . type object ) [ 0 ] ) except : self . version item = none retur try : self . version item = version . version item ( dsz . cmd . data . get ( ' version item ' , dsz . type object ) [ 0 ] ) except : self . version item = none return
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result fullpath , self . dict [ ' full path ' ] ) mmsg . add message ( msg key result , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result fullpath , self . dict [ ' full path ' ] ) mmsg . add message ( msg key result , submsg )
self try : self . current directory = cd . current directory ( dsz . cmd . data . get ( ' current directory ' , dsz . type object ) [ 0 ] ) except : self . current directory = none retur try : self . current directory = cd . current directory ( dsz . cmd . data . get ( ' current directory ' , dsz . type object ) [ 0 ] ) except : self . current directory = none return
self , ret return ret . list type == self . list typ , ret return ret . list type == self . list type
addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' compiled os ' , addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' compiled os ' , addr )
addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' minor version ' , addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' minor version ' , addr )
str , type = dsz . dsz obj . default , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) dsz . dsz obj . echo ( str , type , type = dsz . dsz obj . default , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) dsz . dsz obj . echo ( str , type )
str = ' ' , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) dsz . dsz obj . pause ( str = ' ' , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) dsz . dsz obj . pause ( str )
self , tabcnt dsz . script . data . start ( ' options ' ) dsz . ui . echo ( tab * tabcnt + ' options ' ) dsz . ui . echo ( tab * tabcnt + ' ' ) self . store known ( tabcnt ) dsz . script . data . end ( , tabcnt dsz . script . data . start ( ' options ' ) dsz . ui . echo ( tab * tabcnt + ' options ' ) dsz . ui . echo ( tab * tabcnt + ' ' ) self . store known ( tabcnt ) dsz . script . data . end ( )
dirres retval = [ ] for moddir in dirres . diritem : retval . extend ( filter ( ( lambda x : ( x . name not in filters ) ) , moddir . fileitem ) ) return retvaes retval = [ ] for moddir in dirres . diritem : retval . extend ( filter ( ( lambda x : ( x . name not in filters ) ) , moddir . fileitem ) ) return retval
fileitem myhash = hashlib . md5 ( ) myhash . update ( ops . utf8 ( ( ' %s%s%s ' % ( fileitem . filetimes . modified . time , fileitem . dszparent . path , fileitem . name ) ) ) ) return binascii . hexlify ( myhash . digest ( ) item myhash = hashlib . md5 ( ) myhash . update ( ops . utf8 ( ( ' %s%s%s ' % ( fileitem . filetimes . modified . time , fileitem . dszparent . path , fileitem . name ) ) ) ) return binascii . hexlify ( myhash . digest ( ) )
session , type conn = get database conn ( ) curs = query execute wrapper ( conn , query string = ' insert into scansweep jobtype (session , type) values (? , ?) ' , query list = [ session , type ] ) return truion , type conn = get database conn ( ) curs = query execute wrapper ( conn , query string = ' insert into scansweep jobtype (session , type) values (? , ?) ' , query list = [ session , type ] ) return true
def scansweep db file = os . path . join ( ops . projectlogdir , ' scansweep . db ' ) scansweepdb = ops . db . get this db ( scansweep db file ) return scansweepdscansweep db file = os . path . join ( ops . projectlogdir , ' scansweep . db ' ) scansweepdb = ops . db . get this db ( scansweep db file ) return scansweepdb
self , escalation rule arp = self try : if eval ( escalation rule ) : return true else : return false except : return fals , escalation rule arp = self try : if eval ( escalation rule ) : return true else : return false except : return false
self return [ ' target ' , ' port ' , ' success ' , ' error ' return [ ' target ' , ' port ' , ' success ' , ' error ' ]
self , escalation rule banner = self try : if eval ( escalation rule ) : return true else : return false except : return fals , escalation rule banner = self try : if eval ( escalation rule ) : return true else : return false except : return false
self return [ return [ ]
self return [ ' target ' , ' mac ' , ' oui ' , ' name ' , ' group ' , ' services ' , ' target id ' , ' timestamp ' return [ ' target ' , ' mac ' , ' oui ' , ' name ' , ' group ' , ' services ' , ' target id ' , ' timestamp ' ]
self return 1 return 15
self return ( ' rp ctouch response for %s ' % self . target return ( ' rp ctouch response for %s ' % self . target )
self return [ ' target ' , ' port ' , ' os ' , ' timestamp ' return [ ' target ' , ' port ' , ' os ' , ' timestamp ' ]
def return ' ping 'return ' ping '
self l files = self . list files ( ) size = 0 for f in l files : size += f . size print ( ' about to get %d files totalling %d bytes . will prompt for individual files > %d bytes ' % ( len ( l files ) , size , self . get max size ( ) ) l files = self . list files ( ) size = 0 for f in l files : size += f . size print ( ' about to get %d files totalling %d bytes . will prompt for individual files > %d bytes ' % ( len ( l files ) , size , self . get max size ( ) ) )
name , proj name = none return get ( name , db handle = ops . project . get pdb ( proj name ) , proj name = none return get ( name , db handle = ops . project . get pdb ( proj name ) )
proj name = none return get all ( db handle = ops . project . get pdb ( proj name ) name = none return get all ( db handle = ops . project . get pdb ( proj name ) )
env , cmdid = 0 , addr = dsz . script . env [ ' target address ' ] if ( not dsz . env . check ( env , cmdid , addr ) ) : return none else : return unicode ( dsz . env . get ( env , cmdid , addr ) , ' utf 8 ' , cmdid = 0 , addr = dsz . script . env [ ' target address ' ] if ( not dsz . env . check ( env , cmdid , addr ) ) : return none else : return unicode ( dsz . env . get ( env , cmdid , addr ) , ' utf 8 ' )
self return ( self . audit event success == 1 return ( self . audit event success == 1 )
def if ( not os . path . exists ( donuts ) ) : return false flags = none with open ( donuts ) as input : try : flags = json . load ( input ) except : return false for i in flags . keys ( ) : ops . env . set ( i , flags [ i ] ) return truif ( not os . path . exists ( donuts ) ) : return false flags = none with open ( donuts ) as input : try : flags = json . load ( input ) except : return false for i in flags . keys ( ) : ops . env . set ( i , flags [ i ] ) return true
name , comment if ( ( name is none ) or ( name == ' none ' ) ) : return none name = ( marker prefix % name ) initdb ( ) ops . marker . set volatile ( name , comment , comment if ( ( name is none ) or ( name == ' none ' ) ) : return none name = ( marker prefix % name ) initdb ( ) ops . marker . set volatile ( name , comment )
value mark ( value , started e mark ( value , started )
self return self . namespac return self . namespace
self return self . processor . forcemen return self . processor . forcemenu
self self . process ( self . process ( )
self return self . handle ( validate = true return self . handle ( validate = true )
self return self . process ( validate = true return self . process ( validate = true )
self return self . process ( return self . process ( )
self if ( ' recursive ' in self . optdict ) : return true else : return fals if ( ' recursive ' in self . optdict ) : return true else : return false
self for opt in self . optdict : if ( opt not in valid options ) : return false return tru for opt in self . optdict : if ( opt not in valid options ) : return false return true
self , val if ( val is none ) : if ( ' target ' in self . optdict ) : del self . optdict [ ' target ' ] return self . optdict [ ' target ' ] = va , val if ( val is none ) : if ( ' target ' in self . optdict ) : del self . optdict [ ' target ' ] return self . optdict [ ' target ' ] = val
self if ( ( ' wow64 ' in self . optdict ) and self . optdict [ ' wow64 ' ] ) : return true else : return fals if ( ( ' wow64 ' in self . optdict ) and self . optdict [ ' wow64 ' ] ) : return true else : return false
self if ( ( ' wow32 ' in self . optdict ) and self . optdict [ ' wow32 ' ] ) : return true else : return fals if ( ( ' wow32 ' in self . optdict ) and self . optdict [ ' wow32 ' ] ) : return true else : return false
self return self . opt object numbe return self . opt object number
self if ( self . result is not none ) : self . result . update ( ) if ( self . result . commandmetadata . isrunning == 1 ) : dsz . cmd . run ( ( ' stop %d ' % self . channel ) if ( self . result is not none ) : self . result . update ( ) if ( self . result . commandmetadata . isrunning == 1 ) : dsz . cmd . run ( ( ' stop %d ' % self . channel ) )
self return ( ' log ' in self . prefixes return ( ' log ' in self . prefixes )
self , val if ( ( ( val is none ) or ( val is false ) ) and ( ' force ' in self . optdict ) ) : del self . optdict [ ' force ' ] elif val : self . optdict [ ' force ' ] = tru , val if ( ( ( val is none ) or ( val is false ) ) and ( ' force ' in self . optdict ) ) : del self . optdict [ ' force ' ] elif val : self . optdict [ ' force ' ] = true
self if ( ( ' udp ' in self . optdict ) and self . optdict [ ' udp ' ] ) : return true else : return fals if ( ( ' udp ' in self . optdict ) and self . optdict [ ' udp ' ] ) : return true else : return false
self return self . bind add return self . bind addr
self return self . target por return self . target port
self return self . client add return self . client addr
maxage = datetime . timedelta . max , target id = none ( timeitem , now ) = sync ( maxage , target id ) return timeitem . skege = datetime . timedelta . max , target id = none ( timeitem , now ) = sync ( maxage , target id ) return timeitem . skew
maxage = datetime . timedelta . max , target id = none ( timeitem , now ) = sync ( maxage , target id ) return ( now + timeitem . skew ge = datetime . timedelta . max , target id = none ( timeitem , now ) = sync ( maxage , target id ) return ( now + timeitem . skew )
cmd , uniqid return datacache . get ( ' {0} {1} ' . format ( cmd , uniqid ) , none , uniqid return datacache . get ( ' {0} {1} ' . format ( cmd , uniqid ) , none )
self ret = { } for attr in self . data to save . values ( ) : ret [ attr . name ] = self [ attr . name ] return re ret = { } for attr in self . data to save . values ( ) : ret [ attr . name ] = self [ attr . name ] return ret
self dsz . ui . echo ( ' directory listing ' ) cmds = create command line for cmd in cmds : dsz . ui . echo ( ( ' `%s` ' % cmd ) ) dsz . ui . echo ( ( ' %s ' % self . concerns ) , dsz . warning dsz . ui . echo ( ' directory listing ' ) cmds = create command line for cmd in cmds : dsz . ui . echo ( ( ' `%s` ' % cmd ) ) dsz . ui . echo ( ( ' %s ' % self . concerns ) , dsz . warning )
ch , size str = ' ' for i in range ( 0 , size ) : str = ( ' %s%s ' % ( str , ch ) ) return st, size str = ' ' for i in range ( 0 , size ) : str = ( ' %s%s ' % ( str , ch ) ) return str
self return [ ' systemversion ' , ' packages ' return [ ' systemversion ' , ' packages ' ]
self return fals return false
s reduced handle = reduce handle ( s . fileno ( ) ) return rebuild socket , ( reduced handle , s . family , s . type , s . proto duced handle = reduce handle ( s . fileno ( ) ) return rebuild socket , ( reduced handle , s . family , s . type , s . proto )
typecode or type , * args , ** kwds ' ' ' returns a synchronized shared object ' ' ' from multiprocessing . sharedctypes import value return value ( typecode or type , * args , ** kwds code or type , * args , ** kwds ' ' ' returns a synchronized shared object ' ' ' from multiprocessing . sharedctypes import value return value ( typecode or type , * args , ** kwds )
path try : os . lstat ( path ) except os . error : return false return true
self if self . is cgi ( ) : return self . run cgi ( ) else : return simple http server . simple http request handler . send head ( self )
self raise not implemented error ( ' method must be implemented by subclass ' )
self , key os . remove ( os . path . join ( self . path , self . lookup ( key ) ) )
self result = [ ] for entry in os . listdir ( self . path ) : if len ( entry ) > 1 and entry [ 0 ] == ' . ' and os . path . isdir ( os . path . join ( self . path , entry ) ) : result . append ( entry [ 1 : ] ) return result
self , folder path = os . path . join ( self . path , ' . ' + folder ) result = maildir ( path , factory = self . factory ) maildirfolder path = os . path . join ( path , ' maildirfolder ' ) if not os . path . exists ( maildirfolder path ) : os . close ( os . open ( maildirfolder path , os . o creat | os . o wronly , 438 ) ) return result
self , f f . write ( os . linesep + ' \\x01\\x01\\x01\\x01 ' + os . linesep )
self , folder return mh ( os . path . join ( self . path , folder ) , factory = self . factory , create = false )
self , folder return mh ( os . path . join ( self . path , folder ) , factory = self . factory )
self , key return string io . string io ( self . get string ( key ) . replace ( ' \ ' , os . linesep ) )
self , f f . write ( os . linesep + ' \\x1f ' )
self return self . get ( ' status ' , ' ' ) + self . get ( ' x status ' , ' ' )
self , sequences self . sequences = list ( sequences )
self , labels self . labels = list ( labels )
