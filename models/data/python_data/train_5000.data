response , soup config if ( " text/html " in response . headers . get ( " content type " , " " ) or browser . looks like html ( response ) ) : response . soup = bs4 . beautiful soup ( response . content , ** soup config ) else : response . soup = none
self , cookiejar self . session . cookies = cookiejar
self return self . session . cookies
self , user agent if user agent is none : requests ua = requests . utils . default user agent ( ) user agent = ' %s (%s/%s) ' % ( requests ua , title , version ) self . session . headers [ ' user agent ' ] = user agent
self , * args , ** kwargs response = self . session . request ( * args , ** kwargs ) browser . add soup ( response , self . soup config ) return response
self , * args , ** kwargs response = self . session . get ( * args , ** kwargs ) if self . raise on 404 and response . status code == 404 : raise link not found error ( ) browser . add soup ( response , self . soup config ) return response
self , form , url = none , ** kwargs if isinstance ( form , form ) : form = form . form response = self . request ( form , url , ** kwargs ) browser . add soup ( response , self . soup config ) return response
self , soup with tempfile . named temporary file ( delete = false , suffix = ' . html ' ) as file : file . write ( soup . encode ( ) ) webbrowser . open ( ' file:// ' + file . name )
self , data for ( name , value ) in data . items ( ) : i = self . form . find ( " input " , { " name " : name } ) if not i : raise invalid form method ( " no input field named " + name ) i [ " value " ] = value
self , name for option in self . form . find all ( " input " , { " name " : name } ) : if " checked " in option . attrs : del option . attrs [ " checked " ]
self , data for ( name , value ) in data . items ( ) : t = self . form . find ( " textarea " , { " name " : name } ) if not t : raise invalid form method ( " no textarea named " + name ) t . string = value
self , name , value , force = false for func in ( " checkbox " , " radio " , " input " , " textarea " , " select " ) : try : getattr ( self , " set " + func ) ( { name : value } ) return except invalid form method : pass if force : self . new control ( ' text ' , name , value = value ) return raise link not found error ( " no valid element named " + name )
self , type , name , value , ** kwargs for tag in ( ' input ' , ' textarea ' , ' select ' ) : for old in self . form . find all ( tag , { ' name ' : name } ) : old . decompose ( ) control = beautiful soup ( " " , " html . parser " ) . new tag ( ' input ' ) control [ ' type ' ] = type control [ ' name ' ] = name control [ ' value ' ] = value for k , v in kwargs . items ( ) : control [ k ] = v self . form . append ( control ) return control
self , tag name , type attr , attrs attrs dict = attrs . copy ( ) attrs dict [ ' type ' ] = lambda x : x and x . lower ( ) == type attr return self . form . find all ( tag name , attrs = attrs dict , tag name , type attr , attrs attrs dict = attrs . copy ( ) attrs dict [ ' type ' ] = lambda x : x and x . lower ( ) == type attr return self . form . find all ( tag name , attrs = attrs dict )
self , debug self . debug = debug
self return self . debug
self , verbose self . verbose = verbose
self return self . verbose
self return self . state . page
self , type , name , value , ** kwargs return self . form . new control ( type , name , value , ** kwargs )
self , url return urllib . parse . urljoin ( self . url , url )
self , url , * args , ** kwargs return self . open ( self . absolute url ( url ) , * args , ** kwargs )
self old request = self . state . request if old request is none : raise value error ( ' the current page is not refreshable . either no ' ' page is opened or low level browser methods ' ' were used to do so ' ) resp = self . session . send ( old request ) browser . add soup ( resp , self . soup config ) self . state = browser state ( page = resp . soup , url = resp . url , request = resp . request ) return resp
self , * args , ** kwargs print ( " links in the current page: " ) for l in self . links ( * args , ** kwargs ) : print ( " " , l )
self , url regex = none , link text = none , * args , ** kwargs all links = self . page . find all ( ' a ' , href = true , * args , ** kwargs ) if url regex is not none : all links = [ a for a in all links if re . search ( url regex , a [ ' href ' ] ) ] if link text is not none : all links = [ a for a in all links if a . text == link text ] return all links
self , * args , ** kwargs links = self . links ( * args , ** kwargs ) if len ( links ) == 0 : raise link not found error ( ) else : return links [ 0 ]
self , link = none , * args , ** kwargs link = self . find link internal ( link , args , kwargs ) referer = self . url headers = { ' referer ' : referer } if referer else none return self . open relative ( link [ ' href ' ] , headers = headers )
self , link = none , file = none , * args , ** kwargs link = self . find link internal ( link , args , kwargs ) url = self . absolute url ( link [ ' href ' ] ) referer = self . url headers = { ' referer ' : referer } if referer else none response = self . session . get ( url , headers = headers ) if self . raise on 404 and response . status code == 404 : raise link not found error ( ) if file is not none : with open ( file , ' wb ' ) as f : f . write ( response . content ) return response
self , soup = none if soup is none : soup = self . page super ( stateful browser , self ) . launch browser ( soup )
def soup = bs4 . beautiful soup ( ' <notform> this is not a form</notform> ' , ' lxml ' ) tag = soup . find ( ' notform ' ) assert isinstance ( tag , bs4 . element . tag ) pytest . deprecated call ( mechanicalsoup . form , tag )
def text = ' ' ' <form> <input type= " submit " name= " test1 " value= " test1 " /> <input type= " submit " name= " test2 " value= " test2 " /> </form> ' ' ' soup = bs4 . beautiful soup ( text , ' lxml ' ) form = mechanicalsoup . form ( soup . form ) form . choose submit ( ' test1 ' ) expected msg = ' submit already chosen . cannot change submit! ' with pytest . raises ( exception , match = expected msg ) : form . choose submit ( ' test2 ' )
def browser = mechanicalsoup . stateful browser ( ) browser . open fake page ( choose submit multiple match form ) form = browser . select form ( ' #choose submit form ' ) with pytest . raises ( mechanicalsoup . utils . link not found error ) : form . choose submit ( ' test submit ' browser = mechanicalsoup . stateful browser ( ) browser . open fake page ( choose submit multiple match form ) form = browser . select form ( ' #choose submit form ' ) with pytest . raises ( mechanicalsoup . utils . link not found error ) : form . choose submit ( ' test submit ' )
options if not isinstance ( options , list ) and not isinstance ( options , tuple ) : expected = [ ( ' instrument ' , options ) ] else : expected = [ ( ' instrument ' , option ) for option in options ] browser , url = setup mock browser ( expected post = expected , text = set select multiple form ) browser . open ( url ) form = browser . select form ( ' form ' ) form . set select ( { ' instrument ' : options } ) res = browser . submit selected ( ) assert res . status code == 200 and res . text == ' success! '
capsys browser = mechanicalsoup . stateful browser ( ) browser . open fake page ( page with various fields , url = " http://example . com/invalid/ " ) form = browser . select form ( " form " ) form . set radio ( { " size " : " small " } ) form . set checkbox ( { " topping " : " cheese " } ) browser . form . print summary ( ) out , err = capsys . readouterr ( ) out = out . replace ( ' ></input> ' , ' /> ' ) assert out == assert err == " "
capsys browser = mechanicalsoup . stateful browser ( ) browser . open fake page ( page with various fields , url = " http://example . com/invalid/ " ) browser . select form ( " form " ) browser . form . print summary ( ) out , err = capsys . readouterr ( ) out = out . replace ( ' ></input> ' , ' /> ' ) assert out == assert err == " "
def browser = mechanicalsoup . stateful browser ( ) html = ' ' ' <form> <input type= " submit " value= " invalid " /> <input type= " submit " name= " valid " value= " valid " /></form> ' ' ' browser . open fake page ( html ) form = browser . select form ( ) with pytest . raises ( mechanicalsoup . utils . link not found error ) : form . choose submit ( ' not found ' )
httpbin form html = """ <form method= " post " action={}/post> <select name= " shape " > <option value= " round " > round</option> <option value= " square " > square</option> </select> </form> """ . format ( httpbin . url ) form = beautiful soup ( form html , " lxml " ) . form browser = mechanicalsoup . browser ( ) response = browser . request ( form ) assert response . json ( ) [ ' form ' ] == { ' shape ' : ' round ' }
httpbin form html = """ <form method= " post " action= " {}/post " > <input disabled name= " nosubmit " value= " 1 " /> </form> """ . format ( httpbin . url ) browser = mechanicalsoup . browser ( ) response = browser . request ( beautiful soup ( form html , " lxml " ) . form ) assert response . json ( ) [ ' form ' ] == { }
httpbin browser = mechanicalsoup . browser ( ) resp = browser . get ( httpbin + " /nosuchpage " ) assert resp . status code == 40bin browser = mechanicalsoup . browser ( ) resp = browser . get ( httpbin + " /nosuchpage " ) assert resp . status code == 404
httpbin browser = mechanicalsoup . browser ( raise on 404 = true ) with pytest . raises ( mechanicalsoup . link not found error ) : resp = browser . get ( httpbin + " /nosuchpage " ) resp = browser . get ( httpbin . url ) assert resp . status code == 20bin browser = mechanicalsoup . browser ( raise on 404 = true ) with pytest . raises ( mechanicalsoup . link not found error ) : resp = browser . get ( httpbin + " /nosuchpage " ) resp = browser . get ( httpbin . url ) assert resp . status code == 200
httpbin jar = requests cookie jar ( ) jar . set ( ' field ' , ' value ' ) assert jar . get ( ' field ' ) == ' value ' browser = mechanicalsoup . browser ( ) browser . set cookiejar ( jar ) resp = browser . get ( httpbin + " /cookies " ) assert resp . json ( ) == { ' cookies ' : { ' field ' : ' value ' } }
httpbin browser = mechanicalsoup . browser ( ) data = { ' color ' : ' blue ' , ' colorblind ' : ' true ' } resp = browser . post ( httpbin + " /post " , data ) assert resp . status code == 200 and resp . json ( ) [ ' form ' ] == datbin browser = mechanicalsoup . browser ( ) data = { ' color ' : ' blue ' , ' colorblind ' : ' true ' } resp = browser . post ( httpbin + " /post " , data ) assert resp . status code == 200 and resp . json ( ) [ ' form ' ] == data
expected post = none , text = choose submit form url = ' mock://form . com ' browser , mock = prepare mock browser ( ) mock get ( mock , url , text ) if expected post is not none : mock post ( mock , url + ' /post ' , expected post ) return browser , urcted post = none , text = choose submit form url = ' mock://form . com ' browser , mock = prepare mock browser ( ) mock get ( mock , url , text ) if expected post is not none : mock post ( mock , url + ' /post ' , expected post ) return browser , url
scheme = ' mock ' mock = requests mock . adapter ( ) browser = mechanicalsoup . stateful browser ( requests adapters = { scheme : mock } ) return browser , mocme = ' mock ' mock = requests mock . adapter ( ) browser = mechanicalsoup . stateful browser ( requests adapters = { scheme : mock } ) return browser , mock
mocked adapter , url , reply , content type = ' text/html ' , ** kwargs headers = { ' content type ' : content type } mocked adapter . register uri ( ' get ' , url , headers = headers , text = reply , ** kwargs ed adapter , url , reply , content type = ' text/html ' , ** kwargs headers = { ' content type ' : content type } mocked adapter . register uri ( ' get ' , url , headers = headers , text = reply , ** kwargs )
browser , httpbin try : response = browser . open ( httpbin + " /legacy " ) if response . status code == 404 : # the line above may or may not have raised the exception # depending on raise on 404 . raise it unconditionally now . raise mechanicalsoup . link not found error ( ) except mechanicalsoup . link not found error : browser . open ( httpbin . url )
def data = [ ( ' var1 ' , ' val1 ' ) , ( ' var2 ' , ' val2 ' ) ] browser , url = setup mock browser ( expected post = data ) r = browser . request ( ' post ' , url + ' /post ' , data = data ) assert r . text == ' success! 'data = [ ( ' var1 ' , ' val1 ' ) , ( ' var2 ' , ' val2 ' ) ] browser , url = setup mock browser ( expected post = data ) r = browser . request ( ' post ' , url + ' /post ' , data = data ) assert r . text == ' success! '
def browser = mechanicalsoup . stateful browser ( ) browser . open fake page ( ' <form></form> ' , url = " http://example . com " ) assert browser . page == browser . get current page ( ) assert browser . page is not none assert browser . url == browser . get url ( ) assert browser . url is not none browser . select form ( ) assert browser . form == browser . get current form ( ) assert browser . form is not none
def browser = mechanicalsoup . stateful browser ( ) browser . open fake page ( ' <form></form> ' ) with pytest . raises ( attribute error , match = " no form has been selected yet . " ) : browser . form assert browser . get current form ( ) is nonbrowser = mechanicalsoup . stateful browser ( ) browser . open fake page ( ' <form></form> ' ) with pytest . raises ( attribute error , match = " no form has been selected yet . " ) : browser . form assert browser . get current form ( ) is none
httpbin browser = mechanicalsoup . stateful browser ( ) resp = browser . open ( httpbin + " /nosuchpage " ) assert resp . status code == 40bin browser = mechanicalsoup . stateful browser ( ) resp = browser . open ( httpbin + " /nosuchpage " ) assert resp . status code == 404
def browser = mechanicalsoup . stateful browser ( ) assert not browser . get debug ( ) browser . set debug ( true ) assert browser . get debug ( browser = mechanicalsoup . stateful browser ( ) assert not browser . get debug ( ) browser . set debug ( true ) assert browser . get debug ( )
def browser = mechanicalsoup . stateful browser ( ) browser . open fake page ( ' <html></html> ' ) with pytest . raises ( mechanicalsoup . link not found error ) : browser . find link ( ' nosuchlink ' browser = mechanicalsoup . stateful browser ( ) browser . open fake page ( ' <html></html> ' ) with pytest . raises ( mechanicalsoup . link not found error ) : browser . find link ( ' nosuchlink ' )
def browser , url = setup mock browser ( ) browser . open fake page ( submit form noaction ) browser . select form ( ' #choose submit form ' ) with pytest . raises ( value error , match = " no url to submit to " ) : browser . submit selected ( browser , url = setup mock browser ( ) browser . open fake page ( submit form noaction ) browser . select form ( ' #choose submit form ' ) with pytest . raises ( value error , match = " no url to submit to " ) : browser . submit selected ( )
def browser , url = setup mock browser ( expected post = [ ] ) browser . open fake page ( submit form noname , url = url ) browser . select form ( ' #choose submit form ' ) response = browser . submit selected ( ) assert response . status code == 200 and response . text == ' success! 'browser , url = setup mock browser ( expected post = [ ] ) browser . open fake page ( submit form noname , url = url ) browser . select form ( ' #choose submit form ' ) response = browser . submit selected ( ) assert response . status code == 200 and response . text == ' success! '
def forms = """ <form id= " a " ></form><form id= " b " ></form><p></p> """ soup = beautiful soup ( forms , " lxml " ) with mechanicalsoup . stateful browser ( ) as browser : browser . open fake page ( forms ) form = browser . select form ( soup . find ( " form " , { " id " : " b " } ) ) assert form . form [ ' id ' ] == " b " with pytest . raises ( mechanicalsoup . link not found error ) : browser . select form ( soup . find ( " p " ) )
httpbin , expected , kwargs browser = mechanicalsoup . stateful browser ( ) html = ' <a href= " /foo " > bar</a><a href= " /get " > link</a> ' browser . open fake page ( html , httpbin . url ) browser . follow link ( ** kwargs ) assert browser . url == httpbin + expectebin , expected , kwargs browser = mechanicalsoup . stateful browser ( ) html = ' <a href= " /foo " > bar</a><a href= " /get " > link</a> ' browser . open fake page ( html , httpbin . url ) browser . follow link ( ** kwargs ) assert browser . url == httpbin + expected
httpbin browser = mechanicalsoup . stateful browser ( ) open legacy httpbin ( browser , httpbin ) tmpdir = tempfile . mkdtemp ( ) tmpfile = tmpdir + ' /nosuchfile . png ' current url = browser . url current page = browser . page response = browser . download link ( file = tmpfile , link = ' image/png ' ) assert browser . url == current url assert browser . page == current page assert os . path . isfile ( tmpfile ) assert file get contents ( tmpfile ) == response . content assert response . content [ : 4 ] == b ' \\x89 png '
httpbin browser = mechanicalsoup . stateful browser ( ) open legacy httpbin ( browser , httpbin ) current url = browser . url current page = browser . page response = browser . download link ( link = ' image/png ' ) assert browser . url == current url assert browser . page == current page assert response . content [ : 4 ] == b ' \\x89 png '
httpbin browser = mechanicalsoup . stateful browser ( raise on 404 = true ) browser . open fake page ( ' <a href= " /no such page 404 " > link</a> ' , url = httpbin . url ) tmpdir = tempfile . mkdtemp ( ) tmpfile = tmpdir + ' /nosuchfile . txt ' current url = browser . url current page = browser . page with pytest . raises ( mechanicalsoup . link not found error ) : browser . download link ( file = tmpfile , link text = ' link ' ) assert browser . url == current url assert browser . page == current page assert not os . path . exists ( tmpfile )
httpbin browser = mechanicalsoup . stateful browser ( ) ref = httpbin + " /my referer " browser . open fake page ( ' <a href= " /headers " > link</a> ' , url = ref ) tmpfile = tempfile . named temporary file ( ) current url = browser . url current page = browser . page browser . download link ( file = tmpfile . name , link text = ' link ' ) assert browser . url == current url assert browser . page == current page with open ( tmpfile . name ) as f : json data = json . load ( f ) headers = json data [ " headers " ] assert headers [ " referer " ] == ref
def browser = mechanicalsoup . stateful browser ( ) with pytest . raises ( value error ) : browser . refresh ( ) with pytest . raises ( value error ) : browser . open fake page ( ' <p> fake empty page</p> ' , url = ' http://fake . com ' ) browser . refresh ( browser = mechanicalsoup . stateful browser ( ) with pytest . raises ( value error ) : browser . refresh ( ) with pytest . raises ( value error ) : browser . open fake page ( ' <p> fake empty page</p> ' , url = ' http://fake . com ' ) browser . refresh ( )
self , format string , args , kwargs result = super ( pdf formatter , self ) . vformat ( format string , args , kwargs ) return result . encode ( ' latin1 ' , format string , args , kwargs result = super ( pdf formatter , self ) . vformat ( format string , args , kwargs ) return result . encode ( ' latin1 ' )
self , key , pdf file parts = self . get value ( key , ' \\\\[( . +?)\\\\] ' ) . split ( b ' 0 r ' ) trail = parts . pop ( ) assert not trail . strip ( ) class = type ( self ) read = pdf file . read object return [ class ( n , read ( n ) ) for n in map ( int , parts ) ]
self , object number fileobj = self . fileobj fileobj . seek ( self . objects offsets [ object number ] ) line = next ( fileobj ) assert line . endswith ( b ' 0 obj\ ' ) assert int ( line [ : 7 ] ) == object number object lines = [ ] for line in fileobj : if line == b ' >>\ ' : assert next ( fileobj ) == b ' endobj\ ' # no newline , we\u2019ll add it when writing . object lines . append ( b ' >> ' ) return b ' ' . join ( object lines ) object lines . append ( line )
self , object number , byte string self . overwritten objects offsets [ object number ] = ( self . write object ( object number , byte string ) )
self , dictionary , new content assert dictionary . byte string . endswith ( b ' >> ' ) self . overwrite object ( dictionary . object number , dictionary . byte string [ : 2 ] + new content + b ' \>> ' )
self return len ( self . objects offsets ) + len ( self . new objects offsets )
self , byte string object number = self . next object number ( ) self . new objects offsets . append ( self . write object ( object number , byte string ) ) return object number
self , object number , byte string offset , write = self . start writing ( ) write ( pdf format ( ' {0} 0 obj\ ' , object number ) ) write ( byte string ) write ( b ' \endobj\ ' ) return offse , object number , byte string offset , write = self . start writing ( ) write ( pdf format ( ' {0} 0 obj\ ' , object number ) ) write ( byte string ) write ( b ' \endobj\ ' ) return offset
self assert not self . finished fileobj = self . fileobj fileobj . seek ( 0 , os . seek end ) return fileobj . tell ( ) , fileobj . writ assert not self . finished fileobj = self . fileobj fileobj . seek ( 0 , os . seek end ) return fileobj . tell ( ) , fileobj . write
pdf , attachments , url fetcher file spec ids = [ ] for attachment in attachments : file spec id = write pdf attachment ( pdf , attachment , url fetcher ) if file spec id is not none : file spec ids . append ( file spec id ) if len ( file spec ids ) == 0 : return none content = [ b ' << / names [ ' ] for fs in file spec ids : content . append ( pdf format ( ' \(attachment{0}) {0} 0 r ' , fs ) ) content . append ( b ' \] >> ' ) return pdf . write new object ( b ' ' . join ( content ) )
cls , page child contexts = [ cls . from box ( child , page ) for child in page . children ] page = page . copy with children ( [ ] ) return cls ( page , child contexts , [ ] , [ ] , [ ] , page , page child contexts = [ cls . from box ( child , page ) for child in page . children ] page = page . copy with children ( [ ] ) return cls ( page , child contexts , [ ] , [ ] , [ ] , page )
string r return string . encode ( ' utf8 ' ) . lower ( ) . decode ( ' utf8 ' )
element , link type return any ( ascii lower ( token ) == link type for token in html space separated tokens re . findall ( element . get ( ' rel ' , ' ' ) ) )
element , box , get image from uri , base url if box . element tag in html handlers : return html handlers [ element . tag ] ( element , box , get image from uri , base url ) else : return [ box ]
tag def decorator ( function ) : """ decorator registering a function handling ``tag`` elements . """ html handlers [ tag ] = function return function return decorator
element , box , image if box . style [ ' display ' ] in ( ' block ' , ' list item ' , ' table ' ) : type = boxes . block replaced box else : # todo: support images with ' display: table cell ' ? type = boxes . inline replaced box new box = type ( element . tag , box . style , image ) new box . string set = box . string set new box . bookmark label = box . bookmark label return new box
element , box , get image from uri , base url src = get url attribute ( element , ' src ' , base url ) type = element . get ( ' type ' , ' ' ) . strip ( ) if src : image = get image from uri ( src , type ) if image is not none : return [ make replaced box ( element , box , image ) ] return [ ]
element , box , get image from uri , base url data = get url attribute ( element , ' data ' , base url ) type = element . get ( ' type ' , ' ' ) . strip ( ) if data : image = get image from uri ( data , type ) if image is not none : return [ make replaced box ( element , box , image ) ] return [ box ]
element , box , name , minimum = 1 value = element . get ( name , ' ' ) . strip ( ) if value : try : value = int ( value ) except value error : pass else : if value >= minimum : setattr ( box , name , value )
element , box , get image from uri , base url if isinstance ( box , boxes . table column box ) : integer attribute ( element , box , ' span ' ) if box . span > 1 : # generate multiple boxes # http://lists . w3 . org/ archives/ public/www style/2011 nov/0293 . html return [ box . copy ( ) for i in range ( box . span ) ] return [ box ]
element , box , get image from uri , base url box . is attachment = element has link type ( element , ' attachment ' ) return [ box ]
html document , fallback base url first base element = next ( iter ( html document . iter ( ' base ' ) ) , none ) if first base element is not none : href = first base element . get ( ' href ' , ' ' ) . strip ( ) if href : return urljoin ( fallback base url , href ) return fallback base url
meta name , string if w3 c date re . match ( string ) : return string else : logger . warning ( ' invalid date in <meta name= " %s " > %r ' , meta name , string )
self , image resolution , font size return ( self . intrinsic width / image resolution , self . intrinsic height / image resolution , image resolution , font size return ( self . intrinsic width / image resolution , self . intrinsic height / image resolution )
self scale = super ( scaled svg surface , self ) . device units per user units return scale / 0 . 7 scale = super ( scaled svg surface , self ) . device units per user units return scale / 0 . 75
self , src , mimetype data = self . url fetcher ( src ) if ' string ' in data : return data [ ' string ' ] return data [ ' file obj ' ] . read ( , src , mimetype data = self . url fetcher ( src ) if ' string ' in data : return data [ ' string ' ] return data [ ' file obj ' ] . read ( )
positions first = positions [ 0 ] last = positions [ 1 ] total length = last first if total length != 0 : positions = [ ( pos first ) / total length for pos in positions ] else : positions = [ 0 for in positions ] return first , last , positions
self , image resolution , font size return none , non , image resolution , font size return none , none
self , width , height , user to device distance raise not implemented error
self return [ html5 ua stylesheet return [ html5 ua stylesheet ]
self return get html metadata ( self . wrapper element , self . base url return get html metadata ( self . wrapper element , self . base url )
self , stylesheets = none , enable hinting = false , presentational hints = false , font config = none return document . render ( self , stylesheets , enable hinting , presentational hints , font config )
self , stylesheets = none , resolution = 96 , presentational hints = false , font config = none surface , width , height = ( self . render ( stylesheets , enable hinting = true , presentational hints = presentational hints , font config = font config ) . write image surface ( resolution ) ) return surface
self , target = none , stylesheets = none , resolution = 96 , presentational hints = false , font config = none png bytes , width , height = ( self . render ( stylesheets , enable hinting = true , presentational hints = presentational hints , font config = font config ) . write png ( target , resolution ) ) return png bytes
context context . save ( ) try : yield finally : context . restore ( )
red , green , blue cmax = max ( red , green , blue ) cmin = min ( red , green , blue ) delta = cmax cmin if delta == 0 : hue = 0 elif cmax == red : hue = 60 * ( ( green blue ) / delta % 6 ) elif cmax == green : hue = 60 * ( ( blue red ) / delta + 2 ) elif cmax == blue : hue = 60 * ( ( red green ) / delta + 4 ) saturation = 0 if delta == 0 else delta / cmax return hue , saturation , cmax
color hue , saturation , value = rgb2hsv ( color . red , color . green , color . blue ) value /= 1 . 5 saturation /= 1 . 25 return hsv2rgb ( hue , saturation , value ) + ( color . alpha , )
color hue , saturation , value = rgb2hsv ( color . red , color . green , color . blue ) value = 1 ( 1 value ) / 1 . 5 if saturation : saturation = 1 ( 1 saturation ) / 1 . 25 return hsv2rgb ( hue , saturation , value ) + ( color . alpha , )
x , y , offset x , offset y , offset return x + offset x * offset , y + offset y * offset
context , box if box . style [ ' visibility ' ] != ' visible ' or not box . width or not box . height : return draw width , draw height , draw x , draw y = replaced . replacedbox layout ( box ) with stacked ( context ) : rounded box path ( context , box . rounded content box ( ) ) context . clip ( ) context . translate ( draw x , draw y ) box . replacement . draw ( context , draw width , draw height , box . style [ ' image rendering ' ] )
self gzip file . close ( self ) self . fileobj to close . close ( gzip file . close ( self ) self . fileobj to close . close ( )
data if isinstance ( data , bytes ) : data = data . decode ( ' utf8 ' ) return email . message from string ( data if isinstance ( data , bytes ) : data = data . decode ( ' utf8 ' ) return email . message from string ( data )
url return bool ( ( unicode scheme re if isinstance ( url , str ) else bytes scheme re ) . match ( url ) return bool ( ( unicode scheme re if isinstance ( url , str ) else bytes scheme re ) . match ( url ) )
element , attr name , base url , allow relative = false value = element . get ( attr name , ' ' ) . strip ( ) if value : return url join ( base url or ' ' , value , allow relative , ' <%s %s= " %s " > ' , ( element . tag , attr name , value ) )
string return string if url is absolute ( string ) else path2url ( string )
data missing padding = 4 len ( data ) % 4 if missing padding : data += b ' = ' * missing padding return decodebytes ( data )
self , pages = ' all ' if pages == ' all ' : pages = self . pages elif not isinstance ( pages , list ) : pages = list ( pages ) return type ( self ) ( pages , self . metadata , self . url fetcher , self . font config )
self , target = none , resolution = 96 surface , max width , sum heights = self . write image surface ( resolution ) if target is none : target = io . bytes io ( ) surface . write to png ( target ) png bytes = target . getvalue ( ) else : surface . write to png ( target ) png bytes = none return png bytes , max width , sum heights
ffi , * names for name in names : try : return ffi . dlopen ( name ) except os error : pass return ffi . dlopen ( names [ 0 ] )
string , slice return string . encode ( ' utf 8 ' ) [ slice ] . decode ( ' utf 8 ' ng , slice return string . encode ( ' utf 8 ' ) [ slice ] . decode ( ' utf 8 ' )
string bytestring = string . encode ( ' utf8 ' ) . replace ( b ' \\x00 ' , b ' ' ) return ffi . new ( ' char[] ' , bytestring ) , bytestring
line ink extents = ffi . new ( ' pango rectangle * ' ) pango . pango layout line get extents ( line , ink extents , ffi . null ) return ( units to double ( ink extents . x ) , units to double ( ink extents . y ) ink extents = ffi . new ( ' pango rectangle * ' ) pango . pango layout line get extents ( line , ink extents , ffi . null ) return ( units to double ( ink extents . x ) , units to double ( ink extents . y ) )
self context = pango . pango layout get context ( self . layout ) return font metrics ( context , self . font , self . language context = pango . pango layout get context ( self . layout ) return font metrics ( context , self . font , self . language )
self , wrap mode pango . pango layout set wrap ( self . layout , wrap mode , wrap mode pango . pango layout set wrap ( self . layout , wrap mode )
self del self . layout , self . font , self . language , self . styl del self . layout , self . font , self . language , self . style
self , style self . setup ( self . context , style [ ' font size ' ] , style ) self . set text ( self . text , justify = true , style self . setup ( self . context , style [ ' font size ' ] , style ) self . set text ( self . text , justify = true )
text , style , context , max width , justification spacing text wrap = style [ ' white space ' ] in ( ' normal ' , ' pre wrap ' , ' pre line ' ) if not text wrap : max width = none layout = layout ( context , style [ ' font size ' ] , style , justification spacing ) if max width is not none and max width < 2 ** 21 : pango . pango layout set width ( layout . layout , units from double ( max width ) ) layout . set text ( text ) return layout
text , lang if not text or len ( text ) < 2 : return none bytestring , log attrs = get log attrs ( text , lang ) length = len ( bytestring ) + 1 return any ( attr . is line break for attr in log attrs [ 1 : length 1 ] , lang if not text or len ( text ) < 2 : return none bytestring , log attrs = get log attrs ( text , lang ) length = len ( bytestring ) + 1 return any ( attr . is line break for attr in log attrs [ 1 : length 1 ] )
name , type = ' symbolic ' , ** descriptors if type == ' override ' : # todo: when @counter style rules are supported , change override # to bind when a value is generated , not when the @rule is parsed . style = dict ( styles [ descriptors . pop ( ' override ' ) ] ) else : style = dict ( initial values , formatter = functools . partial ( formatters [ type ] , descriptors . pop ( ' symbols ' ) , descriptors . pop ( ' negative ' , initial values [ ' negative ' ] ) ) ) style . update ( descriptors ) styles [ name ] = style
function formatters [ function . name . replace ( ' ' , ' ' ) ] = function return function
symbols , negative , value if value == 0 : return symbols [ 0 ] is negative = value < 0 if is negative : value = abs ( value ) prefix , suffix = negative reversed parts = [ suffix ] else : reversed parts = [ ] length = len ( symbols ) value = abs ( value ) while value != 0 : reversed parts . append ( symbols [ value % length ] ) value //= length if is negative : reversed parts . append ( prefix ) return ' ' . join ( reversed ( reversed parts ) )
symbols , negative , value if value <= 0 : return none length = len ( symbols ) reversed parts = [ ] while value != 0 : value = 1 reversed parts . append ( symbols [ value % length ] ) value //= length return ' ' . join ( reversed ( reversed parts ) )
symbols , negative , value if value <= 0 : return none length = len ( symbols ) return symbols [ value % length ] * ( ( value 1 ) // length )
symbols , negative , value first symbol value , symbols = symbols value = first symbol value if 0 <= value < len ( symbols ) : return symbols [ value ]
symbols , negative , value if value == 0 : for weight , symbol in symbols : if weight == 0 : return symbol is negative = value < 0 if is negative : value = abs ( value ) prefix , suffix = negative parts = [ prefix ] else : parts = [ ] for weight , symbol in symbols : repetitions = value // weight parts . extend ( [ symbol ] * repetitions ) value = weight * repetitions if value == 0 : if is negative : parts . append ( suffix ) return ' ' . join ( parts ) return none
value , counter style if counter style == ' none ' : return ' ' failed styles = set ( ) while true : if counter style == ' decimal ' or counter style in failed styles : return str ( value ) style = styles [ counter style ] low , high = style [ ' range ' ] if low <= value <= high : representation = style [ ' formatter ' ] ( value ) if representation is not none : return representation failed styles . add ( counter style ) counter style = style [ ' fallback ' ]
value , counter style style = styles [ counter style ] return style [ ' prefix ' ] + format ( value , counter style ) + style [ ' suffix ' ]
self return ( return ( )
cls , parent , * args , ** kwargs style = computed from cascaded ( cascaded = { } , parent style = parent . style , element = none ) return cls ( parent . element tag , style , * args , ** kwargs )
self cls = type ( self ) new box = cls . new ( cls ) new box . dict . update ( self . dict ) return new box
self return self . copy ( )
self , dx = 0 , dy = 0 , ignore floats = false if dx == 0 and dy == 0 : return self . position x += dx self . position y += dy for child in self . all children ( ) : if not ( ignore floats and child . is floated ( ) ) : child . translate ( dx , dy , ignore floats )
self return self . height + self . padding top + self . padding bottom
self return self . border width ( ) + self . margin left + self . margin right
self return self . border height ( ) + self . margin top + self . margin bottom
self return self . position x + self . margin left + self . padding left + self . border left width
self return self . position y + self . margin top + self . padding top + self . border top width
self return self . position x + self . margin left + self . border left width
self return self . position y + self . margin top + self . border top width
self return self . position x + self . margin left
self return self . position y + self . margin top
self return self . rounded box ( self . border top width , self . border right width , self . border bottom width , self . border left width )
self return self . rounded box ( 0 , 0 , 0 , 0 )
self return self . rounded box ( self . border top width + self . padding top , self . border right width + self . padding right , self . border bottom width + self . padding bottom , self . border left width + self . padding left )
self return self . style [ ' float ' ] != ' none '
self return self . style [ ' position ' ] in ( ' absolute ' , ' fixed ' )
self return self . style [ ' position ' ] [ 0 ] == ' running() '
self return not ( self . is floated ( ) or self . is absolutely positioned ( ) or self . is running ( ) )
self return self . childre return self . children
self , new children , is start = true , is end = true new box = self . copy ( ) new box . children = tuple ( new children ) if self . style [ ' box decoration break ' ] == ' slice ' : new box . remove decoration ( not is start , not is end ) return new box
self result = self . copy ( ) result . children = tuple ( child . deepcopy ( ) for child in self . children ) return resul result = self . copy ( ) result . children = tuple ( child . deepcopy ( ) for child in self . children ) return result
self yield self for child in self . children : if hasattr ( child , ' descendants ' ) : for grand child in child . descendants ( ) : yield grand child else : yield child
self if self . is table wrapper : for child in self . children : if isinstance ( child , table box ) : return child else : # pragma: no cover raise value error ( ' table wrapper without a table ' )
cls , parent , * args , ** kwargs box = super ( ) . anonymous from ( parent , * args , ** kwargs ) if parent . style [ ' overflow ' ] != ' visible ' : box . text overflow = parent . style [ ' text overflow ' ] return bo , parent , * args , ** kwargs box = super ( ) . anonymous from ( parent , * args , ** kwargs ) if parent . style [ ' overflow ' ] != ' visible ' : box . text overflow = parent . style [ ' text overflow ' ] return box
self return ( self . border box x ( ) , self . position y , self . border width ( ) , self . margin height ( ) )
self , text assert text new box = self . copy ( ) new box . text = text return new box
self return itertools . chain ( self . children , self . column groups return itertools . chain ( self . children , self . column groups )
self , dx = 0 , dy = 0 , ignore floats = false if dx == 0 and dy == 0 : return self . column positions = [ position + dx for position in self . column positions ] return super ( table box , self ) . translate ( dx , dy , ignore floats , dx = 0 , dy = 0 , ignore floats = false if dx == 0 and dy == 0 : return self . column positions = [ position + dx for position in self . column positions ] return super ( table box , self ) . translate ( dx , dy , ignore floats )
self return ( self . style [ ' page ' ] , self . style [ ' page ' ] return ( self . style [ ' page ' ] , self . style [ ' page ' ] )
self return [ cell for column in self . children for cell in column . get cells ( ) ]
element tag , style , content return box type from display [ style [ ' display ' ] ] ( element tag , style , content ent tag , style , content return box type from display [ style [ ' display ' ] ] ( element tag , style , content )
counter name , counter values , missing counters if counter name not in list ( counter values ) + missing counters : missing counters . append ( counter name )
element , box , style , counter values , target collector box . string set = [ ] if style [ ' string set ' ] != ' none ' : for i , ( string name , string values ) in enumerate ( style [ ' string set ' ] ) : compute string set ( element , box , string name , string values , counter values , target collector ) if style [ ' bookmark label ' ] == ' none ' : box . bookmark label = ' ' else : compute bookmark label ( element , box , style [ ' bookmark label ' ] , counter values , target collector )
box if not isinstance ( box , boxes . parent box ) : return box children = [ anonymous table boxes ( child ) for child in box . children ] return table boxes children ( box , children )
box if not isinstance ( box , boxes . parent box ) : return box children = [ flex boxes ( child ) for child in box . children ] box . children = flex children ( box , children ) return box
root box chosen box = root box if ( root box . element tag . lower ( ) == ' html ' and root box . style [ ' overflow ' ] == ' visible ' ) : for child in root box . children : if child . element tag . lower ( ) == ' body ' : chosen box = child break root box . viewport overflow = chosen box . style [ ' overflow ' ] chosen box . style [ ' overflow ' ] = ' visible ' return root box
box if isinstance ( box , boxes . parent box ) : return ' ' . join ( box text ( child ) for child in box . descendants ( ) if child . element tag . endswith ( ' ::before ' ) and not isinstance ( child , boxes . parent box ) ) else : return ' 'if isinstance ( box , boxes . parent box ) : return ' ' . join ( box text ( child ) for child in box . descendants ( ) if child . element tag . endswith ( ' ::before ' ) and not isinstance ( child , boxes . parent box ) ) else : return ' '
box if isinstance ( box , boxes . parent box ) : return ' ' . join ( box text ( child ) for child in box . descendants ( ) if child . element tag . endswith ( ' ::after ' ) and not isinstance ( child , boxes . parent box ) ) else : return ' 'if isinstance ( box , boxes . parent box ) : return ' ' . join ( box text ( child ) for child in box . descendants ( ) if child . element tag . endswith ( ' ::after ' ) and not isinstance ( child , boxes . parent box ) ) else : return ' '
context , box , function , outer width = box . style [ ' width ' ] if width == ' auto ' or width . unit == ' % ' : # " percentages on the following properties are treated instead as # though they were the following: width: auto " # http://dbaron . org/css/intrinsic/#outer intrinsic children widths = [ function ( context , child , outer = true ) for child in box . children if not child . is absolutely positioned ( ) ] width = max ( children widths ) if children widths else 0 else : assert width . unit == ' px ' width = width . value return adjust ( box , outer , width )
box , width min width = box . style [ ' min width ' ] max width = box . style [ ' max width ' ] if min width == ' auto ' or min width . unit == ' % ' : min width = 0 else : min width = min width . value if max width == ' auto ' or max width . unit == ' % ' : max width = float ( ' inf ' ) else : max width = max width . value return max ( min width , min ( width , max width ) )
box , outer , width , left = true , right = true fixed = min max ( box , width ) if outer : return margin width ( box , fixed , left , right ) else : return fixed
context , box , outer = true return block content width ( context , box , min content width , outer )
context , box , outer = true return block content width ( context , box , max content width , outer )
context , box , outer = true , skip stack = none , first line = false , is line start = false widths = inline line widths ( context , box , outer , is line start , minimum = true , skip stack = skip stack , first line = first line ) if first line : widths = [ next ( widths ) ] else : widths = list ( widths ) widths [ 1 ] = trailing whitespace size ( context , box ) return adjust ( box , outer , max ( widths ) )
context , box , outer = true , is line start = false widths = list ( inline line widths ( context , box , outer , is line start , minimum = false ) ) widths [ 1 ] = trailing whitespace size ( context , box ) return adjust ( box , outer , max ( widths ) )
context , box width = box . style [ ' width ' ] if width == ' auto ' or width . unit == ' % ' : width = 0 else : assert width . unit == ' px ' width = width . value return adjust ( box , false , width )
context , box , outer return max ( table cell min content width ( context , box , outer ) , block max content width ( context , box , outer ) )
context , box , outer = true min contents = [ min content width ( context , child , outer = true ) for child in box . children if child . is flex item ] if not min contents : return adjust ( box , outer , 0 ) if ( box . style [ ' flex direction ' ] . startswith ( ' row ' ) and box . style [ ' flex wrap ' ] == ' nowrap ' ) : return adjust ( box , outer , sum ( min contents ) ) else : return adjust ( box , outer , max ( min contents ) )
context , box , outer = true max contents = [ max content width ( context , child , outer = true ) for child in box . children if child . is flex item ] if not max contents : return adjust ( box , outer , 0 ) if box . style [ ' flex direction ' ] . startswith ( ' row ' ) : return adjust ( box , outer , sum ( max contents ) ) else : return adjust ( box , outer , max ( max contents ) )
constraint width , constraint height , intrinsic ratio return constraint image sizing ( constraint width , constraint height , intrinsic ratio , cover = false )
constraint width , constraint height , intrinsic ratio return constraint image sizing ( constraint width , constraint height , intrinsic ratio , cover = true )
constraint width , constraint height , intrinsic ratio , cover if intrinsic ratio is none : return constraint width , constraint height elif cover ^ ( constraint width > constraint height * intrinsic ratio ) : return constraint height * intrinsic ratio , constraint height else : return constraint width , constraint width / intrinsic ratitraint width , constraint height , intrinsic ratio , cover if intrinsic ratio is none : return constraint width , constraint height elif cover ^ ( constraint width > constraint height * intrinsic ratio ) : return constraint height * intrinsic ratio , constraint height else : return constraint width , constraint width / intrinsic ratio
box , context , containing block if box . width == ' auto ' : box . width = shrink to fit ( context , box , containing block . width , context , containing block if box . width == ' auto ' : box . width = shrink to fit ( context , box , containing block . width )
context , box , collapsed margin = 0 clearance = none hypothetical position = box . position y + collapsed margin for excluded shape in context . excluded shapes : if box . style [ ' clear ' ] in ( excluded shape . style [ ' float ' ] , ' both ' ) : y , h = excluded shape . position y , excluded shape . margin height ( ) if hypothetical position < y + h : clearance = max ( ( clearance or 0 ) , y + h hypothetical position ) return clearance
self return self . sugar + self . inne return self . sugar + self . inner
self return self . sugar + ( self . min content size if self . inner == ' auto ' else self . inner return self . sugar + ( self . min content size if self . inner == ' auto ' else self . inner )
self return self . sugar + ( self . max content size if self . inner == ' auto ' else self . inner return self . sugar + ( self . max content size if self . inner == ' auto ' else self . inner )
self , available self . inner = min ( max ( self . min content size , available ) , self . max content size , available self . inner = min ( max ( self . min content size , available ) , self . max content size )
self box = self . box box . height = self . inner box . margin top = self . margin a box . margin bottom = self . margin box = self . box box . height = self . inner box . margin top = self . margin a box . margin bottom = self . margin b
self return 1e return 1e6
self box = self . box box . width = self . inner box . margin left = self . margin a box . margin right = self . margin box = self . box box . width = self . inner box . margin left = self . margin a box . margin right = self . margin b
self if self . max content size is none : self . max content size = max content width ( self . context , self . box , outer = false ) return self . max content siz if self . max content size is none : self . max content size = max content width ( self . context , self . box , outer = false ) return self . max content size
box , context , containing block width page width or height ( horizontal box ( context , box ) , containing block width , context , containing block width page width or height ( horizontal box ( context , box ) , containing block width )
box , context , containing block height page width or height ( vertical box ( context , box ) , containing block height , context , containing block height page width or height ( vertical box ( context , box ) , containing block height )
box if box . is table wrapper : # inline table ' s baseline is its first row ' s baseline for child in box . children : if isinstance ( child , boxes . table box ) : if child . children and child . children [ 0 ] . children : first row = child . children [ 0 ] . children [ 0 ] return first row . baseline elif box . style [ ' overflow ' ] == ' visible ' : result = find in flow baseline ( box , last = true ) if result : return result return box . position y + box . margin height ( )
box , context , containing block if box . width == ' auto ' : box . width = shrink to fit ( context , box , containing block . width , context , containing block if box . width == ' auto ' : box . width = shrink to fit ( context , box , containing block . width )
context , line , extra width nb spaces = count spaces ( line ) if nb spaces == 0 : return add word spacing ( context , line , extra width / nb spaces , 0 ext , line , extra width nb spaces = count spaces ( line ) if nb spaces == 0 : return add word spacing ( context , line , extra width / nb spaces , 0 )
box if isinstance ( box , boxes . text box ) : # todo: remove trailing spaces correctly return box . text . count ( ' ' ) elif isinstance ( box , ( boxes . line box , boxes . inline box ) ) : return sum ( count spaces ( child ) for child in box . children ) else : return if isinstance ( box , boxes . text box ) : # todo: remove trailing spaces correctly return box . text . count ( ' ' ) elif isinstance ( box , ( boxes . line box , boxes . inline box ) ) : return sum ( count spaces ( child ) for child in box . children ) else : return 0
linebox for child in linebox . children : if isinstance ( child , boxes . inline box ) : if not is phantom linebox ( child ) : return false for side in ( ' top ' , ' right ' , ' bottom ' , ' left ' ) : if ( getattr ( child . style [ ' margin %s ' % side ] , ' value ' , none ) or child . style [ ' border %s width ' % side ] or child . style [ ' padding %s ' % side ] . value ) : return false elif child . is in normal flow ( ) : return false return true
box , containing block box = box . copy ( ) if box . style [ ' width ' ] == ' auto ' and box . style [ ' height ' ] == ' auto ' : computed margins = box . margin left , box . margin right block replaced width . without min max ( box , containing block ) replaced box height . without min max ( box ) min max auto replaced ( box ) box . margin left , box . margin right = computed margins block level width . without min max ( box , containing block ) else : block replaced width ( box , containing block ) replaced box height ( box ) return box
adjoining margins margins = [ 0 ] margins . extend ( adjoining margins ) positives = ( m for m in margins if m >= 0 ) negatives = ( m for m in margins if m <= 0 ) return max ( positives ) + min ( negatives )
box return ( box . is floated ( ) ) or ( box . is absolutely positioned ( ) ) or ( # todo: columns shouldn ' t be block boxes , this condition would then be # useless when this is fixed box . is column ) or ( isinstance ( box , boxes . block container box ) and not isinstance ( box , boxes . block box ) ) or ( isinstance ( box , boxes . block box ) and box . style [ ' overflow ' ] != ' visible ' )
sibling before , sibling after before page = sibling before . page values ( ) [ 1 ] after page = sibling after . page values ( ) [ 0 ] if before page != after page : return after page
box list , absolute boxes , fixed boxes for box in box list : if isinstance ( box , boxes . parent box ) : remove placeholders ( box . children , absolute boxes , fixed boxes ) if box . style [ ' position ' ] == ' absolute ' and box in absolute boxes : # box is not in absolute boxes if its parent has position: relative absolute boxes . remove ( box ) elif box . style [ ' position ' ] == ' fixed ' : fixed boxes . remove ( box )
box , extra padding box . padding top += extra padding for child in box . children : child . translate ( dy = extra padding )
context , wrapper , containing block table = wrapper . get wrapped table ( ) resolve percentages ( table , containing block ) if table . style [ ' table layout ' ] == ' fixed ' and table . width != ' auto ' : fixed table layout ( wrapper ) else : auto table layout ( context , wrapper , containing block ) wrapper . width = table . border width ( )
cell result = find in flow baseline ( cell , baseline types = ( boxes . line box , boxes . table row box ) ) if result is not none : return result cell . position y else : # default to the bottom of the content area . return cell . border top width + cell . padding top + cell . height
box , last = false , baseline types = ( boxes . line box , ) if isinstance ( box , baseline types ) : return box . position y + box . baseline if isinstance ( box , boxes . parent box ) and not isinstance ( box , boxes . table caption box ) : children = reversed ( box . children ) if last else box . children for child in children : if child . is in normal flow ( ) : result = find in flow baseline ( child , last , baseline types ) if result is not none : return result
page , get image from uri layout box backgrounds ( page , page , get image from uri ) set canvas background ( page , get image from uri layout box backgrounds ( page , page , get image from uri ) set canvas background ( page )
self , new box object . setattr ( self , ' box ' , new box ) object . setattr ( self , ' layout done ' , true , new box object . setattr ( self , ' box ' , new box ) object . setattr ( self , ' layout done ' , true )
self new placeholder = absolute placeholder ( self . box . copy ( ) ) object . setattr ( new placeholder , ' layout done ' , self . layout done ) return new placeholde new placeholder = absolute placeholder ( self . box . copy ( ) ) object . setattr ( new placeholder , ' layout done ' , self . layout done ) return new placeholder
context , placeholder , containing block , fixed boxes assert not placeholder . layout done box = placeholder . box placeholder . set laid out box ( absolute box layout ( context , box , containing block , fixed boxes ) )
function @ functools . wraps ( function ) def wrapper ( box , * args ) : computed margins = box . margin left , box . margin right result = function ( box , * args ) if box . width > box . max width : box . width = box . max width box . margin left , box . margin right = computed margins result = function ( box , * args ) if box . width < box . min width : box . width = box . min width box . margin left , box . margin right = computed margins result = function ( box , * args ) return result wrapper . without min max = function return wrapper
function @ functools . wraps ( function ) def wrapper ( box , * args ) : computed margins = box . margin top , box . margin bottom result = function ( box , * args ) if box . height > box . max height : box . height = box . max height box . margin top , box . margin bottom = computed margins result = function ( box , * args ) if box . height < box . min height : box . height = box . min height box . margin top , box . margin bottom = computed margins result = function ( box , * args ) return result wrapper . without min max = function return wrapper
value , refer to if value is none or value == ' auto ' : return value elif value . unit == ' px ' : return value . value else : assert value . unit == ' % ' return refer to * value . value / 100 .
box , containing block cb width , cb height = containing block resolve one percentage ( box , ' left ' , cb width ) resolve one percentage ( box , ' right ' , cb width ) resolve one percentage ( box , ' top ' , cb height ) resolve one percentage ( box , ' bottom ' , cb height , containing block cb width , cb height = containing block resolve one percentage ( box , ' left ' , cb width ) resolve one percentage ( box , ' right ' , cb width ) resolve one percentage ( box , ' top ' , cb height ) resolve one percentage ( box , ' bottom ' , cb height )
url , query string = none if url : if query string : url += ' ? ' + query string if not url is absolute ( url ) : # default to http rather than relative filenames url = ' http:// ' + url return ur , query string = none if url : if query string : url += ' ? ' + query string if not url is absolute ( url ) : # default to http rather than relative filenames url = ' http:// ' + url return url
port = 5000 host = ' 127 . 0 . 0 . 1 ' server = make server ( host , port , app ) print ( ' listening on http://%s:%s/ . . . ' % ( host , port ) ) server . serve forever ( = 5000 host = ' 127 . 0 . 0 . 1 ' server = make server ( host , port , app ) print ( ' listening on http://%s:%s/ . . . ' % ( host , port ) ) server . serve forever ( )
port = 5000 host = ' 127 . 0 . 0 . 1 ' server = make server ( host , port , app ) print ( ' listening on http://%s:%s/ . . . ' % ( host , port ) ) server . serve forever ( = 5000 host = ' 127 . 0 . 0 . 1 ' server = make server ( host , port , app ) print ( ' listening on http://%s:%s/ . . . ' % ( host , port ) ) server . serve forever ( )
name name = name . replace ( ' ' , ' ' ) def decorator ( function ) : """ register the property ``name`` for ``function`` . """ computer functions [ name ] = function return function return decorator
computer , name , values return tuple ( ( origin x , length ( computer , name , pos x ) , origin y , length ( computer , name , pos y ) ) for origin x , pos x , origin y , pos y in values )
computer , name , values return tuple ( length ( computer , name , value ) for value in values )
computer , name , value if value == ' always ' : return ' page ' else : return value
computer , name , value if value == ' auto ' : if ' crop ' in computer [ ' computed ' ] [ ' marks ' ] : return dimension ( 8 , ' px ' ) # 6pt else : return dimension ( 0 , ' px ' ) else : return length ( computer , name , value uter , name , value if value == ' auto ' : if ' crop ' in computer [ ' computed ' ] [ ' marks ' ] : return dimension ( 8 , ' px ' ) # 6pt else : return dimension ( 0 , ' px ' ) else : return length ( computer , name , value )
computer , name , value if value == ' normal ' : return value else : return length ( computer , name , value , pixels only = true uter , name , value if value == ' normal ' : return value else : return length ( computer , name , value , pixels only = true )
computer , name , values return tuple ( value if value in ( ' contain ' , ' cover ' ) else length or percentage tuple ( computer , name , value ) for value in values )
computer , name , value style = computer [ ' computed ' ] [ name . replace ( ' width ' , ' style ' ) ] if style in ( ' none ' , ' hidden ' ) : return 0 if value in border width keywords : return border width keywords [ value ] if isinstance ( value , int ) : # the initial value can get here , but length() would fail as # it does not have a ' unit ' attribute . return value return length ( computer , name , value , pixels only = true )
computer , name , value return length ( computer , name , value , pixels only = true )
computer , name , values return tuple ( length ( computer , name , value ) for value in values )
computer , name , value if value == ' normal ' : value = dimension ( 1 , ' em ' ) return length ( computer , name , value , pixels only = true )
computer , name , values return content list ( computer , values )
computer , name , values return tuple ( ( string set [ 0 ] , content list ( computer , string set [ 1 ] ) ) for string set in values )
computer , name , values if len ( values ) == 1 : value , = values if value == ' normal ' : return ' inhibit ' if computer [ ' pseudo type ' ] else ' contents ' elif value == ' none ' : return ' inhibit ' return content list ( computer , values )
computer , name , value if computer [ ' specified ' ] [ ' position ' ] in ( ' absolute ' , ' fixed ' ) : return ' none ' else : return value
computer , name , value if value == ' normal ' : return value elif not value . unit : return ( ' number ' , value . value ) elif value . unit == ' % ' : factor = value . value / 100 . font size value = computer [ ' computed ' ] [ ' font size ' ] pixels = factor * font size value else : pixels = length ( computer , name , value , pixels only = true ) return ( ' pixels ' , pixels )
computer , name , values if values == ' none ' : return none else : type , value = values if type == ' attr() ' : return get link attribute ( computer [ ' element ' ] , value , computer [ ' base url ' ] ) else : return values
computer , name , value if isinstance ( value , int ) : return value else : return length ( computer , name , value )
computer , name , value if value == ' normal ' : return 0 else : return length ( computer , name , value , pixels only = true )
style font size = 1000 layout = text . layout ( context = none , font size = font size , style = style ) layout . set text ( ' x ' ) line , = layout . get first line ( ) , ink height above baseline = text . get ink position ( line ) return round ( ink height above baseline / font size , 5 ) or 0 . 5
tokens parts = [ ] this part = [ ] for token in tokens : if token . type == ' literal ' and token . value == ' , ' : parts . append ( this part ) this part = [ ] else : this part . append ( token ) parts . append ( this part ) return tuple ( parts )
tokens return tuple ( token for token in tokens if token . type not in ( ' whitespace ' , ' comment ' ) )
base url , url if url is absolute ( url ) : return iri to uri ( url ) elif base url : return iri to uri ( urljoin ( base url , url ) ) else : raise invalid values ( ' relative uri reference without a base uri: %r ' % url url , url if url is absolute ( url ) : return iri to uri ( url ) elif base url : return iri to uri ( urljoin ( base url , url ) ) else : raise invalid values ( ' relative uri reference without a base uri: %r ' % url )
function @ functools . wraps ( function ) def wrapper ( tokens , * args ) : results = [ ] for part in split on comma ( tokens ) : result = function ( remove whitespace ( part ) , * args ) if result is none : return none results . append ( result ) return tuple ( results ) wrapper . single value = function return wrapper
token if token . type == ' ident ' : return token . lower value
token if token . type == ' ident ' : return token . value
tokens if len ( tokens ) == 1 : token = tokens [ 0 ] if token . type == ' ident ' : return token . lower value
function @ functools . wraps ( function ) def keyword validator ( tokens ) : """ wrap a validator to call get single keyword on tokens . """ keyword = get single keyword ( tokens ) if function ( keyword ) : return keyword return keyword validator
function @ functools . wraps ( function ) def single token validator ( tokens , * args ) : """ validate a property whose token is single . """ if len ( tokens ) == 1 : return function ( tokens [ 0 ] , * args ) single token validator . func = function return single token validator
token if token . type == ' string ' : return ( ' string ' , token . value ) if token . type == ' function ' : if token . name == ' attr ' : return check attr function ( token , ' string ' ) elif token . name in ( ' counter ' , ' counters ' ) : return check counter function ( token ) elif token . name == ' content ' : return check content function ( token ) elif token . name == ' string ' : return check string function ( token )
token , negative = true , percentage = false if percentage and token . type == ' percentage ' : if negative or token . value >= 0 : return dimension ( token . value , ' % ' ) if token . type == ' dimension ' and token . unit in length units : if negative or token . value >= 0 : return dimension ( token . value , token . unit ) if token . type == ' number ' and token . value == 0 : return dimension ( 0 , none )
token if token . type == ' dimension ' : factor = resolution to dppx . get ( token . unit ) if factor is not none : return token . value * factor
token , base url if token . type == ' url ' : if token . value . startswith ( ' # ' ) : return ( ' url ' , ( ' internal ' , unquote ( token . value [ 1 : ] ) ) ) else : return ( ' url ' , ( ' external ' , safe urljoin ( base url , token . value ) ) ) elif token . type == ' function ' : if token . name == ' attr ' : return check attr function ( token , ' url ' )
query list , device media type return ' all ' in query list or device media type in query list
self return self . cascaded style return self . cascaded styles
element content = [ element . text ] if element . text else [ ] for child in element : if child . tail : content . append ( child . tail ) return ' ' . join ( content )
self , anchor token if anchor token [ 0 ] == ' string ' and anchor token [ 1 ] . startswith ( ' # ' ) : return anchor token [ 1 ] [ 1 : ] elif anchor token [ 0 ] == ' url ' and anchor token [ 1 ] [ 0 ] == ' internal ' : return anchor token [ 1 ] [ 1 ]
self , anchor name if anchor name and isinstance ( anchor name , str ) : if anchor name in self . existing anchors : logger . warning ( ' anchor defined twice: %s ' , anchor name ) else : self . existing anchors . append ( anchor name )
self , anchor token anchor name = self . anchor name from token ( anchor token ) if anchor name : self . target lookup items . setdefault ( anchor name , target lookup item ( ) )
self , parent box , css token , parse again function , missing counters , missing target counters if not self . collecting : return if missing counters or missing target counters : # todo: remove attribute or set a default value in box class if not hasattr ( parent box , ' missing link ' ) : parent box . missing link = parent box counter lookup item = counter lookup item ( parse again function , missing counters , missing target counters ) self . counter lookup items . setdefault ( ( parent box , css token ) , counter lookup item )
self if self . had pending targets : for item in self . target lookup items . values ( ) : for function in item . parse again functions . values ( ) : function ( ) self . had pending targets = false self . collecting = false
property name = none , proprietary = false , unstable = false , wants base url = false def decorator ( function ) : """ add ``function`` to the `` properties`` . """ if property name is none : name = function . name . replace ( ' ' , ' ' ) else : name = property name assert name in known properties , name assert name not in properties , name function . wants base url = wants base url properties [ name ] = function if proprietary : proprietary . add ( name ) if unstable : unstable . add ( name ) return function return decorator
keyword return keyword in ( ' scroll ' , ' fixed ' , ' local ' )
token if get keyword ( token ) == ' invert ' : return ' current color ' else : return parse color ( token n if get keyword ( token ) == ' invert ' : return ' current color ' else : return parse color ( token )
keyword return keyword in ( ' separate ' , ' collapse ' ord return keyword in ( ' separate ' , ' collapse ' )
keyword return keyword in ( ' show ' , ' hide ' )
tokens if len ( tokens ) == 3 : # ignore third parameter as 3 d transforms are ignored . tokens = tokens [ : 2 ] return parse 2d position ( tokens )
tokens return parse position ( tokens )
tokens return parse position ( tokens )
tokens lengths = [ get length ( token , negative = false ) for token in tokens ] if all ( lengths ) : if len ( lengths ) == 1 : return ( lengths [ 0 ] , lengths [ 0 ] ) elif len ( lengths ) == 2 : return tuple ( lengths )
tokens lengths = [ get length ( token , negative = false , percentage = true ) for token in tokens ] if all ( lengths ) : if len ( lengths ) == 1 : return ( lengths [ 0 ] , lengths [ 0 ] ) elif len ( lengths ) == 2 : return tuple ( lengths )
keyword return keyword in ( ' none ' , ' hidden ' , ' dotted ' , ' dashed ' , ' double ' , ' inset ' , ' outset ' , ' groove ' , ' ridge ' , ' solid ' )
keyword return keyword in ( ' auto ' , ' avoid ' , ' avoid page ' , ' page ' , ' left ' , ' right ' , ' recto ' , ' verso ' , ' avoid column ' , ' column ' , ' always ' )
keyword return keyword in ( ' auto ' , ' avoid ' , ' avoid page ' , ' avoid column ' )
keyword return keyword in ( ' slice ' , ' clone ' )
tokens if len ( tokens ) == 2 : keywords = tuple ( get keyword ( token ) for token in tokens ) if ' crop ' in keywords and ' cross ' in keywords : return keywords elif len ( tokens ) == 1 : keyword = get keyword ( tokens [ 0 ] ) if keyword in ( ' crop ' , ' cross ' ) : return ( keyword , ) elif keyword == ' none ' : return ( )
keyword return keyword in ( ' none ' , ' dotted ' , ' dashed ' , ' double ' , ' inset ' , ' outset ' , ' groove ' , ' ridge ' , ' solid ' )
token length = get length ( token , negative = false ) if length : return length keyword = get keyword ( token ) if keyword in ( ' thin ' , ' medium ' , ' thick ' ) : return keyword
token length = get length ( token , negative = false ) if length : return length keyword = get keyword ( token ) if keyword == ' auto ' : return keyword
keyword return keyword in ( ' all ' , ' none ' )
keyword return keyword in ( ' padding box ' , ' border box ' , ' content box ' )
keyword return keyword in ( ' top ' , ' bottom ' )
keyword return keyword in ( ' left ' , ' right ' , ' both ' , ' none ' )
token function = parse function ( token ) if function : name , args = function if name == ' rect ' and len ( args ) == 4 : values = [ ] for arg in args : if get keyword ( arg ) == ' auto ' : values . append ( ' auto ' ) else : length = get length ( arg ) if length : values . append ( length ) if len ( values ) == 4 : return tuple ( values ) if get keyword ( token ) == ' auto ' : return ( )
tokens return counter ( tokens , default integer = 1 )
tokens return counter ( tokens , default integer = 0 )
token length = get length ( token , negative = false , percentage = true ) if length : return length if get keyword ( token ) == ' auto ' : return ' auto '
token length = get length ( token , negative = false ) if length : return length keyword = get keyword ( token ) if keyword == ' normal ' : return keyword
keyword return keyword in ( ' auto ' , ' balance ' )
keyword return keyword in ( ' ltr ' , ' rtl ' )
keyword return keyword in ( ' auto ' , ' normal ' , ' none ' ord return keyword in ( ' auto ' , ' normal ' , ' none ' )
token keyword = get keyword ( token ) if keyword == ' normal ' : return keyword elif token . type == ' string ' : return token . valun keyword = get keyword ( token ) if keyword == ' normal ' : return keyword elif token . type == ' string ' : return token . value
keyword return keyword in ( ' normal ' , ' sub ' , ' super ' ord return keyword in ( ' normal ' , ' sub ' , ' super ' )
keyword return keyword in ( ' normal ' , ' small caps ' , ' all small caps ' , ' petite caps ' , ' all petite caps ' , ' unicase ' , ' titling caps ' ord return keyword in ( ' normal ' , ' small caps ' , ' all small caps ' , ' petite caps ' , ' all petite caps ' , ' unicase ' , ' titling caps ' )
token length = get length ( token , negative = false , percentage = true ) if length : return length font size keyword = get keyword ( token ) if font size keyword in ( ' smaller ' , ' larger ' ) : return font size keyword if font size keyword in computed values . font size keywords : return font size keyword
keyword return keyword in ( ' normal ' , ' italic ' , ' oblique ' )
keyword return keyword in ( ' ultra condensed ' , ' extra condensed ' , ' condensed ' , ' semi condensed ' , ' normal ' , ' semi expanded ' , ' expanded ' , ' extra expanded ' , ' ultra expanded ' )
keyword return keyword in ( ' fill ' , ' contain ' , ' cover ' , ' none ' , ' scale down ' ord return keyword in ( ' fill ' , ' contain ' , ' cover ' , ' none ' , ' scale down ' )
token return get resolution ( token n return get resolution ( token )
token if get keyword ( token ) == ' normal ' : return ' normal ' length = get length ( token ) if length : return length
keyword return keyword in ( ' inside ' , ' outside ' )
keyword return keyword == ' none ' or keyword in counters . styles
token keyword = get keyword ( token ) if keyword == ' auto ' : return keyword else : return length or precentage ( [ token ] )
token length = get length ( token , negative = false , percentage = true ) if length : return length
token if token . type == ' number ' : return min ( 1 , max ( 0 , token . value ) )
token if token . type == ' number ' and token . int value is not none : value = token . int value if value >= 1 : return value
token if token . type == ' number ' and token . int value is not none : value = token . int value if value >= 1 : return value if get keyword ( token ) == ' auto ' : return ' auto '
keyword return keyword in ( ' clip ' , ' ellipsis ' )
token if token . type == ' function ' and token . name == ' running ' : if len ( token . arguments ) == 1 and token . arguments [ 0 ] . type == ' ident ' : return ( ' running() ' , token . arguments [ 0 ] . value ) keyword = get single keyword ( [ token ] ) if keyword in ( ' static ' , ' relative ' , ' absolute ' , ' fixed ' ) : return keyword
tokens if ( tokens and len ( tokens ) % 2 == 0 and all ( token . type == ' string ' for token in tokens ) ) : strings = tuple ( token . value for token in tokens ) # separate open and close quotes . # eg . ( ' \u00ab ' , ' \u00bb ' , ' \u201c ' , ' \u201d ' ) > (( ' \u00ab ' , ' \u201c ' ) , ( ' \u00bb ' , ' \u201d ' )) return strings [ : : 2 ] , strings [ 1 : : 2 ]
keyword if keyword in ( ' fixed ' , ' auto ' ) : return keyword
keyword return keyword in ( ' left ' , ' right ' , ' center ' , ' justify ' )
tokens keywords = { get keyword ( token ) for token in tokens } if keywords == { ' none ' } : return ' none ' allowed values = { ' underline ' , ' overline ' , ' line through ' , ' blink ' } if len ( tokens ) == len ( keywords ) and keywords . issubset ( allowed values ) : return keywords
token length = get length ( token , percentage = true ) if length : return length
keyword return keyword in ( ' none ' , ' uppercase ' , ' lowercase ' , ' capitalize ' , ' full width ' )
token length = get length ( token , percentage = true ) if length : return length keyword = get keyword ( token ) if keyword in ( ' baseline ' , ' middle ' , ' sub ' , ' super ' , ' text top ' , ' text bottom ' , ' top ' , ' bottom ' ) : return keyword
keyword return keyword in ( ' visible ' , ' hidden ' , ' collapse ' )
keyword return keyword in ( ' normal ' , ' pre ' , ' nowrap ' , ' pre wrap ' , ' pre line ' )
keyword return keyword in ( ' normal ' , ' break word ' )
token basis = width height ( [ token ] ) if basis is not none : return basis if get keyword ( token ) == ' content ' : return ' content '
keyword return keyword in ( ' row ' , ' row reverse ' , ' column ' , ' column reverse ' )
token if token . type == ' number ' : return token . valun if token . type == ' number ' : return token . value
token if token . type == ' number ' and token . int value is not none : return token . int valun if token . type == ' number ' and token . int value is not none : return token . int value
keyword return keyword in ( ' nowrap ' , ' wrap ' , ' wrap reverse ' )
keyword return keyword in ( ' auto ' , ' flex start ' , ' flex end ' , ' center ' , ' baseline ' , ' stretch ' )
keyword return keyword in ( ' flex start ' , ' flex end ' , ' center ' , ' space between ' , ' space around ' , ' space evenly ' , ' stretch ' )
keyword return keyword in ( ' auto ' , ' crisp edges ' , ' pixelated ' )
token if get keyword ( token ) == ' none ' : return ' none ' function = parse function ( token ) if function : name , args = function prototype = ( name , [ a . type for a in args ] ) args = [ getattr ( a , ' value ' , a ) for a in args ] if prototype == ( ' attr ' , [ ' ident ' ] ) : return ( ' attr() ' , args [ 0 ] )
token , base url if get keyword ( token ) == ' none ' : return ' none ' parsed url = get url ( token , base url ) if parsed url : return parsed url function = parse function ( token ) if function : name , args = function prototype = ( name , [ a . type for a in args ] ) args = [ getattr ( a , ' value ' , a ) for a in args ] if prototype == ( ' attr ' , [ ' ident ' ] ) : return ( ' attr() ' , args [ 0 ] )
token if token . type == ' number ' and token . int value is not none : value = token . int value if value >= 0 : return value return get length ( token , negative = false )
token keyword = get keyword ( token ) if keyword in ( ' none ' , ' manual ' , ' auto ' ) : return keyword
token keyword = get keyword ( token ) if keyword == ' auto ' : return ' \u2010 ' elif token . type == ' string ' : return token . value
token return get length ( token , negative = false , percentage = true )
token if get keyword ( token ) == ' none ' : return ' none ' function = parse function ( token ) if function : name , args = function prototype = ( name , [ a . type for a in args ] ) args = [ getattr ( a , ' value ' , a ) for a in args ] if prototype == ( ' attr ' , [ ' ident ' ] ) : return ( ' attr() ' , args [ 0 ] ) elif token . type == ' string ' : return ( ' string ' , token . value )
tokens , base url parsed tokens = tuple ( get content list token ( token , base url ) for token in tokens ) if none not in parsed tokens : return parsed tokens
token if token . type == ' number ' and token . int value is not none : value = token . int value if value >= 1 : return value elif get keyword ( token ) == ' none ' : return ' none '
keyword return keyword in ( ' open ' , ' closed ' )
tokens , base url if len ( tokens ) >= 2 : var name = get custom ident ( tokens [ 0 ] ) if var name is none : return parsed tokens = tuple ( get content list token ( token , base url ) for token in tokens [ 1 : ] ) if none not in parsed tokens : return ( var name , parsed tokens ) elif tokens and get keyword ( tokens [ 0 ] ) == ' none ' : return ' none '
descriptor name = none , wants base url = false def decorator ( function ) : """ add ``function`` to the `` descriptors`` . """ if descriptor name is none : name = function . name . replace ( ' ' , ' ' ) else : name = descriptor name assert name not in descriptors , name function . wants base url = wants base url descriptors [ name ] = function return function return decorator
tokens , allow spaces = false allowed types = [ ' ident ' ] if allow spaces : allowed types . append ( ' whitespace ' ) if len ( tokens ) == 1 and tokens [ 0 ] . type == ' string ' : return tokens [ 0 ] . value if tokens and all ( token . type in allowed types for token in tokens ) : return ' ' . join ( token . value for token in tokens if token . type == ' ident ' )
tokens , base url if len ( tokens ) <= 2 : tokens , token = tokens [ : 1 ] , tokens [ 1 ] if token . type == ' function ' and token . lower name == ' format ' : tokens , token = tokens [ : 1 ] , tokens [ 1 ] if token . type == ' function ' and token . lower name == ' local ' : return ' local ' , font family ( token . arguments , allow spaces = true ) url = get url ( token , base url ) if url is not none and url [ 0 ] == ' url ' : return url [ 1 ]
keyword return keyword in ( ' normal ' , ' italic ' , ' oblique ' )
token keyword = get keyword ( token ) if keyword in ( ' normal ' , ' bold ' ) : return keyword if token . type == ' number ' and token . int value is not none : if token . int value in [ 100 , 200 , 300 , 400 , 500 , 600 , 700 , 800 , 900 ] : return token . int value
keyword return keyword in ( ' ultra condensed ' , ' extra condensed ' , ' condensed ' , ' semi condensed ' , ' normal ' , ' semi expanded ' , ' expanded ' , ' extra expanded ' , ' ultra expanded ' )
property name def expander decorator ( function ) : """ add ``function`` to the `` expanders`` . """ assert property name not in expanders , property name expanders [ property name ] = function return function return expander decorator
base url , name , tokens for suffix in ( ' top ' , ' right ' , ' bottom ' , ' left ' ) : for new prop in expand border side ( base url , name + suffix , tokens ) : yield new prop
name , tokens for token in tokens : if parse color ( token ) is not none : suffix = ' color ' elif border width ( [ token ] ) is not none : suffix = ' width ' elif border style ( [ token ] ) is not none : suffix = ' style ' else : raise invalid values yield suffix , [ token ]
base url , name , tokens keyword = get single keyword ( tokens ) new name = name . split ( ' ' , 1 ) [ 1 ] if keyword in ( ' auto ' , ' left ' , ' right ' , ' avoid ' ) : yield new name , keyword elif keyword == ' always ' : yield new name , ' page '
base url , name , tokens keyword = get single keyword ( tokens ) if keyword in ( ' auto ' , ' avoid ' ) : yield ' break inside ' , keyword
name , tokens name = none if len ( tokens ) == 2 and get keyword ( tokens [ 0 ] ) == ' auto ' : tokens = tokens [ : : 1 ] for token in tokens : if column width ( [ token ] ) is not none and name != ' column width ' : name = ' column width ' elif column count ( [ token ] ) is not none : name = ' column count ' else : raise invalid values yield name , [ token ]
name , tokens return expand font variant ( tokens )
base url , name , tokens keyword = overflow wrap ( tokens ) if keyword is none : raise invalid values yield ' overflow wrap ' , keyword
@ page , = render pages ( ' ' ' <style> @font face { src: url(weasyprint . otf); font family: weasyprint } body { font family: weasyprint } </style> <span>abc</span> ' ' ' ) html , = page . children body , = html . children line , = body . children assert line . width == 3 * 1ge , = render pages ( ' ' ' <style> @font face { src: url(weasyprint . otf); font family: weasyprint } body { font family: weasyprint } </style> <span>abc</span> ' ' ' ) html , = page . children body , = html . children line , = body . children assert line . width == 3 * 16
context return ( context . box . element tag , [ b . element tag for b in context . blocks and cells ] , [ serialize stacking ( c ) for c in context . zero z contexts ] ext return ( context . box . element tag , [ b . element tag for b in context . blocks and cells ] , [ serialize stacking ( c ) for c in context . zero z contexts ] )
basename return os . path . join ( os . path . dirname ( file ) , ' resources ' , basename )
@ logger = logger messages = [ ] def emit ( record ) : if record . name == ' weasyprint . progress ' : return message = ' %s: %s ' % ( record . levelname . upper ( ) , record . get message ( ) ) messages . append ( message ) previous handlers = logger . handlers previous level = logger . level logger . handlers = [ ] logger . add handler ( callback handler ( emit ) ) logger . set level ( logging . debug ) try : yield messages finally : logger . handlers = previous handlers logger . level = previous level
function @ functools . wraps ( function ) def wrapper ( * args , ** kwargs ) : with capture logs ( ) as logs : try : function ( * args , ** kwargs ) except exception : # pragma: no cover if logs : print ( ' %i errors logged: ' % len ( logs ) , file = sys . stderr ) for message in logs : print ( message , file = sys . stderr ) raise else : if logs : # pragma: no cover for message in logs : print ( message , file = sys . stderr ) raise assertion error ( ' %i errors logged ' % len ( logs ) ) return wrapper
box list return [ ( box . element tag , type ( box ) . name [ : 3 ] , # all concrete boxes are either text , replaced , column or parent . ( box . text if isinstance ( box , boxes . text box ) else ' <replaced> ' if isinstance ( box , boxes . replaced box ) else serialize ( getattr ( box , ' column groups ' , ( ) ) + tuple ( box . children ) ) ) ) for box in box list ]
html content box , = build . element to box ( * parse base ( html content ) ) return box
html content , base url = base url box = build . build formatting structure ( * parse base ( html content , base url ) ) sanity checks ( box ) return box
html content return [ p . page box for p in fake html ( string = html content , base url = base url ) . render ( enable hinting = true ) . pages ]
box , expected assert box . element tag == ' html ' assert isinstance ( box , boxes . block box ) assert len ( box . children ) == 1 box = box . children [ 0 ] assert isinstance ( box , boxes . block box ) assert box . element tag == ' body ' assert serialize ( box . children ) == expected
box if not isinstance ( box , boxes . parent box ) : return acceptable types lists = none for class in type ( box ) . mro ( ) : if class in proper children : acceptable types lists = proper children [ class ] break assert any ( all ( isinstance ( child , acceptable types ) or not child . is in normal flow ( ) for child in box . children ) for acceptable types in acceptable types lists ) , ( box , box . children ) for child in box . children : sanity checks ( child )
@ pages = render pages ( ' ' ' <style> @page { /* make the page content area only 10px high and wide , so every word in <p> end up on a page of its own . */ size: 30px; margin: 10px; @bottom center { content: " page\u00a0 " counter(page) " \u00a0of\u00a0 " counter(pages) " . " ; } } </style> <p>lorem ipsum dolor ' ' ' ) for page number , page in enumerate ( pages , 1 ) : html , bottom center = page . children line box , = bottom center . children text box , = line box . children assert text box . text == ' page\u00a0{0}\u00a0of\u00a03 . ' . format ( page number )
html box = parse all ( html ) assert box . style [ ' display ' ] == ' block ' assert not box . childre box = parse all ( html ) assert box . style [ ' display ' ] == ' block ' assert not box . children
self , data self . chunks . append ( bytes ( data [ : ] ) , data self . chunks . append ( bytes ( data [ : ] ) )
self return b ' ' . join ( self . chunks return b ' ' . join ( self . chunks )
result png bytes , width , height = result surface = cairo . image surface . create from png ( io . bytes io ( png bytes ) ) assert ( surface . get width ( ) , surface . get height ( ) ) == ( width , height ) return width , heighlt png bytes , width , height = result surface = cairo . image surface . create from png ( io . bytes io ( png bytes ) ) assert ( surface . get width ( ) , surface . get height ( ) ) == ( width , height ) return width , height
html , expected by page , expected tree , round document = fake html ( string = html ) . render ( ) if round : round meta ( document . pages ) assert [ p . bookmarks for p in document . pages ] == expected by page assert document . make bookmark tree ( ) == expected tre , expected by page , expected tree , round document = fake html ( string = html ) . render ( ) if round : round meta ( document . pages ) assert [ p . bookmarks for p in document . pages ] == expected by page assert document . make bookmark tree ( ) == expected tree
rect , values if isinstance ( rect , bytes ) : rect = rect . decode ( ' ascii ' ) for a , b in zip ( rect . strip ( ' [] ' ) . split ( ) , values ) : assert abs ( int ( a ) b ) <= 1
zoom pdf bytes = fake html ( string = ' <style>@page{size:3in 4in ' ) . write pdf ( zoom = zoom ) assert ' / media box [ 0 0 {} {} ] ' . format ( int ( 216 * zoom ) , int ( 288 * zoom ) ) . encode ( ' ascii ' ) in pdf byte pdf bytes = fake html ( string = ' <style>@page{size:3in 4in ' ) . write pdf ( zoom = zoom ) assert ' / media box [ 0 0 {} {} ] ' . format ( int ( 216 * zoom ) , int ( 288 * zoom ) ) . encode ( ' ascii ' ) in pdf bytes
@ fileobj = io . bytes io ( ) fake html ( string = ' <body> ' ) . write pdf ( target = fileobj ) pdf file = pdf . pdf file ( fileobj ) with pytest . raises ( attribute error ) : pdf file . catalog . get indirect dict ( ' outlines ' , pdf file leobj = io . bytes io ( ) fake html ( string = ' <body> ' ) . write pdf ( target = fileobj ) pdf file = pdf . pdf file ( fileobj ) with pytest . raises ( attribute error ) : pdf file . catalog . get indirect dict ( ' outlines ' , pdf file )
@ fileobj = io . bytes io ( ) fake html ( string = ' <body> ' ) . write pdf ( target = fileobj ) pdf file = pdf . pdf file ( fileobj ) with pytest . raises ( attribute error ) : pdf file . pages [ 0 ] . get indirect dict array ( ' annots ' , pdf file leobj = io . bytes io ( ) fake html ( string = ' <body> ' ) . write pdf ( target = fileobj ) pdf file = pdf . pdf file ( fileobj ) with pytest . raises ( attribute error ) : pdf file . pages [ 0 ] . get indirect dict array ( ' annots ' , pdf file )
@ assert b ' / filter / dct decode ' not in fake html ( base url = resource filename ( ' dummy . html ' ) , string = ' <img src= " pattern . gif " > ' ) . write pdf ( sert b ' / filter / dct decode ' not in fake html ( base url = resource filename ( ' dummy . html ' ) , string = ' <img src= " pattern . gif " > ' ) . write pdf ( )
@ assert b ' / filter / dct decode ' in fake html ( base url = resource filename ( ' dummy . html ' ) , string = ' <img src= " blue . jpg " > ' ) . write pdf ( sert b ' / filter / dct decode ' in fake html ( base url = resource filename ( ' dummy . html ' ) , string = ' <img src= " blue . jpg " > ' ) . write pdf ( )
def page , = parse ( ' ' ' <style> p { var: 10px; width: var( var) } </style> <p></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 1page , = parse ( ' ' ' <style> p { var: 10px; width: var( var) } </style> <p></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 10
def page , = parse ( ' ' ' <style> html { var: 20px } p { width: var( var); var: 10px } </style> <p></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 1page , = parse ( ' ' ' <style> html { var: 20px } p { width: var( var); var: 10px } </style> <p></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 10
def page , = parse ( ' ' ' <style> html { var: 20px } body { var: 10px } p { width: var( var) } </style> <p></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 1page , = parse ( ' ' ' <style> html { var: 20px } body { var: 10px } p { width: var( var) } </style> <p></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 10
def page , = parse ( ' ' ' <style> html { foo: 10px } body { var: var( foo) } p { width: var( var) } </style> <p></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 1page , = parse ( ' ' ' <style> html { foo: 10px } body { var: var( foo) } p { width: var( var) } </style> <p></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 10
def page , = parse ( ' ' ' <style> html { var: initial } p { width: var( var , 10px) } </style> <p></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 1page , = parse ( ' ' ' <style> html { var: initial } p { width: var( var , 10px) } </style> <p></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 10
text , width = none , ** style new style = dict ( initial values ) new style [ ' font family ' ] = mono fonts . split ( ' , ' ) new style . update ( style ) return split first line ( text , new style , context = none , max width = width , justification spacing = 0 )
@ , , , width 1 , , = make text ( ' some text ' ) , , , width 2 , , = make text ( ' some text some text ' ) assert width 1 < width , , , width 1 , , = make text ( ' some text ' ) , , , width 2 , , = make text ( ' some text some text ' ) assert width 1 < width 2
width , space page , = render pages ( ' ' ' <style> body { font size: 100px; width: %ipx } span { white space: %s } </style> <body><span> this + \ is text ' ' ' % ( width , space ) ) html , = page . children body , = html . children return body . childreh , space page , = render pages ( ' ' ' <style> body { font size: 100px; width: %ipx } span { white space: %s } </style> <body><span> this + \ is text ' ' ' % ( width , space ) ) html , = page . children body , = html . children return body . children
@ line1 , = white space lines ( 1 , ' nowrap ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + is text 'ne1 , = white space lines ( 1 , ' nowrap ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + is text '
@ line1 , = white space lines ( 1000000 , ' normal ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + is text 'ne1 , = white space lines ( 1000000 , ' normal ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + is text '
@ line1 , line2 = white space lines ( 1000000 , ' pre ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + ' box2 , = line2 . children text2 , = box2 . children assert text2 . text == ' is text 'ne1 , line2 = white space lines ( 1000000 , ' pre ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + ' box2 , = line2 . children text2 , = box2 . children assert text2 . text == ' is text '
@ line1 , = white space lines ( 1000000 , ' nowrap ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + is text 'ne1 , = white space lines ( 1000000 , ' nowrap ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + is text '
@ line1 , line2 = white space lines ( 1000000 , ' pre wrap ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + ' box2 , = line2 . children text2 , = box2 . children assert text2 . text == ' is text 'ne1 , line2 = white space lines ( 1000000 , ' pre wrap ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + ' box2 , = line2 . children text2 , = box2 . children assert text2 . text == ' is text '
@ line1 , line2 = white space lines ( 1000000 , ' pre line ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + ' box2 , = line2 . children text2 , = box2 . children assert text2 . text == ' is text 'ne1 , line2 = white space lines ( 1000000 , ' pre line ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + ' box2 , = line2 . children text2 , = box2 . children assert text2 . text == ' is text '
@ page , = render pages ( ' ' ' <div style= " float: left; white space: pre line " > this is oh this end </div> ' ' ' ge , = render pages ( ' ' ' <div style= " float: left; white space: pre line " > this is oh this end </div> ' ' ' )
box return ( box . position x , box . position y , box . margin width ( ) , box . margin height ( ) )
@ page , = render pages ( ' ' ' <style>img { width: 20px }</style> <p style= " float: left " > <img src=pattern . png><img src=pattern . png><br> <img src=pattern . png></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 4ge , = render pages ( ' ' ' <style>img { width: 20px }</style> <p style= " float: left " > <img src=pattern . png><img src=pattern . png><br> <img src=pattern . png></p> ' ' ' ) html , = page . children body , = html . children paragraph , = body . children assert paragraph . width == 40
@ style = { ' margin left ' : 12 , ' display ' : ' block ' } assert style [ ' display ' ] == ' block ' assert style [ ' margin left ' ] == 12 with pytest . raises ( key error ) : style [ ' position ' yle = { ' margin left ' : 12 , ' display ' : ' block ' } assert style [ ' display ' ] == ' block ' assert style [ ' margin left ' ] == 12 with pytest . raises ( key error ) : style [ ' position ' ]
style , selectors at rule , = tinycss2 . parse stylesheet ( style ) assert parse page selectors ( at rule ) == selectore , selectors at rule , = tinycss2 . parse stylesheet ( style ) assert parse page selectors ( at rule ) == selectors
source , messages with capture logs ( ) as logs : css ( string = source ) assert len ( logs ) == 1 , source for message in messages : assert message in logs [ 0 ]
@ html = ' <link rel=stylesheet href=invalid protocol://absolute> ' with capture logs ( ) as logs : fake html ( string = html ) . render ( ) assert len ( logs ) == 1 assert ' error: failed to load stylesheet at ' in logs [ 0 ml = ' <link rel=stylesheet href=invalid protocol://absolute> ' with capture logs ( ) as logs : fake html ( string = html ) . render ( ) assert len ( logs ) == 1 assert ' error: failed to load stylesheet at ' in logs [ 0 ]
style with capture logs ( ) as logs : document = fake html ( string = style ) page , = document . render ( ) . pages html , = page . page box . children assert html . style [ ' color ' ] == ( 0 , 0 , 1 , 1 ) assert len ( logs ) == e with capture logs ( ) as logs : document = fake html ( string = style ) page , = document . render ( ) . pages html , = page . page box . children assert html . style [ ' color ' ] == ( 0 , 0 , 1 , 1 ) assert len ( logs ) == 2
@ assert pixels ( ' background current color ' , 2 , 2 , green 2x2 , ' ' ' <style> @page { size: 2px } html , body { height: 100%; margin: 0 } html { color: red; background: current color } body { color: lime; background: inherit } </style> <body> ' ' ' sert pixels ( ' background current color ' , 2 , 2 , green 2x2 , ' ' ' <style> @page { size: 2px } html , body { height: 100%; margin: 0 } html { color: red; background: current color } body { color: lime; background: inherit } </style> <body> ' ' ' )
@ assert pixels ( ' border collapse current color ' , 2 , 2 , green 2x2 , ' ' ' <style> @page { size: 2px } html { color: red; border color: current color; } body { margin: 0 } table { border collapse: collapse; color: lime; border: 1px solid; border color: inherit } </style> <table><td> ' ' ' sert pixels ( ' border collapse current color ' , 2 , 2 , green 2x2 , ' ' ' <style> @page { size: 2px } html { color: red; border color: current color; } body { margin: 0 } table { border collapse: collapse; color: lime; border: 1px solid; border color: inherit } </style> <table><td> ' ' ' )
@ assert pixels ( ' inline image overflow ' , 8 , 8 , ' ' ' r bbb bbbb ' ' ' , ' ' ' <style> @page { size: 8px } body { margin: 2px 0 0 2px; background: #fff; font size:0 } div { height: 2px; overflow: hidden } </style> <div><img src= " pattern . png " ></div> ' ' ' sert pixels ( ' inline image overflow ' , 8 , 8 , ' ' ' r bbb bbbb ' ' ' , ' ' ' <style> @page { size: 8px } body { margin: 2px 0 0 2px; background: #fff; font size:0 } div { height: 2px; overflow: hidden } </style> <div><img src= " pattern . png " ></div> ' ' ' )
@ assert pixels ( ' border box overflow ' , 8 , 8 , ' ' ' bbbb b b b b bbbb ' ' ' , ' ' ' <style> @page { size: 8px; background: #fff; margin: 2px; } div { width: 2px; height: 2px; overflow: hidden; border: 1px solid blue; } </style> <div></div> ' ' ' sert pixels ( ' border box overflow ' , 8 , 8 , ' ' ' bbbb b b b b bbbb ' ' ' , ' ' ' <style> @page { size: 8px; background: #fff; margin: 2px; } div { width: 2px; height: 2px; overflow: hidden; border: 1px solid blue; } </style> <div></div> ' ' ' )
@ assert pixels ( ' image rotate90 ' , 8 , 8 , ' ' ' bb br bbbb bbbb bbbb ' ' ' , ' ' ' <style> @page { size: 8px; margin: 2px; background: #fff; } div { transform: rotate(90deg); font size: 0 } </style> <div><img src= " pattern . png " ></div> ' ' ' sert pixels ( ' image rotate90 ' , 8 , 8 , ' ' ' bb br bbbb bbbb bbbb ' ' ' , ' ' ' <style> @page { size: 8px; margin: 2px; background: #fff; } div { transform: rotate(90deg); font size: 0 } </style> <div><img src= " pattern . png " ></div> ' ' ' )
@ assert pixels ( ' image rotate90 translate x ' , 12 , 12 , ' ' ' bb br bbbb bbbb bbbb ' ' ' , ' ' ' <style> @page { size: 12px; margin: 2px; background: #fff; } div { transform: rotate(90deg) translate x(3px); font size: 0; width: 4px } </style> <div><img src= " pattern . png " ></div> ' ' ' sert pixels ( ' image rotate90 translate x ' , 12 , 12 , ' ' ' bb br bbbb bbbb bbbb ' ' ' , ' ' ' <style> @page { size: 12px; margin: 2px; background: #fff; } div { transform: rotate(90deg) translate x(3px); font size: 0; width: 4px } </style> <div><img src= " pattern . png " ></div> ' ' ' )
@ assert pixels ( ' image translate percentage ' , 8 , 8 , ' ' ' r bbb bbbb bbbb bbbb ' ' ' , ' ' ' <style> @page { size: 8px; margin: 2px; background: #fff; } div { transform: translate(25% , 0); font size: 0 } </style> <div><img src= " pattern . png " ></div> ' ' ' sert pixels ( ' image translate percentage ' , 8 , 8 , ' ' ' r bbb bbbb bbbb bbbb ' ' ' , ' ' ' <style> @page { size: 8px; margin: 2px; background: #fff; } div { transform: translate(25% , 0); font size: 0 } </style> <div><img src= " pattern . png " ></div> ' ' ' )
@ assert pixels ( ' image translate y ' , 8 , 8 , ' ' ' r bbb bbbb bbbb bbbb ' ' ' , ' ' ' <style> @page { size: 8px; margin: 2px; background: #fff; } div { transform: translate y( 1px); font size: 0 } </style> <div><img src= " pattern . png " ></div> ' ' ' sert pixels ( ' image translate y ' , 8 , 8 , ' ' ' r bbb bbbb bbbb bbbb ' ' ' , ' ' ' <style> @page { size: 8px; margin: 2px; background: #fff; } div { transform: translate y( 1px); font size: 0 } </style> <div><img src= " pattern . png " ></div> ' ' ' )
@ assert same rendering ( 60 , 60 , [ ( ' opacity 0 reference ' , opacity source % ' ' ' <div></div> ' ' ' ) , ( ' opacity 0 ' , opacity source % ' ' ' <div></div> <div style= " opacity: 0 " ></div> ' ' ' ) , ] sert same rendering ( 60 , 60 , [ ( ' opacity 0 reference ' , opacity source % ' ' ' <div></div> ' ' ' ) , ( ' opacity 0 ' , opacity source % ' ' ' <div></div> <div style= " opacity: 0 " ></div> ' ' ' ) , ] )
name , expected width , expected height , expected pixels , html assert pixels ( name , expected width , expected height , expected pixels , html , expected width , expected height , expected pixels , html assert pixels ( name , expected width , expected height , expected pixels , html )
name , css , pixels assert pixels ( ' background ' + name , 14 , 16 , pixels , ' ' ' <style> @page { size: 14px 16px } html { background: #fff } body { margin: 2px; height: 10px; background: %s } p { background: none } </style> <body> <p>&nbsp; ' ' ' % css , css , pixels assert pixels ( ' background ' + name , 14 , 16 , pixels , ' ' ' <style> @page { size: 14px 16px } html { background: #fff } body { margin: 2px; height: 10px; background: %s } p { background: none } </style> <body> <p>&nbsp; ' ' ' % css )
@ assert pixels ( ' zero size background ' , 10 , 10 , ' ' ' ' ' ' , ' ' ' <style> @page { size: 10px } html { background: #fff } body { background: url(pattern . png); background size: cover; display: inline block } </style> <body> ' ' ' sert pixels ( ' zero size background ' , 10 , 10 , ' ' ' ' ' ' , ' ' ' <style> @page { size: 10px } html { background: #fff } body { background: url(pattern . png); background size: cover; display: inline block } </style> <body> ' ' ' )
value , pixels assert pixels ( ' background clip ' + value , 8 , 8 , pixels , ' ' ' <style> @page { size: 8px } html { background: #fff } body { margin: 1px; padding: 1px; height: 2px; border: 1px solid transparent; background: %s } </style> <body> ' ' ' % value e , pixels assert pixels ( ' background clip ' + value , 8 , 8 , pixels , ' ' ' <style> @page { size: 8px } html { background: #fff } body { margin: 1px; padding: 1px; height: 2px; border: 1px solid transparent; background: %s } </style> <body> ' ' ' % value )
name , expected width , expected height , expected pixels , html assert pixels ( name , expected width , expected height , expected pixels , html , expected width , expected height , expected pixels , html assert pixels ( name , expected width , expected height , expected pixels , html )
basename , pixels , width , height directory = os . path . join ( os . path . dirname ( file ) , ' results ' ) if not os . path . isdir ( directory ) : os . mkdir ( directory ) filename = os . path . join ( directory , basename + ' . png ' ) cairo . image surface ( cairo . format argb32 , width , height , data = bytearray ( pixels ) , stride = width * 4 ) . write to png ( filename )
name , expected width , expected height , html document = fake html ( string = html , # dummy filename , but in the right directory . base url = resource filename ( ' <test> ' ) ) pixels = document to pixels ( document , name , expected width , expected height ) return document , pixels
document , name , expected width , expected height surface = document . write image surface ( ) return image to pixels ( surface , expected width , expected height )
filename , image assert pixels ( ' inline image ' + filename , 8 , 8 , image , ' ' ' <style> @page { size: 8px } body { margin: 2px 0 0 2px; background: #fff; font size: 0 } </style> <div><img src= " %s " ></div> ' ' ' % filename name , image assert pixels ( ' inline image ' + filename , 8 , 8 , image , ' ' ' <style> @page { size: 8px } body { margin: 2px 0 0 2px; background: #fff; font size: 0 } </style> <div><img src= " %s " ></div> ' ' ' % filename )
@ assert pixels ( ' image no src ' , 8 , 8 , no image , ' ' ' <style> @page { size: 8px } body { margin: 0; background: #fff; font size: 0 } img { display: block; margin: 2px auto 0 } </style> <div><img alt= " " ></div> ' ' ' sert pixels ( ' image no src ' , 8 , 8 , no image , ' ' ' <style> @page { size: 8px } body { margin: 0; background: #fff; font size: 0 } img { display: block; margin: 2px auto 0 } </style> <div><img alt= " " ></div> ' ' ' )
@ assert pixels ( ' image 0x1 ' , 8 , 8 , no image , ' ' ' <style> @page { size: 8px } body { margin: 2px; background: #fff; font size: 0 } </style> <div><img src= " pattern . png " alt= " not shown " style= " width: 0; height: 1px " ></div> ' ' ' sert pixels ( ' image 0x1 ' , 8 , 8 , no image , ' ' ' <style> @page { size: 8px } body { margin: 2px; background: #fff; font size: 0 } </style> <div><img src= " pattern . png " alt= " not shown " style= " width: 0; height: 1px " ></div> ' ' ' )
@ assert pixels ( ' image 1x0 ' , 8 , 8 , no image , ' ' ' <style> @page { size: 8px } body { margin: 2px; background: #fff; font size: 0 } </style> <div><img src= " pattern . png " alt= " not shown " style= " width: 1px; height: 0 " ></div> ' ' ' sert pixels ( ' image 1x0 ' , 8 , 8 , no image , ' ' ' <style> @page { size: 8px } body { margin: 2px; background: #fff; font size: 0 } </style> <div><img src= " pattern . png " alt= " not shown " style= " width: 1px; height: 0 " ></div> ' ' ' )
@ assert pixels ( ' image 0x0 ' , 8 , 8 , no image , ' ' ' <style> @page { size: 8px } body { margin: 2px; background: #fff; font size: 0 } </style> <div><img src= " pattern . png " alt= " not shown " style= " width: 0; height: 0 " ></div> ' ' ' sert pixels ( ' image 0x0 ' , 8 , 8 , no image , ' ' ' <style> @page { size: 8px } body { margin: 2px; background: #fff; font size: 0 } </style> <div><img src= " pattern . png " alt= " not shown " style= " width: 0; height: 0 " ></div> ' ' ' )
@ assert pixels ( ' image with padding ' , 8 , 8 , centered image , ' ' ' <style> @page { size: 8px; background: #fff } body { font size: 0 } </style> <div style= " line height: 1px " > <img src=pattern . png style= " padding: 2px 0 0 2px " > </div> ' ' ' sert pixels ( ' image with padding ' , 8 , 8 , centered image , ' ' ' <style> @page { size: 8px; background: #fff } body { font size: 0 } </style> <div style= " line height: 1px " > <img src=pattern . png style= " padding: 2px 0 0 2px " > </div> ' ' ' )
@ return test borders ( margin = ' 20px ' , prop = ' outline ' turn test borders ( margin = ' 20px ' , prop = ' outline ' )
@ assert pixels ( ' visibility hidden ' , 12 , 7 , ' ' ' ' ' ' , visibility source % { ' extra css ' : ' div { visibility: hidden } ' } sert pixels ( ' visibility hidden ' , 12 , 7 , ' ' ' ' ' ' , visibility source % { ' extra css ' : ' div { visibility: hidden } ' } )
@ assert pixels ( ' visibility mixed ' , 12 , 7 , ' ' ' r bbb bbbb bbbb bbbb ' ' ' , visibility source % { ' extra css ' : ' ' ' div { visibility: hidden } span { visibility: visible } ' ' ' } sert pixels ( ' visibility mixed ' , 12 , 7 , ' ' ' r bbb bbbb bbbb bbbb ' ' ' , visibility source % { ' extra css ' : ' ' ' div { visibility: hidden } span { visibility: visible } ' ' ' } )
pixels str return parse pixels ( pixels str , pix by char overrides ls str return parse pixels ( pixels str , pix by char overrides )
@ assert pixels ( ' linear gradient ' , 5 , 9 , ' ' ' bbbbb bbbbb rrrrr rrrrr rrrrr rrrrr ' ' ' , ' ' ' <style>@page { size: 5px 9px; background: linear gradient( white , white 3px , blue 0 , blue 5px , red 0 , red ) ' ' ' sert pixels ( ' linear gradient ' , 5 , 9 , ' ' ' bbbbb bbbbb rrrrr rrrrr rrrrr rrrrr ' ' ' , ' ' ' <style>@page { size: 5px 9px; background: linear gradient( white , white 3px , blue 0 , blue 5px , red 0 , red ) ' ' ' )
@ assert pixels ( ' linear gradient ' , 5 , 9 , ' ' ' bbbbb bbbbb rrrrr rrrrr rrrrr rrrrr ' ' ' , ' ' ' <style>@page { size: 5px 9px; background: linear gradient( white 3px , blue 0 , blue 5px , red 0 ) ' ' ' sert pixels ( ' linear gradient ' , 5 , 9 , ' ' ' bbbbb bbbbb rrrrr rrrrr rrrrr rrrrr ' ' ' , ' ' ' <style>@page { size: 5px 9px; background: linear gradient( white 3px , blue 0 , blue 5px , red 0 ) ' ' ' )
@ assert pixels ( ' linear gradient ' , 9 , 5 , ' ' ' b brrrr b brrrr b brrrr b brrrr b brrrr ' ' ' , ' ' ' <style>@page { size: 9px 5px; background: linear gradient( to right , white 3px , blue 0 , blue 5px , red 0 ) ' ' ' sert pixels ( ' linear gradient ' , 9 , 5 , ' ' ' b brrrr b brrrr b brrrr b brrrr b brrrr ' ' ' , ' ' ' <style>@page { size: 9px 5px; background: linear gradient( to right , white 3px , blue 0 , blue 5px , red 0 ) ' ' ' )
@ assert pixels ( ' linear gradient ' , 10 , 5 , ' ' ' bbbbb brrrr bbbbb brrrr bbbbb brrrr bbbbb brrrr bbbbb brrrr ' ' ' , ' ' ' <style>@page { size: 10px 5px; background: linear gradient( to right , blue 5px , blue 6px , red 6px , red 9px ) ' ' ' sert pixels ( ' linear gradient ' , 10 , 5 , ' ' ' bbbbb brrrr bbbbb brrrr bbbbb brrrr bbbbb brrrr bbbbb brrrr ' ' ' , ' ' ' <style>@page { size: 10px 5px; background: linear gradient( to right , blue 5px , blue 6px , red 6px , red 9px ) ' ' ' )
@ assert pixels ( ' linear gradient ' , 9 , 5 , ' ' ' hhhhhhhhh hhhhhhhhh hhhhhhhhh hhhhhhhhh hhhhhhhhh ' ' ' , ' ' ' <style>@page { size: 9px 5px; background: repeating linear gradient( to right , black 3px , black 3px , #800080 3px , #800080 3px ) ' ' ' sert pixels ( ' linear gradient ' , 9 , 5 , ' ' ' hhhhhhhhh hhhhhhhhh hhhhhhhhh hhhhhhhhh hhhhhhhhh ' ' ' , ' ' ' <style>@page { size: 9px 5px; background: repeating linear gradient( to right , black 3px , black 3px , #800080 3px , #800080 3px ) ' ' ' )
@ assert pixels ( ' linear gradient ' , 9 , 5 , ' ' ' vvvvvvvvv vvvvvvvvv vvvvvvvvv vvvvvvvvv vvvvvvvvv ' ' ' , ' ' ' <style> @page { size: 9px 5px; background: repeating linear gradient( to right , blue 50% , blue 60% , red 60% , red 90%); background size: 1px 1px ' ' ' sert pixels ( ' linear gradient ' , 9 , 5 , ' ' ' vvvvvvvvv vvvvvvvvv vvvvvvvvv vvvvvvvvv vvvvvvvvv ' ' ' , ' ' ' <style> @page { size: 9px 5px; background: repeating linear gradient( to right , blue 50% , blue 60% , red 60% , red 90%); background size: 1px 1px ' ' ' )
@ assert pixels ( ' radial gradient ' , 6 , 6 , ' ' ' bbbbbb bbbbbb bbbbbb bbbbbb bbbbbb bbbbbb ' ' ' , ' ' ' <style>@page { size: 6px; background: radial gradient(red 30% , blue 10%) ' ' ' sert pixels ( ' radial gradient ' , 6 , 6 , ' ' ' bbbbbb bbbbbb bbbbbb bbbbbb bbbbbb bbbbbb ' ' ' , ' ' ' <style>@page { size: 6px; background: radial gradient(red 30% , blue 10%) ' ' ' )
@ assert pixels ( ' radial gradient ' , 6 , 6 , ' ' ' rrrrrr rrrrrr rrrrrr rrrrrr rrrrrr rrrrrr ' ' ' , ' ' ' <style>@page { size: 6px; background: radial gradient(red 110% , blue 130%) ' ' ' sert pixels ( ' radial gradient ' , 6 , 6 , ' ' ' rrrrrr rrrrrr rrrrrr rrrrrr rrrrrr rrrrrr ' ' ' , ' ' ' <style>@page { size: 6px; background: radial gradient(red 110% , blue 130%) ' ' ' )
@ page , = parse ( ' ' ' <style> html , body { margin: 0 } body { height: 50% } </style> ' ' ' ) html , = page . children assert html . element tag == ' html ' body , = html . children assert body . element tag == ' body ' assert body . height == ge , = parse ( ' ' ' <style> html , body { margin: 0 } body { height: 50% } </style> ' ' ' ) html , = page . children assert html . element tag == ' html ' body , = html . children assert body . element tag == ' body ' assert body . height == 0
size , width , height page , = render pages ( ' <style>@page { size: %s; }</style> ' % size ) assert int ( page . margin width ( ) ) == width assert int ( page . margin height ( ) ) == height
direction , page break , pages number pages = render pages ( ' ' ' <style> html { direction: %s } p { break before: %s } </style> abc <p>def</p> ' ' ' % ( direction , page break ) ) assert len ( pages ) == pages numbection , page break , pages number pages = render pages ( ' ' ' <style> html { direction: %s } p { break before: %s } </style> abc <p>def</p> ' ' ' % ( direction , page break ) ) assert len ( pages ) == pages number
@ page , = render pages ( ' ' ' <div class= " references " style= " display: flex; align items: baseline; " > <div></div> </div> ' ' ' ge , = render pages ( ' ' ' <div class= " references " style= " display: flex; align items: baseline; " > <div></div> </div> ' ' ' )
html page , = parse ( html ) html , = page . children body , = html . children line , = body . children img , = line . children return body , im page , = parse ( html ) html , = page . children body , = html . children line , = body . children img , = line . children return body , img
@ url = " data:image/svg+xml , <svg width= ' 2 . 54cm ' height= ' 0 . 5in ' ></svg> " body , img = get img ( ' <img src= " %s " > ' % url ) assert img . width == 96 assert img . height == 4l = " data:image/svg+xml , <svg width= ' 2 . 54cm ' height= ' 0 . 5in ' ></svg> " body , img = get img ( ' <img src= " %s " > ' % url ) assert img . width == 96 assert img . height == 48
@ with capture logs ( ) as logs : parse ( ' <img src=nonexistent . png><img src=nonexistent . png> ' ) assert len ( logs ) == 1 assert ' error: failed to load image ' in logs [ 0 th capture logs ( ) as logs : parse ( ' <img src=nonexistent . png><img src=nonexistent . png> ' ) assert len ( logs ) == 1 assert ' error: failed to load image ' in logs [ 0 ]
@ body , img = get img ( ' ' ' <body style= " font size: 0 " > <img src= " pattern . png " style= " width: 40px " > ' ' ' ) assert body . height == 40 assert img . position y == 0 assert img . width == 40 assert img . height == 4dy , img = get img ( ' ' ' <body style= " font size: 0 " > <img src= " pattern . png " style= " width: 40px " > ' ' ' ) assert body . height == 40 assert img . position y == 0 assert img . width == 40 assert img . height == 40
@ body , img = get img ( ' ' ' <body style= " font size: 0 " > <img src= " pattern . png " style= " height: 40px " > ' ' ' ) assert body . height == 40 assert img . position y == 0 assert img . width == 40 assert img . height == 4dy , img = get img ( ' ' ' <body style= " font size: 0 " > <img src= " pattern . png " style= " height: 40px " > ' ' ' ) assert body . height == 40 assert img . position y == 0 assert img . width == 40 assert img . height == 40
@ body , img = get img ( ' ' ' <body style= " font size: 0 " > <img src= " pattern . png " style= " min width: 40px " > ' ' ' ) assert body . height == 40 assert img . position y == 0 assert img . width == 40 assert img . height == 4dy , img = get img ( ' ' ' <body style= " font size: 0 " > <img src= " pattern . png " style= " min width: 40px " > ' ' ' ) assert body . height == 40 assert img . position y == 0 assert img . width == 40 assert img . height == 40
@ body , img = get img ( ' <img src= " pattern . png " style= " max width: 2px " > ' ) assert img . width == 2 assert img . height == dy , img = get img ( ' <img src= " pattern . png " style= " max width: 2px " > ' ) assert img . width == 2 assert img . height == 2
@ page , = parse ( ' <p> </p> ' ) html , = page . children body , = html . children paragraph , = body . children assert len ( paragraph . children ) == 0 assert paragraph . height == ge , = parse ( ' <p> </p> ' ) html , = page . children body , = html . children paragraph , = body . children assert len ( paragraph . children ) == 0 assert paragraph . height == 0
@ page , = parse ( ' ' ' <style> p { width: 1px } </style> <p><br> </p> ' ' ' ) page , = parse ( ' <p> </p> ' ) html , = page . children body , = html . children paragraph , = body . children assert len ( paragraph . children ) == ge , = parse ( ' ' ' <style> p { width: 1px } </style> <p><br> </p> ' ' ' ) page , = parse ( ' <p> </p> ' ) html , = page . children body , = html . children paragraph , = body . children assert len ( paragraph . children ) == 1
@ page , = render pages ( ' ' ' <table style= " max width: 300px " > <td style= " width: 400px " ></td> </table> ' ' ' ge , = render pages ( ' ' ' <table style= " max width: 300px " > <td style= " width: 400px " ></td> </table> ' ' ' )
@ page , = render pages ( ' ' ' <table style= " width: 300px; max width: 350px " > <td style= " width: 400px " ></td> </table> ' ' ' ge , = render pages ( ' ' ' <table style= " width: 300px; max width: 350px " > <td style= " width: 400px " ></td> </table> ' ' ' )
@ page , = render pages ( ' ' ' <table style= " width: 300px; max width: 350px " > <td style= " padding: 50px " > <div style= " width: 300px " ></div> </td> </table> ' ' ' ge , = render pages ( ' ' ' <table style= " width: 300px; max width: 350px " > <td style= " padding: 50px " > <div style= " width: 300px " ></div> </td> </table> ' ' ' )
@ page , = render pages ( ' ' ' <table style= " max width: 300px; margin: 100px " > <td style= " width: 400px " ></td> </table> ' ' ' ge , = render pages ( ' ' ' <table style= " max width: 300px; margin: 100px " > <td style= " width: 400px " ></td> </table> ' ' ' )
@ page , = render pages ( ' ' ' <table style= " width: 300px; border spacing: 2px " > <td style= " width: 299px " ></td> </table> ' ' ' ge , = render pages ( ' ' ' <table style= " width: 300px; border spacing: 2px " > <td style= " width: 299px " ></td> </table> ' ' ' )
@ page , = render pages ( ' ' ' <table> <td style= " width: 50% " > </table> ' ' ' ge , = render pages ( ' ' ' <table> <td style= " width: 50% " > </table> ' ' ' )
@ page , = render pages ( ' ' ' <table> <tr> <td> <table> <tr> <th> test</th> </tr> <tr> <td style= " min width: 100%; " ></td> <td style= " width: 48px; " ></td> </tr> </table> </td> </tr> </table> ' ' ' ge , = render pages ( ' ' ' <table> <tr> <td> <table> <tr> <th> test</th> </tr> <tr> <td style= " min width: 100%; " ></td> <td style= " width: 48px; " ></td> </tr> </table> </td> </tr> </table> ' ' ' )
@ page , = render pages ( ' ' ' <table> <tr> <td> <table style= " display: inline table " > <tr> <td style= " width: 100%; " ></td> <td></td> </tr> </table> </td> </tr> </table> ' ' ' ge , = render pages ( ' ' ' <table> <tr> <td> <table style= " display: inline table " > <tr> <td style= " width: 100%; " ></td> <td></td> </tr> </table> </td> </tr> </table> ' ' ' )
@ page , = render pages ( ' <html style= " display: table " > ' ge , = render pages ( ' <html style= " display: table " > ' )
orig phn , mapping group phn = [ ] for val in orig phn : group phn . append ( val ) group phn . append ( ' sil ' ) for key in mapping . keys ( ) : if key in orig phn : group phn . remove ( key ) group phn . sort ( ) return group ph phn , mapping group phn = [ ] for val in orig phn : group phn . append ( val ) group phn . append ( ' sil ' ) for key in mapping . keys ( ) : if key in orig phn : group phn . remove ( key ) group phn . sort ( ) return group phn
object , name ' ' ' get attributes for object ' ' ' assert type ( name ) == list , ' name must be a list ' value = [ ] for n in name : value . append ( getattr ( object , n , ' none ' ) ) return valuct , name ' ' ' get attributes for object ' ' ' assert type ( name ) == list , ' name must be a list ' value = [ ] for n in name : value . append ( getattr ( object , n , ' none ' ) ) return value
target seq = [ ] for t in target : if t == len ( phn ) : pass else : seq . append ( phn [ t ] ) seq = ' ' . join ( seq ) return seet seq = [ ] for t in target : if t == len ( phn ) : pass else : seq . append ( phn [ t ] ) seq = ' ' . join ( seq ) return seq
mfcc dir , label dir mfcc dirs = glob ( mfcc dir ) label dirs = glob ( label dir ) for mfcc , label in zip ( mfcc dirs , label dirs ) : yield ( mfcc , label dir , label dir mfcc dirs = glob ( mfcc dir ) label dirs = glob ( label dir ) for mfcc , label in zip ( mfcc dirs , label dirs ) : yield ( mfcc , label )
shape fan in = shape [ 0 ] if len ( shape ) == 2 else np . prod ( shape [ : 1 ] ) fan out = shape [ 1 ] if len ( shape ) == 2 else shape [ 1 ] return fan in , fan out
self return self . num unit return self . num units
self return self . num unit return self . num units
self return self . num unit return self . num units
self return ( lstm state tuple ( self . num units , self . num units ) if self . state is tuple else 2 * self . num units return ( lstm state tuple ( self . num units , self . num units ) if self . state is tuple else 2 * self . num units )
path if isinstance ( path , list ) : for p in path : if not os . path . exists ( p ) : os . makedirs ( p ) else : if not os . path . exists ( path ) : os . makedirs ( path )
seq strings = [ ] for s in seq : strings . append ( ' ' . join ( [ chr ( 65 + p ) for p in s ] ) ) return stringstrings = [ ] for s in seq : strings . append ( ' ' . join ( [ chr ( 65 + p ) for p in s ] ) ) return strings
audio , window size = 0 . 02 , window stride = 0 . 01 sampling rate , samples = wav . read ( audio ) win length = int ( window size * sampling rate ) hop length = int ( window stride * sampling rate ) n fft = win length d = librosa . core . stft ( samples , n fft = n fft , hop length = hop length , win length = win length ) mag = np . abs ( d ) log mag = np . log1p ( mag ) log mag = preprocessing . scale ( log mag ) return log mag
feat , n = 2 numframes = len ( feat ) feat = numpy . concatenate ( ( [ feat [ 0 ] for i in range ( n ) ] , feat , [ feat [ 1 ] for i in range ( n ) ] ) ) denom = sum ( [ 2 * i * i for i in range ( 1 , n + 1 ) ] ) dfeat = [ ] for j in range ( numframes ) : dfeat . append ( numpy . sum ( [ n * feat [ n + j + n ] for n in range ( 1 * n , n + 1 ) ] , axis = 0 ) / denom ) return dfeat
signal , samplerate = 16000 , win length = 0 . 025 , win step = 0 . 01 , filters num = 26 , nfft = 512 , low freq = 0 , high freq = none , pre emphasis coeff = 0 . 97 feat , energy = fbank ( signal , samplerate , win length , win step , filters num , nfft , low freq , high freq , pre emphasis coeff ) return numpy . log ( feat )
hz return 2595 * numpy . log10 ( 1 + hz / 700 . 0 )
mel return 700 * ( 10 ** ( mel / 2595 . 0 ) 1 )
frames , nfft return 1 . 0 / nfft * numpy . square ( spectrum magnitude ( frames , nfft ) )
c str ' ' ' \u5c06\u6c49\u5b57\u8f6c\u5316\u6210\u6570\u5b57 ' ' ' if c str == ' ' : return u ' 0 ' src = u ' \u70b9\u96f6\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d ' dst = u ' . 0123456789 ' for i , c in enumerate ( src ) : c str = c str . replace ( c , dst [ i ] ) return c str ' ' ' \u5c06\u6c49\u5b57\u8f6c\u5316\u6210\u6570\u5b57 ' ' ' if c str == ' ' : return u ' 0 ' src = u ' \u70b9\u96f6\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d ' dst = u ' . 0123456789 ' for i , c in enumerate ( src ) : c str = c str . replace ( c , dst [ i ] ) return c str
c str gewei = get gewei ( c str ) shiwei = get shiwei ( c str ) baiwei = get baiwei ( c str ) qianwei = get qianwei ( c str ) c str = qianwei + baiwei + shiwei + gewei return c str gewei = get gewei ( c str ) shiwei = get shiwei ( c str ) baiwei = get baiwei ( c str ) qianwei = get qianwei ( c str ) c str = qianwei + baiwei + shiwei + gewei return c str
c str if check whether special ( c str ) : return c2n ( c str ) else : return get complex ( c str r if check whether special ( c str ) : return c2n ( c str ) else : return get complex ( c str )
self , string if self . mode == ' digit2char ' : return convert digit2 character ( string ) else : return convert character2 digit ( string , string if self . mode == ' digit2char ' : return convert digit2 character ( string ) else : return convert character2 digit ( string )
string ' ' ' main function to be called for converting digits into characters in a sentence ' ' ' return prep string ( string ng ' ' ' main function to be called for converting digits into characters in a sentence ' ' ' return prep string ( string )
string return prep string ( string ng return prep string ( string )
s assert s . dtype == tf . float32 squared s = tf . reduce sum ( tf . square ( s ) , axis = 2 , keep dims = true ) normed s = tf . norm ( s , axis = 2 , keep dims = true ) v = squared s / ( 1 + squared s ) / normed s * s assert v . get shape ( ) == s . get shape ( ) return v
self return self . num capsule return self . num capsules
name , obj with open ( name + ' . pkl ' , ' wb ' ) as f : pickle . dump ( obj , f , pickle . highest protocol , obj with open ( name + ' . pkl ' , ' wb ' ) as f : pickle . dump ( obj , f , pickle . highest protocol )
dic , key if not dic . has key ( key ) : dic [ key ] = 0 dic [ key ] += 1 return di , key if not dic . has key ( key ) : dic [ key ] = 0 dic [ key ] += 1 return dic
self , feature dir , label dir , mode , level return load batched data ( feature dir , label dir , batch size , mode , level , feature dir , label dir , mode , level return load batched data ( feature dir , label dir , batch size , mode , level )
self , feature dir , label dir , mode , level return load batched data ( feature dir , label dir , batch size , mode , level , feature dir , label dir , mode , level return load batched data ( feature dir , label dir , batch size , mode , level )
self return ( self . format + not supported exception . arch error ) . format ( * self . message return ( self . format + not supported exception . arch error ) . format ( * self . message )
self , serializer , identifier , as pointer assert isinstance ( serializer , program serializer ) assert isinstance ( identifier , str ) assert isinstance ( as pointer , bool ) serializer . append format ( " struct {0} " , self . name ) if as pointer : serializer . append ( " * " ) serializer . append ( identifier , serializer , identifier , as pointer assert isinstance ( serializer , program serializer ) assert isinstance ( identifier , str ) assert isinstance ( as pointer , bool ) serializer . append format ( " struct {0} " , self . name ) if as pointer : serializer . append ( " * " ) serializer . append ( identifier )
self return self . hlir type . length * return self . hlir type . length * 8
self , name assert isinstance ( name , str ) for f in self . fields : assert isinstance ( f , ebpf field ) if f . name == name : return f raise compilation exception ( true , " could not locate field {0} . {1} " , self , name , name assert isinstance ( name , str ) for f in self . fields : assert isinstance ( f , ebpf field ) if f . name == name : return f raise compilation exception ( true , " could not locate field {0} . {1} " , self , name )
self , serializer assert isinstance ( serializer , program serializer ) serializer . block start ( ) serializer . emit indent ( ) serializer . append line ( " . valid = 0 " ) serializer . block end ( false , serializer assert isinstance ( serializer , program serializer ) serializer . block start ( ) serializer . emit indent ( ) serializer . append line ( " . valid = 0 " ) serializer . block end ( false )
self , serializer , identifier , size assert isinstance ( serializer , program serializer ) serializer . append format ( " struct {0} {1}[{2}] " , self . name , identifier , size , serializer , identifier , size assert isinstance ( serializer , program serializer ) serializer . append format ( " struct {0} {1}[{2}] " , self . name , identifier , size )
self self . current indent += self . indent amoun self . current indent += self . indent amount
self self . current indent = self . indent amount if self . current indent < 0 : raise compilation exception ( true , " negative indentation level " self . current indent = self . indent amount if self . current indent < 0 : raise compilation exception ( true , " negative indentation level " )
self return self . progra return self . program
self self . append ( " " self . append ( " " )
self self . program += self . eo self . program += self . eol
self , string self . program += str ( string , string self . program += str ( string )
self , format , * args string = format . format ( * args ) self . append ( string , format , * args string = format . format ( * args ) self . append ( string )
self , string self . append ( string ) self . newline ( , string self . append ( string ) self . newline ( )
self self . program += " " * self . current inden self . program += " " * self . current indent
self self . append ( " { " ) self . newline ( ) self . increase indent ( self . append ( " { " ) self . newline ( ) self . increase indent ( )
self , add newline self . decrease indent ( ) self . emit indent ( ) self . append ( " } " ) if add newline : self . newline ( , add newline self . decrease indent ( ) self . emit indent ( ) self . append ( " } " ) if add newline : self . newline ( )
self , serializer serializer . emit indent ( ) serializer . append format ( " /* no arguments for {0} */ " , self . name ) serializer . newline ( , serializer serializer . emit indent ( ) serializer . append format ( " /* no arguments for {0} */ " , self . name ) serializer . newline ( )
self , call , args , program size = none for a in args : if a is none : continue if size is none : size = a elif a != size : program . emit warning ( " {0}: arguments do not have the same size {1} and {2} " , call , size , a ) return siz , call , args , program size = none for a in args : if a is none : continue if size is none : size = a elif a != size : program . emit warning ( " {0}: arguments do not have the same size {1} and {2} " , call , size , a ) return size
self , arguments , caller , data container , program result = [ ] for a in arguments : t = arg info ( a , caller , data container , program ) result . append ( t ) return resul , arguments , caller , data container , program result = [ ] for a in arguments : t = arg info ( a , caller , data container , program ) result . append ( t ) return result
self return self . widt return self . width
self , name , ebpf type self . type map [ name ] = ebpf typ , name , ebpf type self . type map [ name ] = ebpf type
self return self . widt return self . width
self if self . width <= 8 : return 1 elif self . width <= 16 : return 2 elif self . width <= 32 : return 4 else : return if self . width <= 8 : return 1 elif self . width <= 16 : return 2 elif self . width <= 32 : return 4 else : return 1
self , serializer assert isinstance ( serializer , program serializer ) serializer . append ( self . as string ( ) , serializer assert isinstance ( serializer , program serializer ) serializer . append ( self . as string ( ) )
self , serializer , identifier , size raise compilation exception ( true , " arrays of base type not expected in p4 " , serializer , identifier , size raise compilation exception ( true , " arrays of base type not expected in p4 " )
self , other assert ( isinstance ( other , node ) ) self . edges . add ( other , other assert ( isinstance ( other , node ) ) self . edges . add ( other )
self , node assert ( node not in self . nodes ) self . nodes [ node ] = node ( node , node assert ( node not in self . nodes ) self . nodes [ node ] = node ( node )
self , action return action . lineno < , action return action . lineno < 0
header instance assert isinstance ( header instance , p4 header instance ) return header instance . max index is not noner instance assert isinstance ( header instance , p4 header instance ) return header instance . max index is not none
self , format string , * message assert isinstance ( format string , str ) print ( " warning: " , format string . format ( * message ) , format string , * message assert isinstance ( format string , str ) print ( " warning: " , format string . format ( * message ) )
self , serializer self . config . serialize license ( serializer , self . license , serializer self . config . serialize license ( serializer , self . license )
self , base assert isinstance ( base , str ) base += " " + str ( self . unique name counter ) self . unique name counter += 1 return base
self , serializer assert isinstance ( serializer , program serializer . program serializer ) for t in self . tables : t . serialize ( serializer , self ) for c in self . counters : c . serialize ( serializer , self , serializer assert isinstance ( serializer , program serializer . program serializer ) for t in self . tables : t . serialize ( serializer , self ) for c in self . counters : c . serialize ( serializer , self )
self , serializer assert isinstance ( serializer , program serializer . program serializer ) serializer . emit indent ( ) serializer . append format ( " struct {0} {1} " , self . headers struct type name , self . header struct name , serializer assert isinstance ( serializer , program serializer . program serializer ) serializer . emit indent ( ) serializer . append format ( " struct {0} {1} " , self . headers struct type name , self . header struct name )
self , serializer self . deparser . serialize ( serializer , self , serializer self . deparser . serialize ( serializer , self )
self , name assert isinstance ( name , str ) for h in self . stacks : if h . name == name : assert isinstance ( h , ebpf instance . ebpf header stack ) return h raise compilation exception ( true , " could not locate header stack named {0} " , name , name assert isinstance ( name , str ) for h in self . stacks : if h . name == name : assert isinstance ( h , ebpf instance . ebpf header stack ) return h raise compilation exception ( true , " could not locate header stack named {0} " , name )
self , name assert isinstance ( name , str ) for h in self . headers : if h . name == name : assert isinstance ( h , ebpf instance . ebpf header ) return h raise compilation exception ( true , " could not locate header instance named {0} " , name , name assert isinstance ( name , str ) for h in self . headers : if h . name == name : assert isinstance ( h , ebpf instance . ebpf header ) return h raise compilation exception ( true , " could not locate header instance named {0} " , name )
self , name assert isinstance ( name , str ) for h in self . headers : if h . name == name : return h for h in self . metadata : if h . name == name : return h raise compilation exception ( true , " could not locate instance named {0} " , name , name assert isinstance ( name , str ) for h in self . headers : if h . name == name : return h for h in self . metadata : if h . name == name : return h raise compilation exception ( true , " could not locate instance named {0} " , name )
self , p4action assert isinstance ( p4action , p4 action ) for a in self . actions : if a . name == p4action . name : return a new action = ebpf action . builtin action ( p4action ) self . actions . append ( new action ) return new actio , p4action assert isinstance ( p4action , p4 action ) for a in self . actions : if a . name == p4action . name : return a new action = ebpf action . builtin action ( p4action ) self . actions . append ( new action ) return new action
self , name assert isinstance ( name , str ) for t in self . tables : if t . name == name : return t raise compilation exception ( true , " could not locate table named {0} " , name , name assert isinstance ( name , str ) for t in self . tables : if t . name == name : return t raise compilation exception ( true , " could not locate table named {0} " , name )
self , name assert isinstance ( name , str ) for t in self . counters : if t . name == name : return t raise compilation exception ( true , " could not locate counters named {0} " , name , name assert isinstance ( name , str ) for t in self . counters : if t . name == name : return t raise compilation exception ( true , " could not locate counters named {0} " , name )
self , name assert isinstance ( name , str ) for c in self . conditionals : if c . name == name : return c raise compilation exception ( true , " could not locate conditional named {0} " , name , name assert isinstance ( name , str ) for c in self . conditionals : if c . name == name : return c raise compilation exception ( true , " could not locate conditional named {0} " , name )
self , serializer todo = set ( ) for e in self . entry points : todo . add ( e ) self . generate pipeline internal ( serializer , todo , self . egress entry ) todo = set ( ) todo . add ( self . egress entry ) self . generate pipeline internal ( serializer , todo , none , serializer todo = set ( ) for e in self . entry points : todo . add ( e ) self . generate pipeline internal ( serializer , todo , self . egress entry ) todo = set ( ) todo . add ( self . egress entry ) self . generate pipeline internal ( serializer , todo , none )
self , serializer , identifier , as pointer raise compilation exception ( true , " method must be overridden " , serializer , identifier , as pointer raise compilation exception ( true , " method must be overridden " )
self , serializer , identifier , size raise compilation exception ( true , " method must be overridden " , serializer , identifier , size raise compilation exception ( true , " method must be overridden " )
self return " " return " "
self , serializer , table name , key , value serializer . append format ( " {0} = bpf map lookup elem(&{1} , &{2}); " , value , table name , key , serializer , table name , key , value serializer . append format ( " {0} = bpf map lookup elem(&{1} , &{2}); " , value , table name , key )
self , serializer , table name , key , value serializer . append format ( " bpf map update elem(&{0} , &{1} , &{2} , bpf any); " , table name , key , value , serializer , table name , key , value serializer . append format ( " bpf map update elem(&{0} , &{1} , &{2} , bpf any); " , table name , key , value )
self , serializer , table name , key , value serializer . append format ( " {0} . update(&{1} , &{2}); " , table name , key , value , serializer , table name , key , value serializer . append format ( " {0} . update(&{1} , &{2}); " , table name , key , value )
self , serializer pas , serializer pass
self , serializer pas , serializer pass
self , serializer , license string assert isinstance ( serializer , program serializer ) pas , serializer , license string assert isinstance ( serializer , program serializer ) pass
self , program if self . hlircounter . instance count is not none : return self . hlircounter . instance count if self . auto increment : return self . get table ( program ) . size program . emit warning ( " {0} does not specify a max size; using 1024 " , self . hlircounter ) return 102 , program if self . hlircounter . instance count is not none : return self . hlircounter . instance count if self . auto increment : return self . get table ( program ) . size program . emit warning ( " {0} does not specify a max size; using 1024 " , self . hlircounter ) return 1024
self , serializer assert isinstance ( serializer , program serializer ) self . type . declare ( serializer , self . name , false , serializer assert isinstance ( serializer , program serializer ) self . type . declare ( serializer , self . name , false )
self , serializer assert isinstance ( serializer , program serializer ) if self . initializer is none : self . type . emit initializer ( serializer ) else : for key in self . initializer . keys ( ) : serializer . append format ( " . {0} = {1} , " , key , self . initializer [ key ] , serializer assert isinstance ( serializer , program serializer ) if self . initializer is none : self . type . emit initializer ( serializer ) else : for key in self . initializer . keys ( ) : serializer . append format ( " . {0} = {1} , " , key , self . initializer [ key ] )
self , serializer assert isinstance ( serializer , program serializer ) self . basetype . declare array ( serializer , self . name , self . array size , serializer assert isinstance ( serializer , program serializer ) self . basetype . declare array ( serializer , self . name , self . array size )
op if op == " not " : return " ! " elif op == " or " : return " || " elif op == " and " : return " && " return of op == " not " : return " ! " elif op == " or " : return " || " elif op == " and " : return " && " return op
self , serializer assert isinstance ( serializer , program serializer ) ftype = self . field . type serializer . emit indent ( ) ftype . declare ( serializer , self . key field name , false ) serializer . end of statement ( true , serializer assert isinstance ( serializer , program serializer ) ftype = self . field . type serializer . emit indent ( ) ftype . declare ( serializer , self . key field name , false ) serializer . end of statement ( true )
field assert isinstance ( field , ebpf table key field ) return field . field . type . alignment ( d assert isinstance ( field , ebpf table key field ) return field . field . type . alignment ( )
self , serializer , key name , program serializer . emit indent ( ) serializer . append line ( " /* construct key */ " ) for f in self . fields : f . serialize construction ( key name , serializer , program , serializer , key name , program serializer . emit indent ( ) serializer . append line ( " /* construct key */ " ) for f in self . fields : f . serialize construction ( key name , serializer , program )
self , serializer assert isinstance ( serializer , program serializer ) self . key . serialize type ( serializer , self . key type name , serializer assert isinstance ( serializer , program serializer ) self . key . serialize type ( serializer , self . key type name )
self , * args if self . verbose : print ( * args , * args if self . verbose : print ( * args )
self return ip address ( self . ipaddress return ip address ( self . ipaddress )
self , endpoint assert isinstance ( endpoint , endpoint ) self . endpoints . append ( endpoint ) endpoint . set parent ( self , endpoint assert isinstance ( endpoint , endpoint ) self . endpoints . append ( endpoint ) endpoint . set parent ( self )
self nsname = self . get ns name ( ) ns = net ns ( nsname ) return n nsname = self . get ns name ( ) ns = net ns ( nsname ) return ns
self ns = self . get ns ( ) ; ns . close ( ) ns . remove ( ns = self . get ns ( ) ; ns . close ( ) ns . remove ( )
self , command self . message ( self . name , " executing " , command ) nsn = self . get ns name ( ) pipe = ns popen ( nsn , command ) result = pipe . wait ( ) pipe . release ( ) return resul , command self . message ( self . name , " executing " , command ) nsn = self . get ns name ( ) pipe = ns popen ( nsn , command ) result = pipe . wait ( ) pipe . release ( ) return result
self , source , dest assert isinstance ( source , node ) assert isinstance ( dest , node ) interface name = " veth " + source . name + " " + dest . name return interface nam , source , dest assert isinstance ( source , node ) assert isinstance ( dest , node ) interface name = " veth " + source . name + " " + dest . name return interface name
self , ifname interfaces = self . ipr . link lookup ( ifname = ifname ) if len ( interfaces ) != 1 : raise exception ( " could not identify interface " + ifname ) ix = interfaces [ 0 ] assert isinstance ( ix , int ) return i , ifname interfaces = self . ipr . link lookup ( ifname = ifname ) if len ( interfaces ) != 1 : raise exception ( " could not identify interface " + ifname ) ix = interfaces [ 0 ] assert isinstance ( ix , int ) return ix
self self . message ( " deleting virtual network " ) for n in self . nodes : n . remove ( ) self . ipr . close ( self . message ( " deleting virtual network " ) for n in self . nodes : n . remove ( ) self . ipr . close ( )
self , node , method , args assert isinstance ( node , node ) assert isinstance ( args , list ) torun = file args . insert ( 0 , torun ) args . insert ( 1 , method ) return node . execute ( args , node , method , args assert isinstance ( node , node ) assert isinstance ( args , list ) torun = file args . insert ( 0 , torun ) args . insert ( 1 , method ) return node . execute ( args )
def compile ( " testprograms/simple . p4 " , " simple . c " ) network = simulated network ( ) network . instantiate ( ) network . prepare switch ( ) network . run ( ) network . delete ( ) os . remove ( " simple . c " compile ( " testprograms/simple . p4 " , " simple . c " ) network = simulated network ( ) network . instantiate ( ) network . prepare switch ( ) network . run ( ) network . delete ( ) os . remove ( " simple . c " )
filename return os . path . splitext ( os . path . basename ( filename ) ) [ 0 name return os . path . splitext ( os . path . basename ( filename ) ) [ 0 ]
def return os . getuid ( ) == return os . getuid ( ) == 0
def return read cpu range ( ' /sys/devices/system/cpu/online ' return read cpu range ( ' /sys/devices/system/cpu/online ' )
def return read cpu range ( ' /sys/devices/system/cpu/possible ' return read cpu range ( ' /sys/devices/system/cpu/possible ' )
candidates , pid res = lib . bcc procutils language ( pid ) language = ct . cast ( res , ct . c char p ) . value . decode ( ) return language if language in candidates else nonidates , pid res = lib . bcc procutils language ( pid ) language = ct . cast ( res , ct . c char p ) . value . decode ( ) return language if language in candidates else none
s , file = sys . stdout , nl = 1 buf = file . buffer if hasattr ( file , " buffer " ) else file buf . write ( s ) if nl : buf . write ( b " \ " ) file . flush ( )
self return " %d %s bytes " % ( self . size , " signed " if self . signed else " unsigned " return " %d %s bytes " % ( self . size , " signed " if self . signed else " unsigned " )
self return self . contex return self . context
self ctx array = ( ct . c void p * 1 ) ( ) ctx array [ 0 ] = ct . c void p ( self . context ) return lib . bcc usdt genargs ( ctx array , 1 ) . decode ( ctx array = ( ct . c void p * 1 ) ( ) ctx array [ 0 ] = ct . c void p ( self . context ) return lib . bcc usdt genargs ( ctx array , 1 ) . decode ( )
self probes = [ ] def add probe ( probe ) : probes . append ( usdt probe ( self . context , probe . contents ) ) lib . bcc usdt foreach ( self . context , usdt cb ( add probe ) ) return probe probes = [ ] def add probe ( probe ) : probes . append ( usdt probe ( self . context , probe . contents ) ) lib . bcc usdt foreach ( self . context , usdt cb ( add probe ) ) return probes
self , bpf probes = self . enumerate active probes ( ) for ( binpath , fn name , addr , pid ) in probes : bpf . attach uprobe ( name = binpath . decode ( ) , fn name = fn name . decode ( ) , addr = addr , pid = pid , bpf probes = self . enumerate active probes ( ) for ( binpath , fn name , addr , pid ) in probes : bpf . attach uprobe ( name = binpath . decode ( ) , fn name = fn name . decode ( ) , addr = addr , pid = pid )
self probes = [ ] def add probe ( binpath , fn name , addr , pid ) : probes . append ( ( binpath , fn name , addr , pid ) ) lib . bcc usdt foreach uprobe ( self . context , usdt probe cb ( add probe ) ) return probe probes = [ ] def add probe ( binpath , fn name , addr , pid ) : probes . append ( ( binpath , fn name , addr , pid ) ) lib . bcc usdt foreach uprobe ( self . context , usdt probe cb ( add probe ) ) return probes
i , w0 , w1 = none instr , skip = bpf decoder . decode ( i , w0 , w1 ) return " %4d: (%02x) %s " % ( i , w0 . opcode , instr ) , ski w0 , w1 = none instr , skip = bpf decoder . decode ( i , w0 , w1 ) return " %4d: (%02x) %s " % ( i , w0 . opcode , instr ) , skip
func name , bpfstr instr list = [ " disassemble of bpf program %s: " % ( func name ) ] instr list += disassemble str ( bpfstr ) return linesep . join ( instr list name , bpfstr instr list = [ " disassemble of bpf program %s: " % ( func name ) ] instr list += disassemble str ( bpfstr ) return linesep . join ( instr list )
cls , offset , size , enabled = false , bitoffset = none if not enabled : return " " if bitoffset is not none : return " [%d , %d +%d bit] " % ( offset , bitoffset , size ) return " [%d +%d] " % ( offset , size , offset , size , enabled = false , bitoffset = none if not enabled : return " " if bitoffset is not none : return " [%d , %d +%d bit] " % ( offset , bitoffset , size ) return " [%d +%d] " % ( offset , size )
map name , map obj , map type , sizeinfo = false map type name = get table type name ( map type ) return map decoder . decode map ( map name , map obj , map type name , sizeinfo = sizeinfo name , map obj , map type , sizeinfo = false map type name = get table type name ( map type ) return map decoder . decode map ( map name , map obj , map type name , sizeinfo = sizeinfo )
def global num open probes return num open probeglobal num open probes return num open probes
self , module , name module = assert is bytes ( module ) name = assert is bytes ( name ) addr = ct . c ulonglong ( ) if lib . bcc symcache resolve name ( self . cache , module , name , ct . byref ( addr ) ) < 0 : return 1 return addr . valu , module , name module = assert is bytes ( module ) name = assert is bytes ( name ) addr = ct . c ulonglong ( ) if lib . bcc symcache resolve name ( self . cache , module , name , ct . byref ( addr ) ) < 0 : return 1 return addr . value
cls t = cls . timespec ( ) if cls . clock gettime ( cls . clock monotonic , ct . byref ( t ) ) != 0 : errno = ct . get errno ( ) raise os error ( errno , os . strerror ( errno ) ) return t . tv sec * 1e9 + t . tv nsec
cls , program words headers = " " for header , keywords in cls . auto includes . items ( ) : for keyword in keywords : for word in program words : if keyword in word and header not in headers : headers += " #include <%s>\ " % header return headers
bin path def is exe ( fpath ) : return os . path . isfile ( fpath ) and os . access ( fpath , os . x ok ) fpath , fname = os . path . split ( bin path ) if fpath : if is exe ( bin path ) : return bin path else : for path in os . environ [ " path " ] . split ( os . pathsep ) : path = path . strip ( ' " ' ) exe file = os . path . join ( path , bin path ) if is exe ( exe file ) : return exe file return none
self , prog type = kprobe fns = [ ] for i in range ( 0 , lib . bpf num functions ( self . module ) ) : func name = lib . bpf function name ( self . module , i ) fns . append ( self . load func ( func name , prog type ) ) return fns
self , func name func name = assert is bytes ( func name ) if not lib . bpf function start ( self . module , func name ) : raise exception ( " unknown program %s " % func name ) start , = lib . bpf function start ( self . module , func name ) , size , = lib . bpf function size ( self . module , func name ) , return ct . string at ( start , size )
self , func name bpfstr = self . dump func ( func name ) return disassemble prog ( func name , bpfstr , func name bpfstr = self . dump func ( func name ) return disassemble prog ( func name , bpfstr )
self , table name , sizeinfo = false table obj = self [ table name ] table type = lib . bpf table type id ( self . module , table obj . map id ) return decode map ( table name , table obj , table type , sizeinfo = sizeinfo , table name , sizeinfo = false table obj = self [ table name ] table type = lib . bpf table type id ( self . module , table obj . map id ) return decode map ( table name , table obj , table type , sizeinfo = sizeinfo )
self , num new probes global num open probes if num open probes + num new probes > probe limit : raise exception ( " number of open probes would exceed global quota " , num new probes global num open probes if num open probes + num new probes > probe limit : raise exception ( " number of open probes would exceed global quota " )
self , name , fd global num open probes self . kprobe fds [ name ] = fd num open probes += , name , fd global num open probes self . kprobe fds [ name ] = fd num open probes += 1
self , name global num open probes del self . kprobe fds [ name ] num open probes = , name global num open probes del self . kprobe fds [ name ] num open probes = 1
self , name , fd global num open probes self . uprobe fds [ name ] = fd num open probes += , name , fd global num open probes self . uprobe fds [ name ] = fd num open probes += 1
self , name global num open probes del self . uprobe fds [ name ] num open probes = , name global num open probes del self . uprobe fds [ name ] num open probes = 1
self , name name = assert is bytes ( name ) return self . get syscall prefix ( ) + nam , name name = assert is bytes ( name ) return self . get syscall prefix ( ) + name
self , name name = assert is bytes ( name ) for prefix in self . syscall prefixes : if name . startswith ( prefix ) : return self . get syscall fnname ( name [ len ( prefix ) : ] ) return nam , name name = assert is bytes ( name ) for prefix in self . syscall prefixes : if name . startswith ( prefix ) : return self . get syscall fnname ( name [ len ( prefix ) : ] ) return name
self , event event = assert is bytes ( event ) ev name = b " p " + event . replace ( b " + " , b " " ) . replace ( b " . " , b " " ) self . detach kprobe event ( ev name , event event = assert is bytes ( event ) ev name = b " p " + event . replace ( b " + " , b " " ) . replace ( b " . " , b " " ) self . detach kprobe event ( ev name )
self , event event = assert is bytes ( event ) ev name = b " r " + event . replace ( b " + " , b " " ) . replace ( b " . " , b " " ) self . detach kprobe event ( ev name , event event = assert is bytes ( event ) ev name = b " r " + event . replace ( b " + " , b " " ) . replace ( b " . " , b " " ) self . detach kprobe event ( ev name )
libname libname = assert is bytes ( libname ) res = lib . bcc procutils which so ( libname , 0 ) if not res : return none libpath = ct . cast ( res , ct . c char p ) . value lib . bcc procutils free ( res ) return libpatame libname = assert is bytes ( libname ) res = lib . bcc procutils which so ( libname , 0 ) if not res : return none libpath = ct . cast ( res , ct . c char p ) . value lib . bcc procutils free ( res ) return libpath
category , event evt dir = os . path . join ( tracefs , " events " , category , event ) return os . path . isdir ( evt dir gory , event evt dir = os . path . join ( tracefs , " events " , category , event ) return os . path . isdir ( evt dir )
self , tp = b " " tp = assert is bytes ( tp ) if tp not in self . raw tracepoint fds : raise exception ( " raw tracepoint %s is not attached " % tp ) os . close ( self . raw tracepoint fds [ tp ] ) del self . raw tracepoint fds [ tp ]
@ if bpf . ksymname ( " bpf find raw tracepoint " ) != 1 or bpf . ksymname ( " bpf get raw tracepoint " ) != 1 : return true return fals bpf . ksymname ( " bpf find raw tracepoint " ) != 1 or bpf . ksymname ( " bpf get raw tracepoint " ) != 1 : return true return false
name , sym re return set ( [ name for ( name , ) in bpf . get user functions and addresses ( name , sym re ) ] , sym re return set ( [ name for ( name , ) in bpf . get user functions and addresses ( name , sym re ) ] )
self , name = b " " , sym = b " " , addr = none , pid = 1 name = assert is bytes ( name ) sym = assert is bytes ( sym ) ( path , addr ) = bpf . check path symbol ( name , sym , addr , pid ) ev name = self . get uprobe evname ( b " p " , path , addr , pid ) self . detach uprobe event ( ev name )
self , nonblocking = false trace = self . trace open ( nonblocking ) line = none try : line = trace . readline ( 1024 ) . rstrip ( ) except io error : pass return line
self , fmt = none while true : if fmt : fields = self . trace fields ( nonblocking = false ) if not fields : continue line = fmt . format ( * fields ) else : line = self . trace readline ( nonblocking = false ) print ( line ) sys . stdout . flush ( )
pid if pid < 0 and pid != 1 : pid = 1 if not pid in bpf . sym caches : bpf . sym caches [ pid ] = symbol cache ( pid ) return bpf . sym caches [ pid ]
addr , show module = false , show offset = false return bpf . sym ( addr , 1 , show module , show offset , false )
name return bpf . sym cache ( 1 ) . resolve name ( none , name )
self return len ( self . kprobe fds )
self return len ( self . uprobe fds )
self , timeout = 1 readers = ( ct . c void p * len ( self . perf buffers ) ) ( ) for i , v in enumerate ( self . perf buffers . values ( ) ) : readers [ i ] = v lib . perf reader poll ( len ( readers ) , readers , timeout )
self , timeout = 1 self . perf buffer poll ( timeout )
self return lib . bcc free memory ( return lib . bcc free memory ( )
modname try : lib . bcc buildsymcache add module ( bpf . bsymcache , modname . encode ( ) ) except exception as e : print ( " error adding module to build sym cache " + str ( e ) )
ttype try : return map type name [ ttype ] except key error : return " <unknown> "e try : return map type name [ ttype ] except key error : return " <unknown> "
self for key in self : # a map entry may be deleted in between discovering the key and # fetching the value , suppress such errors try : yield self [ key ] except key error : pas for key in self : # a map entry may be deleted in between discovering the key and # fetching the value , suppress such errors try : yield self [ key ] except key error : pass
self return [ item for item in self . iteritems ( ) return [ item for item in self . iteritems ( ) ]
self return [ value for value in self . itervalues ( ) return [ value for value in self . itervalues ( ) ]
self for k in self . keys ( ) : self . delitem ( k for k in self . keys ( ) : self . delitem ( k )
self for k in list ( self . keys ( ) ) : self [ k ] = self . leaf ( for k in list ( self . keys ( ) ) : self [ k ] = self . leaf ( )
self return self . iter ( return self . iter ( )
self return self . iter ( return self . iter ( )
self self . key = self . table . next ( self . key ) return self . ke self . key = self . table . next ( self . key ) return self . key
self , key key = self . normalize key ( key ) leaf = self . leaf ( ) res = lib . bpf update elem ( self . map fd , ct . byref ( key ) , ct . byref ( leaf ) , 0 ) if res < 0 : raise exception ( " could not clear item " , key key = self . normalize key ( key ) leaf = self . leaf ( ) res = lib . bpf update elem ( self . map fd , ct . byref ( key ) , ct . byref ( leaf ) , 0 ) if res < 0 : raise exception ( " could not clear item " )
self if ( self . fd is not none ) and ( self . fd >= 0 ) : os . close ( self . fd ) self . fd = non if ( self . fd is not none ) and ( self . fd >= 0 ) : os . close ( self . fd ) self . fd = none
self , data if self . event class == none : self . event class = self . get event class ( ) return ct . cast ( data , ct . pointer ( self . event class ) ) . contents
self , callback , page cnt = 8 , lost cb = none if page cnt & ( page cnt 1 ) != 0 : raise exception ( " perf buffer page cnt must be a power of two " ) for i in get online cpus ( ) : self . open perf buffer ( i , callback , page cnt , lost cb )
self , typ , config for i in get online cpus ( ) : self . open perf event ( i , typ , config )
self , key if isinstance ( self . leaf ( ) , ct . structure ) : raise index error ( " leaf must be an integer type for default sum functions " ) return self . s leaf ( sum ( self . getvalue ( key ) ) , key if isinstance ( self . leaf ( ) , ct . structure ) : raise index error ( " leaf must be an integer type for default sum functions " ) return self . s leaf ( sum ( self . getvalue ( key ) ) )
self , key if isinstance ( self . leaf ( ) , ct . structure ) : raise index error ( " leaf must be an integer type for default max functions " ) return self . s leaf ( max ( self . getvalue ( key ) ) , key if isinstance ( self . leaf ( ) , ct . structure ) : raise index error ( " leaf must be an integer type for default max functions " ) return self . s leaf ( max ( self . getvalue ( key ) ) )
self , key result = self . sum ( key ) return result . value / self . total cp , key result = self . sum ( key ) return result . value / self . total cpu
self , key if isinstance ( self . leaf ( ) , ct . structure ) : raise index error ( " leaf must be an integer type for default sum functions " ) return self . s leaf ( sum ( self . getvalue ( key ) ) , key if isinstance ( self . leaf ( ) , ct . structure ) : raise index error ( " leaf must be an integer type for default sum functions " ) return self . s leaf ( sum ( self . getvalue ( key ) ) )
self , key if isinstance ( self . leaf ( ) , ct . structure ) : raise index error ( " leaf must be an integer type for default max functions " ) return self . s leaf ( max ( self . getvalue ( key ) ) , key if isinstance ( self . leaf ( ) , ct . structure ) : raise index error ( " leaf must be an integer type for default max functions " ) return self . s leaf ( max ( self . getvalue ( key ) ) )
self , key result = self . sum ( key ) return result . value / self . total cp , key result = self . sum ( key ) return result . value / self . total cpu
self , stack id , resolve = none return stack trace . stack walker ( self [ self . key ( stack id ) ] , self . flags , resolve , stack id , resolve = none return stack trace . stack walker ( self [ self . key ( stack id ) ] , self . flags , resolve )
line parts = line . split ( ) return ( int ( parts [ 0 ] ) , parts [ 1 ] . strip ( ) parts = line . split ( ) return ( int ( parts [ 0 ] ) , parts [ 1 ] . strip ( ) )
syscall num return syscalls . get ( syscall num , b " [unknown: %d] " % syscall num )
val try : ival = int ( val ) except value error : raise argparse . argument type error ( " must be an integer " ) if ival < 0 : raise argparse . argument type error ( " must be positive " ) return ivatry : ival = int ( val ) except value error : raise argparse . argument type error ( " must be an integer " ) if ival < 0 : raise argparse . argument type error ( " must be positive " ) return ival
val ival = positive int ( val ) if ival == 0 : raise argparse . argument type error ( " must be nonzero " ) return ivaival = positive int ( val ) if ival == 0 : raise argparse . argument type error ( " must be nonzero " ) return ival
stack id return ( stack id < 0 ) and ( stack id != errno . efault k id return ( stack id < 0 ) and ( stack id != errno . efault )
signal , frame print ( al , frame print ( )
addr if args . annotations : return b . ksym ( addr ) + " [k] " . encode ( ) else : return b . ksym ( addr if args . annotations : return b . ksym ( addr ) + " [k] " . encode ( ) else : return b . ksym ( addr )
vec return [ " hi " , " timer " , " net tx " , " net rx " , " block " , " irq poll " , " tasklet " , " sched " , " hrtimer " , " rcu " ] [ vec return [ " hi " , " timer " , " net tx " , " net rx " , " block " , " irq poll " , " tasklet " , " sched " , " hrtimer " , " rcu " ] [ vec ]
cpu , data , size event = bpf [ " events " ] . event ( data ) print ( " % 14 . 6f % 6d %8 . 3f %s " % ( float ( event . timestamp start ) / 1000000000 , event . pid , float ( event . duration ) / 1000000 , event . query ) , data , size event = bpf [ " events " ] . event ( data ) print ( " % 14 . 6f % 6d %8 . 3f %s " % ( float ( event . timestamp start ) / 1000000000 , event . pid , float ( event . duration ) / 1000000 , event . query ) )
self , node return self . adjacency map . get ( node , set ( ) , node return self . adjacency map . get ( node , set ( ) )
self edges = [ ] for node , neighbors in self . adjacency map . items ( ) : for neighbor in neighbors : edges . append ( ( node , neighbor ) ) return edge edges = [ ] for node , neighbors in self . adjacency map . items ( ) : for neighbor in neighbors : edges . append ( ( node , neighbor ) ) return edges
self return self . adjacency map . keys ( return self . adjacency map . keys ( )
self , node1 , node2 return self . attributes map [ ( node1 , node2 ) , node1 , node2 return self . attributes map [ ( node1 , node2 ) ]
self , nodes graph = di graph ( ) for node in nodes : for neighbor in self . neighbors ( node ) : if neighbor in nodes : graph . add edge ( node , neighbor ) return grap , nodes graph = di graph ( ) for node in nodes : for neighbor in self . neighbors ( node ) : if neighbor in nodes : graph . add edge ( node , neighbor ) return graph
bpf , event handler bpf [ " events " ] . open perf buffer ( event handler ) while true : bpf . perf buffer poll ( ) if global . args . pid : return
signum return global . signum to signame . get ( signum , " unknown " )
def try : rc , buffer = initialize ( ) if rc : print ( buffer ) sys . exit ( 0 if global . args . ebpf else rc ) print header ( ) snoop ( buffer , print event ) except keyboard interrupt : print ( ) sys . exit ( ) return try : rc , buffer = initialize ( ) if rc : print ( buffer ) sys . exit ( 0 if global . args . ebpf else rc ) print header ( ) snoop ( buffer , print event ) except keyboard interrupt : print ( ) sys . exit ( ) return 0
val try : ival = float ( val ) except value error : raise argparse . argument type error ( " must be a float " ) if ival < 0 : raise argparse . argument type error ( " must be positive " ) return ivatry : ival = float ( val ) except value error : raise argparse . argument type error ( " must be a float " ) if ival < 0 : raise argparse . argument type error ( " must be positive " ) return ival
counts if args . sort == " all " : return ( counts [ 1 ] . rbytes + counts [ 1 ] . wbytes + counts [ 1 ] . reads + counts [ 1 ] . writes ) else : return getattr ( counts [ 1 ] , args . sort ts if args . sort == " all " : return ( counts [ 1 ] . rbytes + counts [ 1 ] . wbytes + counts [ 1 ] . reads + counts [ 1 ] . writes ) else : return getattr ( counts [ 1 ] , args . sort )
signal , frame print ( al , frame print ( )
event if not args . arguments : return " " return str . join ( " " , [ " 0x%x " % arg for arg in event . args [ : args . arguments ] ] t if not args . arguments : return " " return str . join ( " " , [ " 0x%x " % arg for arg in event . args [ : args . arguments ] ] )
kstack syms = [ ] for addr in kstack : s = b . ksym ( addr , show offset = true ) syms . append ( s ) return symck syms = [ ] for addr in kstack : s = b . ksym ( addr , show offset = true ) syms . append ( s ) return syms
def bpf check text = tmp file = named temporary file ( delete = false ) tmp file . close ( ) ; old stderr = dup ( 2 ) close ( 2 ) fd = open ( tmp file . name , o wronly ) try : t = bpf ( text = bpf check text ) success compile = true except : success compile = false close ( fd ) dup ( old stderr ) close ( old stderr ) unlink ( tmp file . name ) return success compile
val try : ival = int ( val ) except value error : raise argparse . argument type error ( " must be an integer " ) if ival < 0 : raise argparse . argument type error ( " must be positive " ) return ivatry : ival = int ( val ) except value error : raise argparse . argument type error ( " must be an integer " ) if ival < 0 : raise argparse . argument type error ( " must be positive " ) return ival
val ival = positive int ( val ) if ival == 0 : raise argparse . argument type error ( " must be nonzero " ) return ivaival = positive int ( val ) if ival == 0 : raise argparse . argument type error ( " must be nonzero " ) return ival
self , expr if expr is none : return expr for alias , subst in probe . aliases . items ( ) : expr = expr . replace ( alias , subst ) return exp , expr if expr is none : return expr for alias , subst in probe . aliases . items ( ) : expr = expr . replace ( alias , subst ) return expr
self , error raise value error ( " error parsing probe ' %s ' : %s " % ( self . raw spec , error ) , error raise value error ( " error parsing probe ' %s ' : %s " % ( self . raw spec , error ) )
self , expr types if len ( expr types ) == 0 : self . bail ( " no expr types specified " ) self . expr types = expr types . split ( ' , ' , expr types if len ( expr types ) == 0 : self . bail ( " no expr types specified " ) self . expr types = expr types . split ( ' , ' )
self , ident return re . sub ( r ' [^ a za z0 9 ] ' , ' ' , ident , ident return re . sub ( r ' [^ a za z0 9 ] ' , ' ' , ident )
self , string fname = " streq %d " % probe . streq index probe . streq index += 1 self . streq functions += % ( fname , string ) return fname
self , expr type return expr type == " char* " or expr type == " char * " , expr type return expr type == " char* " or expr type == " char * "
self , i if self . is string ( self . expr types [ i ] ) : return " struct string t v%d;\ " % i else : return " %s v%d;\ " % ( self . expr types [ i ] , i , i if self . is string ( self . expr types [ i ] ) : return " struct string t v%d;\ " % i else : return " %s v%d;\ " % ( self . expr types [ i ] , i )
self if self . type == " hist " : return " %s . increment(bpf log2l( key)); " % self . probe hash name else : return " %s . increment( key); " % self . probe hash nam if self . type == " hist " : return " %s . increment(bpf log2l( key)); " % self . probe hash name else : return " %s . increment( key); " % self . probe hash name
self , bpf self . bpf = bpf if self . probe type == " u " : return if self . is user : self . attach u ( ) else : self . attach k ( ) if self . entry probe required : self . attach entry probe ( , bpf self . bpf = bpf if self . probe type == " u " : return if self . is user : self . attach u ( ) else : self . attach k ( ) if self . entry probe required : self . attach entry probe ( )
self , v if " string t " in type ( v ) . name : return str ( v . s ) return str ( v , v if " string t " in type ( v ) . name : return str ( v . s ) return str ( v )
cls , mode , probability , count cls . mode = mode cls . probability = probability cls . count = coun , mode , probability , count cls . mode = mode cls . probability = probability cls . count = count
self return probe . errno mapping [ probe . mode return probe . errno mapping [ probe . mode ]
self chk = self . preds [ 0 ] [ 1 ] == 0 if not chk : return " " if probe . probability == 1 : early pred = " false " else : early pred = " bpf get prandom u32() > %s " % str ( int ( ( 1 << 32 ) * probe . probability ) ) enter = % early pred exit = """ /* * top level function clean up map */ m . delete(&pid); """ return enter if self . is entry else exit
self prog = self . get heading ( ) + prog = prog % ( self . get if top ( ) , self . prep , self . get entry logic ( ) ) return prog
self prog = self . get heading ( ) + prog = prog % ( self . get exit logic ( ) , self . get if top ( ) ) return prog
self pred = self . preds [ 0 ] [ 0 ] text = self . get heading ( ) + return text % ( self . prep , self . length , pred , probe . count , self . get err ( ) , self . length 1 , pred , probe . count , self . get err ( ) )
self self . prepare pred ( ) if self . preds [ 1 ] [ 1 ] == self . length 1 : return self . generate bottom ( ) return self . generate entry ( ) if self . is entry else self . generate exit ( self . prepare pred ( ) if self . preds [ 1 ] [ 1 ] == self . length 1 : return self . generate bottom ( ) return self . generate entry ( ) if self . is entry else self . generate exit ( )
self , bpf if self . is entry : bpf . attach kprobe ( event = self . event , fn name = self . func name ) else : bpf . attach kretprobe ( event = self . event , fn name = self . func name , bpf if self . is entry : bpf . attach kprobe ( event = self . event , fn name = self . func name ) else : bpf . attach kretprobe ( event = self . event , fn name = self . func name )
self text = % self . length return text
self self . bpf = bpf ( text = self . program ) for p in self . probes : p . attach ( self . bpf self . bpf = bpf ( text = self . program ) for p in self . probes : p . attach ( self . bpf )
self while true : try : self . bpf . perf buffer poll ( ) except keyboard interrupt : exit ( while true : try : self . bpf . perf buffer poll ( ) except keyboard interrupt : exit ( )
self self . create probes ( ) self . generate program ( ) self . attach probes ( ) self . main loop ( self . create probes ( ) self . generate program ( ) self . attach probes ( ) self . main loop ( )
string value = int ( string ) if value < 1 : msg = " value must be stricly positive , got %d " % ( value , ) raise argparse . argument type error ( msg ) return valung value = int ( string ) if value < 1 : msg = " value must be stricly positive , got %d " % ( value , ) raise argparse . argument type error ( msg ) return value
pid try : comm = open ( " /proc/%d/comm " % pid , " r " ) . read ( ) . rstrip ( ) return comm except io error : return str ( pid try : comm = open ( " /proc/%d/comm " % pid , " r " ) . read ( ) . rstrip ( ) return comm except io error : return str ( pid )
k return tcp session key ( pid = k . pid , laddr = inet ntop ( af inet , pack ( " i " , k . saddr ) ) , lport = k . lport , daddr = inet ntop ( af inet , pack ( " i " , k . daddr ) ) , dport = k . dport turn tcp session key ( pid = k . pid , laddr = inet ntop ( af inet , pack ( " i " , k . saddr ) ) , lport = k . lport , daddr = inet ntop ( af inet , pack ( " i " , k . daddr ) ) , dport = k . dport )
k return tcp session key ( pid = k . pid , laddr = inet ntop ( af inet6 , k . saddr ) , lport = k . lport , daddr = inet ntop ( af inet6 , k . daddr ) , dport = k . dport turn tcp session key ( pid = k . pid , laddr = inet ntop ( af inet6 , k . saddr ) , lport = k . lport , daddr = inet ntop ( af inet6 , k . daddr ) , dport = k . dport )
signal , frame print ( al , frame print ( )
errstr try : return abs ( int ( errstr ) ) except value error : pass try : return getattr ( errno , errstr ) except attribute error : raise argparse . argument type error ( " couldn ' t map %s to an errno " % errstr tr try : return abs ( int ( errstr ) ) except value error : pass try : return getattr ( errno , errstr ) except attribute error : raise argparse . argument type error ( " couldn ' t map %s to an errno " % errstr )
def if args . latency : print latency stats ( ) else : print count stats ( if args . latency : print latency stats ( ) else : print count stats ( )
cpu , data , size event = b [ " events " ] . event ( data ) print ( " % 18 . 9f sync() " % ( float ( event . ts ) / 1000000 ) , data , size event = b [ " events " ] . event ( data ) print ( " % 18 . 9f sync() " % ( float ( event . ts ) / 1000000 ) )
cpu , data , size event = b [ " events " ] . event ( data ) print ( " % 9s % 6d %s " % ( strftime ( " % h:% m:% s " ) , event . pid , event . str . decode ( ' utf 8 ' , ' replace ' ) ) , data , size event = b [ " events " ] . event ( data ) print ( " % 9s % 6d %s " % ( strftime ( " % h:% m:% s " ) , event . pid , event . str . decode ( ' utf 8 ' , ' replace ' ) ) )
def print ( " [%s] " % strftime ( " % h:% m:% s " ) ) latencies . print log2 hist ( " query latency (%s) " % ( " us " if args . microseconds else " ms " ) ) print ( " " ) latencies . clear ( print ( " [%s] " % strftime ( " % h:% m:% s " ) ) latencies . print log2 hist ( " query latency (%s) " % ( " us " if args . microseconds else " ms " ) ) print ( " " ) latencies . clear ( )
key if not library : return bpf . sym ( key [ 0 ] , 1 ) else : return " %s [%d] " % ( bpf . sym ( key [ 0 ] , key [ 1 ] ) , key [ 1 ] if not library : return bpf . sym ( key [ 0 ] , 1 ) else : return " %s [%d] " % ( bpf . sym ( key [ 0 ] , key [ 1 ] ) , key [ 1 ] )
val try : ival = int ( val ) except value error : raise argparse . argument type error ( " must be an integer " ) if ival < 0 : raise argparse . argument type error ( " must be positive " ) return ivatry : ival = int ( val ) except value error : raise argparse . argument type error ( " must be an integer " ) if ival < 0 : raise argparse . argument type error ( " must be positive " ) return ival
val ival = positive int ( val ) if ival == 0 : raise argparse . argument type error ( " must be nonzero " ) return ivaival = positive int ( val ) if ival == 0 : raise argparse . argument type error ( " must be nonzero " ) return ival
stack id return ( stack id < 0 ) and ( stack id != errno . efault k id return ( stack id < 0 ) and ( stack id != errno . efault )
signal , frame print ( al , frame print ( )
def bpf check text = tmp file = named temporary file ( delete = false ) tmp file . close ( ) ; old stderr = dup ( 2 ) close ( 2 ) fd = open ( tmp file . name , o wronly ) try : t = bpf ( text = bpf check text ) success compile = true except : success compile = false close ( fd ) dup ( old stderr ) close ( old stderr ) unlink ( tmp file . name ) return success compile
cpu , data , size event = b [ " events " ] . event ( data ) samples [ event . ts ] = { } samples [ event . ts ] [ ' cpu ' ] = event . cpu samples [ event . ts ] [ ' len ' ] = event . le , data , size event = b [ " events " ] . event ( data ) samples [ event . ts ] = { } samples [ event . ts ] [ ' cpu ' ] = event . cpu samples [ event . ts ] [ ' len ' ] = event . len
n return ( ( 1 << n ) 1 ) << ( 32 n turn ( ( 1 << n ) 1 ) << ( 32 n )
subnets template = bpf = ' ' for i , s in enumerate ( subnets ) : branch = template branch = branch . replace ( " net addr " , str ( socket . htonl ( s [ 1 ] ) ) ) branch = branch . replace ( " net mask " , str ( socket . htonl ( s [ 2 ] ) ) ) branch = branch . replace ( " pos " , str ( i ) ) bpf += branch return bpf
val try : ival = int ( val ) except value error : raise argparse . argument type error ( " must be an integer " ) if ival < 0 : raise argparse . argument type error ( " must be positive " ) return ivatry : ival = int ( val ) except value error : raise argparse . argument type error ( " must be an integer " ) if ival < 0 : raise argparse . argument type error ( " must be positive " ) return ival
stack id return ( stack id < 0 ) and ( stack id != errno . efault k id return ( stack id < 0 ) and ( stack id != errno . efault )
signal , frame print ( al , frame print ( )
category , event tpoint = " %s:%s " % ( category , event ) if not args . filter or fnmatch . fnmatch ( tpoint , args . filter ) : print ( tpoint ) if args . verbosity > 0 : print tpoint format ( category , event gory , event tpoint = " %s:%s " % ( category , event ) if not args . filter or fnmatch . fnmatch ( tpoint , args . filter ) : print ( tpoint ) if args . verbosity > 0 : print tpoint format ( category , event )
self , size self . count += 1 self . size += siz , size self . count += 1 self . size += size
command p = subprocess . popen ( command . split ( ) , stdout = subprocess . pipe , stderr = subprocess . stdout ) return iter ( p . stdout . readline , b ' ' and p = subprocess . popen ( command . split ( ) , stdout = subprocess . pipe , stderr = subprocess . stdout ) return iter ( p . stdout . readline , b ' ' )
command p = subprocess . popen ( command . split ( ) ) return p . piand p = subprocess . popen ( command . split ( ) ) return p . pid
self return self . type == " t " or ( self . type == " p " and self . library == " " return self . type == " t " or ( self . type == " p " and self . library == " " )
signal , frame print ( al , frame print ( )
self , comm , pid print ( " %s [%d] " % ( comm , pid ) , comm , pid print ( " %s [%d] " % ( comm , pid ) )
pid try : return open ( " /proc/%d/comm " % pid ) . read ( ) . strip ( ) except : return " [unknown] "try : return open ( " /proc/%d/comm " % pid ) . read ( ) . strip ( ) except : return " [unknown] "
cpu , data , size print event ( cpu , data , size , " write/ send " , " perf ssl write " , data , size print event ( cpu , data , size , " write/ send " , " perf ssl write " )
cpu , data , size print event ( cpu , data , size , " read/ recv " , " perf ssl read " , data , size print event ( cpu , data , size , " read/ recv " , " perf ssl read " )
def print ( " usage: %s [interval [count]] " % argv [ 0 ] ) exit ( print ( " usage: %s [interval [count]] " % argv [ 0 ] ) exit ( )
self return self . python format == " " return self . python format == " "
self , error raise value error ( " error in probe ' %s ' : %s " % ( self . raw probe , error ) , error raise value error ( " error in probe ' %s ' : %s " % ( self . raw probe , error ) )
self , string fname = " streq %d " % probe . streq index probe . streq index += 1 self . streq functions += % ( fname , string ) return fname
self , idx , fields field type = self . types [ idx ] if field type == " s " : ptype = ct . c char * self . string size else : ptype = probe . p type [ field type ] fields . append ( ( " v%d " % idx , ptype ) , idx , fields field type = self . types [ idx ] if field type == " s " : ptype = ct . c char * self . string size else : ptype = probe . p type [ field type ] fields . append ( ( " v%d " % idx , ptype ) )
cls , timestamp ns offset = 1e 9 * ( timestamp ns cls . first ts ) if cls . print unix timestamp : return " % . 6f " % ( offset + cls . first ts real ) else : return " % . 6f " % offse , timestamp ns offset = 1e 9 * ( timestamp ns cls . first ts ) if cls . print unix timestamp : return " % . 6f " % ( offset + cls . first ts real ) else : return " % . 6f " % offset
self if self . probe type == ' p ' or self . probe type == ' r ' : return self . function elif self . probe type == ' u ' : return self . usdt name else : # self . probe type == ' t ' return self . tp even if self . probe type == ' p ' or self . probe type == ' r ' : return self . function elif self . probe type == ' u ' : return self . usdt name else : # self . probe type == ' t ' return self . tp event
self , bpf if self . probe type == " r " : bpf . attach kretprobe ( event = self . function , fn name = self . probe name ) elif self . probe type == " p " : bpf . attach kprobe ( event = self . function , fn name = self . probe name , bpf if self . probe type == " r " : bpf . attach kretprobe ( event = self . function , fn name = self . probe name ) elif self . probe type == " p " : bpf . attach kprobe ( event = self . function , fn name = self . probe name )
self probe . configure ( self . args ) self . probes = [ ] for probe spec in self . args . probes : self . probes . append ( probe ( probe spec , self . args . string size , self . args . kernel stack , self . args . user stack ) probe . configure ( self . args ) self . probes = [ ] for probe spec in self . args . probes : self . probes . append ( probe ( probe spec , self . args . string size , self . args . kernel stack , self . args . user stack ) )
signal , frame print ( al , frame print ( )
def result = { } for line in open ( ' /proc/meminfo ' ) : k = line . split ( ' : ' , 3 ) v = k [ 1 ] . split ( ) result [ k [ 0 ] ] = int ( v [ 0 ] ) return resulresult = { } for line in open ( ' /proc/meminfo ' ) : k = line . split ( ' : ' , 3 ) v = k [ 1 ] . split ( ) result [ k [ 0 ] ] = int ( v [ 0 ] ) return result
sys switcher = { sys shmget : " shmget " , sys shmat : " shmat " , sys shmdt : " shmdt " , sys shmctl : " shmctl " , } return switcher . get ( sys , " n/ a " switcher = { sys shmget : " shmget " , sys shmat : " shmat " , sys shmdt : " shmdt " , sys shmctl : " shmctl " , } return switcher . get ( sys , " n/ a " )
def print ( " usage: %s [ ch] { pts | /dev/ttydev} # try h for help " % argv [ 0 ] ) exit ( print ( " usage: %s [ ch] { pts | /dev/ttydev} # try h for help " % argv [ 0 ] ) exit ( )
cpu , data , size event = b [ " events " ] . event ( data ) print ( " %s " % event . buf [ 0 : event . count ] . decode ( ' utf 8 ' , ' replace ' ) , end = " " ) sys . stdout . flush ( , data , size event = b [ " events " ] . event ( data ) print ( " %s " % event . buf [ 0 : event . count ] . decode ( ' utf 8 ' , ' replace ' ) , end = " " ) sys . stdout . flush ( )
num probe limit = 1000 if num > probe limit : raise exception ( " maximum of %d probes allowed , attempted %d " % ( probe limit , num ) probe limit = 1000 if num > probe limit : raise exception ( " maximum of %d probes allowed , attempted %d " % ( probe limit , num ) )
self return self . type == b " t " or ( self . type == b " p " and self . library == b " " return self . type == b " t " or ( self . type == b " p " and self . library == b " " )
self counts = self . bpf [ " counts " ] for location , in list ( self . trace functions . items ( ) ) : counts [ counts . key ( location ) ] = counts . leaf ( counts = self . bpf [ " counts " ] for location , in list ( self . trace functions . items ( ) ) : counts [ counts . key ( location ) ] = counts . leaf ( )
pid , fd proc = " /proc/%d/fd/%d " % ( pid , fd ) try : return os . readlink ( proc ) except os error as err : return " n/ a " , fd proc = " /proc/%d/fd/%d " % ( pid , fd ) try : return os . readlink ( proc ) except os error as err : return " n/ a "
stack id return ( stack id < 0 ) and ( stack id != errno . efault k id return ( stack id < 0 ) and ( stack id != errno . efault )
flags , flag list str flags = [ ] for flag , bit in flag list : if flags & bit : str flags . append ( flag ) flags &= ~ bit if flags or not str flags : str flags . append ( ' 0x{:x} ' . format ( flags ) ) return str flags , flag list str flags = [ ] for flag , bit in flag list : if flags & bit : str flags . append ( flag ) flags &= ~ bit if flags or not str flags : str flags . append ( ' 0x{:x} ' . format ( flags ) ) return str flags
flags , flag list return ' | ' . join ( decode flags ( flags , flag list ) s , flag list return ' | ' . join ( decode flags ( flags , flag list ) )
flags str flags = [ ] if flags & ms mgc msk == ms mgc val : flags &= ~ ms mgc msk str flags . append ( ' ms mgc val ' ) str flags . extend ( decode flags ( flags , mount flags ) ) return ' | ' . join ( str flags s str flags = [ ] if flags & ms mgc msk == ms mgc val : flags &= ~ ms mgc msk str flags . append ( ' ms mgc val ' ) str flags . extend ( decode flags ( flags , mount flags ) ) return ' | ' . join ( str flags )
flags return decode flags ( flags , umount flags s return decode flags ( flags , umount flags )
retval try : return ' ' + errno . errorcode [ retval ] except key error : return str ( retval al try : return ' ' + errno . errorcode [ retval ] except key error : return str ( retval )
c try : return escape chars [ c ] except key error : if 0x20 <= c <= 0x7e : return chr ( c ) else : return ' \\\\x{:02x} ' . format ( c y : return escape chars [ c ] except key error : if 0x20 <= c <= 0x7e : return chr ( c ) else : return ' \\\\x{:02x} ' . format ( c )
s return ' " {} " ' . format ( ' ' . join ( escape character ( c ) for c in s ) turn ' " {} " ' . format ( ' ' . join ( escape character ( c ) for c in s ) )
pid try : comm = open ( " /proc/%d/comm " % pid , " r " ) . read ( ) return " %d %s " % ( pid , comm ) except io error : return str ( pid try : comm = open ( " /proc/%d/comm " % pid , " r " ) . read ( ) return " %d %s " % ( pid , comm ) except io error : return str ( pid )
def print ( " usage: mysqld latency pid [min ms] " ) exit ( print ( " usage: mysqld latency pid [min ms] " ) exit ( )
signal value , frame print ( al value , frame print ( )
def print ( " usage: %s [interval [count]] " % argv [ 0 ] ) exit ( print ( " usage: %s [interval [count]] " % argv [ 0 ] ) exit ( )
val try : ival = int ( val ) except value error : raise argparse . argument type error ( " must be an integer " ) if ival < 0 : raise argparse . argument type error ( " must be positive " ) return ivatry : ival = int ( val ) except value error : raise argparse . argument type error ( " must be an integer " ) if ival < 0 : raise argparse . argument type error ( " must be positive " ) return ival
val ival = positive int ( val ) if ival == 0 : raise argparse . argument type error ( " must be nonzero " ) return ivaival = positive int ( val ) if ival == 0 : raise argparse . argument type error ( " must be nonzero " ) return ival
signal , frame print ( al , frame print ( )
addr if args . annotations : return b . ksym ( addr ) + " [k] " else : return b . ksym ( addr if args . annotations : return b . ksym ( addr ) + " [k] " else : return b . ksym ( addr )
signal , frame print ( al , frame print ( )
signal , frame print ( al , frame print ( )
bpf , pid , info stack = " " if info . num frames <= 0 : return " ??? " for i in range ( 0 , info . num frames ) : addr = info . callstack [ i ] stack += " %s ; " % bpf . sym ( addr , pid , show offset = true ) return stac , pid , info stack = " " if info . num frames <= 0 : return " ??? " for i in range ( 0 , info . num frames ) : addr = info . callstack [ i ] stack += " %s ; " % bpf . sym ( addr , pid , show offset = true ) return stack
command p = subprocess . popen ( command . split ( ) , stdout = subprocess . pipe , stderr = subprocess . stdout ) return iter ( p . stdout . readline , b ' ' and p = subprocess . popen ( command . split ( ) , stdout = subprocess . pipe , stderr = subprocess . stdout ) return iter ( p . stdout . readline , b ' ' )
command p = subprocess . popen ( command . split ( ) ) return p . piand p = subprocess . popen ( command . split ( ) ) return p . pid
signal , frame print ( al , frame print ( )
addr print ( " " , end = " " ) if verbose : print ( " % 16x " % addr , end = " " ) print ( b . ksym ( addr , show offset = offset ) print ( " " , end = " " ) if verbose : print ( " % 16x " % addr , end = " " ) print ( b . ksym ( addr , show offset = offset ) )
addr dq = ' ' for i in range ( 0 , 4 ) : dq = dq + str ( addr & 0xff ) if ( i != 3 ) : dq = dq + ' . ' addr = addr >> 8 return d dq = ' ' for i in range ( 0 , 4 ) : dq = dq + str ( addr & 0xff ) if ( i != 3 ) : dq = dq + ' . ' addr = addr >> 8 return dq
def if args . latency : bpf [ " times " ] . clear ( ) else : bpf [ " counts " ] . clear ( ) if args . syscalls : if args . latency : bpf [ " systimes " ] . clear ( ) else : bpf [ " syscounts " ] . clear ( if args . latency : bpf [ " times " ] . clear ( ) else : bpf [ " counts " ] . clear ( ) if args . syscalls : if args . latency : bpf [ " systimes " ] . clear ( ) else : bpf [ " syscounts " ] . clear ( )
e " %s %s used=%d >%d max=%d >%d " % ( e . string1 , e . string2 , e . field1 , e . field3 , e . field2 , e . field4 %s %s used=%d >%d max=%d >%d " % ( e . string1 , e . string2 , e . field1 , e . field3 , e . field2 , e . field4 )
self self . targets = { } all pids = [ int ( pid ) for pid in os . listdir ( ' /proc ' ) if pid . isdigit ( ) ] for pid in all pids : try : comm = open ( ' /proc/%d/comm ' % pid ) . read ( ) . strip ( ) if comm in self . procnames : cmdline = open ( ' /proc/%d/cmdline ' % pid ) . read ( ) self . targets [ pid ] = cmdline . replace ( ' \\0 ' , ' ' ) except io error : continue
self text = return str . join ( ' ' , [ text % ( self . language , event ) for event in self . events ] )
self text = lang = self . language return str . join ( ' ' , [ text % ( lang , event , lang , event ) for event in self . events ] )
self return self . usdt return self . usdts
def print ( " usage: {0} <in ifdev> < cpu id> " . format ( sys . argv [ 0 ] ) ) print ( " e . g . : {0} eth0 2\ " . format ( sys . argv [ 0 ] ) ) exit ( 1 print ( " usage: {0} <in ifdev> < cpu id> " . format ( sys . argv [ 0 ] ) ) print ( " e . g . : {0} eth0 2\ " . format ( sys . argv [ 0 ] ) ) exit ( 1 )
def print ( " usage: {0} [ s] <ifdev> " . format ( sys . argv [ 0 ] ) ) print ( " s: use skb mode\ " ) print ( " e . g . : {0} eth0\ " . format ( sys . argv [ 0 ] ) ) exit ( 1 print ( " usage: {0} [ s] <ifdev> " . format ( sys . argv [ 0 ] ) ) print ( " s: use skb mode\ " ) print ( " e . g . : {0} eth0\ " . format ( sys . argv [ 0 ] ) ) exit ( 1 )
def print ( " usage: {0} <in ifdev> <out ifdev> " . format ( sys . argv [ 0 ] ) ) print ( " e . g . : {0} eth0 eth1\ " . format ( sys . argv [ 0 ] ) ) exit ( 1 print ( " usage: {0} <in ifdev> <out ifdev> " . format ( sys . argv [ 0 ] ) ) print ( " e . g . : {0} eth0 eth1\ " . format ( sys . argv [ 0 ] ) ) exit ( 1 )
s lst = [ ] for ch in s : hv = hex ( ord ( ch ) ) . replace ( ' 0x ' , ' ' ) if len ( hv ) == 1 : hv = ' 0 ' + hv lst . append ( hv ) return reduce ( lambda x , y : x + y , lst t = [ ] for ch in s : hv = hex ( ord ( ch ) ) . replace ( ' 0x ' , ' ' ) if len ( hv ) == 1 : hv = ' 0 ' + hv lst . append ( hv ) return reduce ( lambda x , y : x + y , lst )
def print ( " usage: %s [ i <if name>] " % argv [ 0 ] ) print ( " " ) print ( " try ' %s h ' for more options . " % argv [ 0 ] ) exit ( print ( " usage: %s [ i <if name>] " % argv [ 0 ] ) print ( " " ) print ( " try ' %s h ' for more options . " % argv [ 0 ] ) exit ( )
def cmd = ' cat /proc/self/maps | grep libc | awk \\ ' {print $6}\\ ' | uniq ' output = subprocess . check output ( cmd , shell = true ) if not isinstance ( output , str ) : output = output . decode ( ) return output . split ( ' \ ' ) [ 0 cmd = ' cat /proc/self/maps | grep libc | awk \\ ' {print $6}\\ ' | uniq ' output = subprocess . check output ( cmd , shell = true ) if not isinstance ( output , str ) : output = output . decode ( ) return output . split ( ' \ ' ) [ 0 ]
signal , frame print ( al , frame print ( )
def print ( " usage: %s [interval [count]] " % argv [ 0 ] ) exit ( print ( " usage: %s [interval [count]] " % argv [ 0 ] ) exit ( )
cpu , data , size event = ct . cast ( data , ct . pointer ( detection timestamp ) ) . contents print ( " % 26s %s %ld " % ( datetime . datetime . now ( ) , " ddos attack => nb of packets up to now : " , event . nb ddos packets ) , data , size event = ct . cast ( data , ct . pointer ( detection timestamp ) ) . contents print ( " % 26s %s %ld " % ( datetime . datetime . now ( ) , " ddos attack => nb of packets up to now : " , event . nb ddos packets ) )
cpu , data , size assert size >= ct . sizeof ( data ) event = ct . cast ( data , ct . pointer ( data ) ) . contents print ( " [%0d] %f: %x " % ( cpu , float ( event . ts ) / 1000000 , event . magic ) ) global counter counter += , data , size assert size >= ct . sizeof ( data ) event = ct . cast ( data , ct . pointer ( data ) ) . contents print ( " [%0d] %f: %x " % ( cpu , float ( event . ts ) / 1000000 , event . magic ) ) global counter counter += 1
self for i in range ( 0 , 100 ) : sleep ( 0 . 01 ) for key , leaf in self . stats . items ( ) : print ( " ptr %x: " % key . ptr , " stat1 (%d %d) " % ( leaf . stat1 [ 1 ] , leaf . stat1 [ 0 ] ) for i in range ( 0 , 100 ) : sleep ( 0 . 01 ) for key , leaf in self . stats . items ( ) : print ( " ptr %x: " % key . ptr , " stat1 (%d %d) " % ( leaf . stat1 [ 1 ] , leaf . stat1 [ 0 ] ) )
self b = bpf ( arg1 , arg2 , debug = 0 ) fn = b . load func ( " on packet " , bpf . socket filter ) bpf . attach raw socket ( fn , " eth0 " ) self . stats = b . get table ( " stats " , key , leaf b = bpf ( arg1 , arg2 , debug = 0 ) fn = b . load func ( " on packet " , bpf . socket filter ) bpf . attach raw socket ( fn , " eth0 " ) self . stats = b . get table ( " stats " , key , leaf )
self try : b = bpf ( text = ' bpf table( " percpu array " , u32 , u32 , stub , 1); ' ) except : raise unittest . skip test ( " per cpu unsupported on this kernel " try : b = bpf ( text = ' bpf table( " percpu array " , u32 , u32 , stub , 1); ' ) except : raise unittest . skip test ( " per cpu unsupported on this kernel " )
self b = bpf ( text = ) t1 = b [ " table1 " ] t1 [ ct . c int ( 0 ) ] = ct . c ulonglong ( 100 ) t1 [ ct . c int ( 127 ) ] = ct . c ulonglong ( 1000 ) for i , v in t1 . items ( ) : if i . value == 0 : self . assert equal ( v . value , 100 ) if i . value == 127 : self . assert equal ( v . value , 1000 ) self . assert equal ( len ( t1 ) , 128 )
self test prog1 = b = bpf ( text = test prog1 ) t = b [ " hash " ] self . assert equal ( t . flags , 1 ) ;
name path = find executable ( name ) if path is none : raise exception ( name + " : command not found " ) return pat path = find executable ( name ) if path is none : raise exception ( name + " : command not found " ) return path
major , minor version = distutils . version . loose version ( os . uname ( ) [ 2 ] ) . version if version [ 0 ] > major : return true if version [ 0 ] < major : return false if minor and version [ 1 ] < minor : return false return trur , minor version = distutils . version . loose version ( os . uname ( ) [ 2 ] ) . version if version [ 0 ] > major : return true if version [ 0 ] < major : return false if minor and version [ 1 ] < minor : return false return true
self text = b = bcc . bpf ( text = text ) sleep ( 1 ) total switches = 0 for k , v in b [ " switches " ] . items ( ) : total switches += v . value self . assert not equal ( 0 , total switches )
self text = b = bcc . bpf ( text = text ) subprocess . check output ( [ " /bin/ls " ] ) sleep ( 1 ) self . assert true ( " /bin/ls " in [ v . filename . decode ( ) for v in b [ " execs " ] . values ( ) ] )
self b = bpf ( src file = " test clang complex . c " , debug = 0 ) fn = b . load func ( " handle packet " , bpf . sched cls b = bpf ( src file = " test clang complex . c " , debug = 0 ) fn = b . load func ( " handle packet " , bpf . sched cls )
self text = b = bpf ( text = text , debug = 0 ) fn = b . load func ( " handle packet " , bpf . sched cls )
self text = b = bpf ( text = text , debug = 0 ) fn = b . load func ( " count foo " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " count tcp " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " count tcp " , bpf . kprobe )
self text = b = bpf ( text = text , debug = 0 ) fn = b . load func ( " do request " , bpf . kprobe )
self text = b = bpf ( text = text , debug = 0 ) fn = b . load func ( " do request " , bpf . kprobe )
self text = b = bpf ( text = text , debug = 0 )
self text = b = bpf ( text = text , debug = 0 ) fn = b . load func ( " trace entry " , bpf . kprobe )
self bpf ( text = )
self b = bpf ( text = ) fn = b . load func ( " trace entry1 " , bpf . kprobe ) fn = b . load func ( " trace entry2 " , bpf . kprobe )
self text = try : b = bpf ( text = text ) except : pass
self b = bpf ( text = ) b . attach kprobe ( event = b . get syscall fnname ( " open " ) , fn name = " do sys open " )
self b = bpf ( text = )
self b = bpf ( text = )
self b = bpf ( text = ) b . load func ( " test " , bpf . kprobe )
self b = bpf ( text = ) b . load func ( " test " , bpf . kprobe )
self b = bpf ( text = ) b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " trace entry " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " trace entry " , bpf . kprobe )
self text = b = bpf ( text = text ) self . assert equal ( ct . sizeof ( b [ " t3 " ] . leaf ) , 8 )
self b1 = bpf ( text = ) b2 = bpf ( text = """ bpf table( " extern " , int , int , table1 , 10); """ ) t = b2 [ " table1 " ]
self with self . assert raises ( exception ) : b = bpf ( text = )
self text = b = bpf ( text = text ) t1 = b [ " t1 " ] print ( t1 . key ( ) . remote ipv4 )
self text = b = bpf ( text = text ) t = b [ " act " ] self . assert equal ( len ( t ) , 32 ) ;
self bpf text = b = bpf ( text = bpf text ) b . load func ( " trace entry " , bpf . kprobe ) b . load func ( " trace exit " , bpf . kprobe )
self bpf text = b = bpf ( text = bpf text ) b . load func ( " trace entry " , bpf . kprobe ) b . load func ( " trace exit " , bpf . kprobe )
self bpf text = b = bpf ( text = bpf text ) b . load func ( " trace entry " , bpf . kprobe ) b . load func ( " trace exit " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) b . attach kprobe ( event = " vfs read " , fn name = " trace read entry " )
self text = r , w = os . pipe ( ) with redirect stderr ( to = w ) : bpf ( text = text ) r = os . fdopen ( r ) output = r . read ( ) expected warn = " warning: only %d %u %x %ld %lu %lx %lld %llu %llx %p %s conversion specifiers allowed " self . assert in ( expected warn , output ) r . close ( )
self text = r , w = os . pipe ( ) with redirect stderr ( to = w ) : bpf ( text = text ) r = os . fdopen ( r ) output = r . read ( ) expected warn = " warning: only %d %u %x %ld %lu %lx %lld %llu %llx %p %s conversion specifiers allowed " self . assert in ( expected warn , output ) r . close ( )
self text = r , w = os . pipe ( ) with redirect stderr ( to = w ) : bpf ( text = text ) r = os . fdopen ( r ) output = r . read ( ) expected warn = " warning: cannot use several %s conversion specifiers " self . assert in ( expected warn , output ) r . close ( )
self text = b1 = bpf ( text = text ) text = """ int do next(struct pt regs *ctx) { return 0;} """ b2 = bpf ( text = text ) fn = b2 . load func ( " do next " , bpf . kprobe ) c key = ct . c int ( 0 ) b1 [ " dummy " ] [ c key ] = ct . c int ( fn . fd ) b1 [ " dummy " ] . delitem ( c key ) ; with self . assert raises ( key error ) : b1 [ " dummy " ] [ c key ]
self text = with self . assert raises ( exception ) : b = bpf ( text = text )
self text = with self . assert raises ( exception ) : b = bpf ( text = text )
self text = b = bpf ( text = text )
self text = b = bpf ( text = text ) table = b [ ' table1 ' ] self . assert equal ( ct . sizeof ( table . key ) , 96 ) self . assert equal ( ct . sizeof ( table . leaf ) , 16 )
self text = b = bpf ( text = text )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . sched cls )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self b = bpf ( text = b ) b . attach kprobe ( event = b " htab map delete elem " , fn name = b " map delete " ) b . cleanup ( )
self b = bpf ( text = b ) if len ( b [ " testing " ] . items ( ) ) : st = b [ " testing " ] [ ct . c uint ( 0 ) ] self . assert equal ( st . a , 10 ) self . assert equal ( st . b , 20 )
self b1 = bpf ( text = ) with bpf ( text = """ bpf table( " extern " , int , int , table1 , 10); """ ) as b2 : t2 = b2 [ " table1 " ] t2 [ ct . c int ( 1 ) ] = ct . c int ( 10 ) self . assert equal ( len ( t2 ) , 10 ) t1 = b1 [ " table1 " ] self . assert equal ( t1 [ ct . c int ( 1 ) ] . value , 10 ) self . assert equal ( len ( t1 ) , 10 )
major , minor version = distutils . version . loose version ( os . uname ( ) [ 2 ] ) . version if version [ 0 ] > major : return true if version [ 0 ] < major : return false if minor and version [ 1 ] < minor : return false return trur , minor version = distutils . version . loose version ( os . uname ( ) [ 2 ] ) . version if version [ 0 ] > major : return true if version [ 0 ] < major : return false if minor and version [ 1 ] < minor : return false return true
self self . b = bpf ( text = ) self . b . attach kprobe ( event re = " ^vfs . * " , fn name = " wololo " )
self self . b1 = bpf ( text = ) self . b2 = bpf ( text = """ int count(void *ctx) { return 0; } """ )
self self . b = bpf ( text = )
self self . assert equal ( 2 , self . b . num open kprobes ( ) self . assert equal ( 2 , self . b . num open kprobes ( ) )
self self . b = bpf ( text = )
self with self . assert raises ( exception ) : self . b . attach kprobe ( event re = " . * " , fn name = " count " with self . assert raises ( exception ) : self . b . attach kprobe ( event re = " . * " , fn name = " count " )
self with self . assert raises ( exception ) : self . b . attach uprobe ( name = " c " , sym re = " . * " , fn name = " count " with self . assert raises ( exception ) : self . b . attach uprobe ( name = " c " , sym re = " . * " , fn name = " count " )
self self . b = bpf ( text = )
self with self . assert raises ( exception ) : self . b . attach kprobe ( event = " doesnotexist " , fn name = " count " with self . assert raises ( exception ) : self . b . attach kprobe ( event = " doesnotexist " , fn name = " count " )
self b = bpf ( text = ) for i in range ( 0 , 64 ) : for j in range ( 0 , random . randint ( 1 , 10 ) ) : try : del b [ " stub1 " ] [ c ulonglong ( 1 << i ) ] except : pass try : del b [ " stub2 " ] [ c ulonglong ( 1 << i ) ] except : pass b [ " hist1 " ] . print log2 hist ( ) b . cleanup ( )
self b = bpf ( text = ) for i in range ( 0 , 100 ) : time . sleep ( 0 . 01 ) b [ " hist1 " ] . print log2 hist ( ) b . cleanup ( )
self b = bpf ( text = ) def bucket sort ( buckets ) : buckets . sort ( ) return buckets for i in range ( 0 , 100 ) : time . sleep ( 0 . 01 ) b [ " mk hist " ] . print log2 hist ( " size " , " k 1 & k 2 " , section print fn = lambda bucket : " %3d %d " % ( bucket [ 0 ] , bucket [ 1 ] ) , bucket fn = lambda bucket : ( bucket . key 1 , bucket . key 2 ) , strip leading zero = true , bucket sort fn = bucket sort ) b . cleanup ( )
prefix i = 0 while true : iface = " {0}{1} " . format ( prefix , i ) if iface not in allocated interfaces : allocated interfaces . add ( iface ) return iface i += ix i = 0 while true : iface = " {0}{1} " . format ( prefix , i ) if iface not in allocated interfaces : allocated interfaces . add ( iface ) return iface i += 1
self self . b = bpf ( text = b ) self . b . attach kprobe ( event re = b " ^ " + self . b . get syscall prefix ( ) + b " bp . * " , fn name = b " hello " ) self . b . attach kretprobe ( event re = b " ^ " + self . b . get syscall prefix ( ) + b " bp . * " , fn name = b " goodbye " )
self self . b = bpf ( text = b " int empty(void *ctx) { return 0; } " self . b = bpf ( text = b " int empty(void *ctx) { return 0; } " )
self self . b . attach kprobe ( event re = b " ^tcp enter cwr . * " , fn name = b " empty " self . b . attach kprobe ( event re = b " ^tcp enter cwr . * " , fn name = b " empty " )
cls , op dst = random . randint ( 0 , 0xf ) src = random . randint ( 0 , 0xf ) offset = random . randint ( 0 , 0xffff ) imm = random . randint ( 0 , 0xffffffff ) return bpf instr ( op , dst , src , offset , imm , op dst = random . randint ( 0 , 0xf ) src = random . randint ( 0 , 0xf ) offset = random . randint ( 0 , 0xffff ) imm = random . randint ( 0 , 0xffffffff ) return bpf instr ( op , dst , src , offset , imm )
self b = bpf ( text = ) self . assert equal ( """ disassemble of bpf program test func: 0: (b7) r0 = 1 1: (95) exit """ , b . disassemble func ( " test func " ) ) self . assert equal ( """ layout of bpf map test map (type hash , fd 3 , id 0): struct { int a; short b; struct { int c:4; int d:8; } e; } key; unsigned long long value; """ , b . decode table ( " test map " ) )
self b = bpf ( text = ) self . assert equal ( b " \\xb7\\x00\\x00\\x00\\x01\\x00\\x00\\x00 " + b " \\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00 " , b . dump func ( " entry " ) )
major , minor version = distutils . version . loose version ( os . uname ( ) [ 2 ] ) . version if version [ 0 ] > major : return true if version [ 0 ] < major : return false if minor and version [ 1 ] < minor : return false return trur , minor version = distutils . version . loose version ( os . uname ( ) [ 2 ] ) . version if version [ 0 ] > major : return true if version [ 0 ] < major : return false if minor and version [ 1 ] < minor : return false return true
def cmd = ' cat /proc/self/maps | grep libc | awk \\ ' {print $6}\\ ' | uniq ' output = subprocess . check output ( cmd , shell = true ) if not isinstance ( output , str ) : output = output . decode ( ) return output . split ( ' \ ' ) [ 0 cmd = ' cat /proc/self/maps | grep libc | awk \\ ' {print $6}\\ ' | uniq ' output = subprocess . check output ( cmd , shell = true ) if not isinstance ( output , str ) : output = output . decode ( ) return output . split ( ' \ ' ) [ 0 ]
self sym = bpf . ksymname ( b " kmalloc " ) self . assert is not none ( sym ) self . assert not equal ( sym , 0 sym = bpf . ksymname ( b " kmalloc " ) self . assert is not none ( sym ) self . assert not equal ( sym , 0 )
self ( addr , aliases ) = self . grab sym ( ) sym = bpf . ksym ( int ( addr , 16 ) ) found = sym in aliases self . assert true ( found ( addr , aliases ) = self . grab sym ( ) sym = bpf . ksym ( int ( addr , 16 ) ) found = sym in aliases self . assert true ( found )
self subprocess . check output ( ' objcopy add gnu debuglink=dummy . debug dummy ' . split ( ) subprocess . check output ( ' objcopy add gnu debuglink=dummy . debug dummy ' . split ( ) )
self super ( test debuglink , self ) . tear down ( ) subprocess . check output ( ' rm dummy dummy . debug ' . split ( ) super ( test debuglink , self ) . tear down ( ) subprocess . check output ( ' rm dummy dummy . debug ' . split ( ) )
self self . resolve addr ( self . resolve addr ( )
self self . resolve name ( self . resolve name ( )
self super ( test buildid , self ) . tear down ( ) subprocess . check output ( ' rm dummy ' . split ( ) ) subprocess . check output ( ( ' rm /usr/lib/debug/ . build id/12 ' + ' /3456789abcdef0123456789abcdef012345678 . debug ' ) . split ( ) super ( test buildid , self ) . tear down ( ) subprocess . check output ( ' rm dummy ' . split ( ) ) subprocess . check output ( ( ' rm /usr/lib/debug/ . build id/12 ' + ' /3456789abcdef0123456789abcdef012345678 . debug ' ) . split ( ) )
self self . resolve addr ( self . resolve addr ( )
self self . resolve name ( self . resolve name ( )
self online cpus = get online cpus ( ) num cores = multiprocessing . cpu count ( ) self . assert equal ( len ( online cpus ) , num cores online cpus = get online cpus ( ) num cores = multiprocessing . cpu count ( ) self . assert equal ( len ( online cpus ) , num cores )
self candidates = [ " c " , " java " , " perl " , " php " , " node " , " ruby " , " python " ] language = detect language ( candidates , os . getpid ( ) ) self . assert equal ( language , " python " candidates = [ " c " , " java " , " perl " , " php " , " node " , " ruby " , " python " ] language = detect language ( candidates , os . getpid ( ) ) self . assert equal ( language , " python " )
major , minor version = distutils . version . loose version ( os . uname ( ) [ 2 ] ) . version if version [ 0 ] > major : return true if version [ 0 ] < major : return false if minor and version [ 1 ] < minor : return false return trur , minor version = distutils . version . loose version ( os . uname ( ) [ 2 ] ) . version if version [ 0 ] > major : return true if version [ 0 ] < major : return false if minor and version [ 1 ] < minor : return false return true
self if self . p : del ( self . p if self . p : del ( self . p )
self self . assert equal ( cfg . leaking amount , self . run leaker ( " malloc " ) self . assert equal ( cfg . leaking amount , self . run leaker ( " malloc " ) )
self self . assert equal ( cfg . leaking amount , self . run leaker ( " realloc " ) self . assert equal ( cfg . leaking amount , self . run leaker ( " realloc " ) )
self self . assert equal ( cfg . leaking amount , self . run leaker ( " posix memalign " ) self . assert equal ( cfg . leaking amount , self . run leaker ( " posix memalign " ) )
self self . assert equal ( cfg . leaking amount , self . run leaker ( " memalign " ) self . assert equal ( cfg . leaking amount , self . run leaker ( " memalign " ) )
self self . assert equal ( cfg . leaking amount , self . run leaker ( " pvalloc " ) self . assert equal ( cfg . leaking amount , self . run leaker ( " pvalloc " ) )
self self . assert equal ( cfg . leaking amount , self . run leaker ( " aligned alloc " ) self . assert equal ( cfg . leaking amount , self . run leaker ( " aligned alloc " ) )
self text = memlock limit = resource . getrlimit ( resource . rlimit memlock ) resource . setrlimit ( resource . rlimit memlock , ( 4096 , 4096 ) ) failed = 0 try : b = bpf ( text = text , allow rlimit = false ) except : failed = 1 self . assert equal ( failed , 1 ) b = bpf ( text = text , allow rlimit = true ) resource . setrlimit ( resource . rlimit memlock , memlock limit )
self b = bpf ( text = ) t = b [ " lru " ] for i in range ( 1 , 1032 ) : t [ ct . c int ( i ) ] = ct . c ulonglong ( i ) for i , v in t . items ( ) : self . assert equal ( v . value , i . value ) self . assert less ( len ( t ) , 1024 ) ;
self self . b = bpf ( text = b ) self . b . attach kprobe ( event re = self . b . get syscall prefix ( ) + b " bpf " , fn name = b " hello " ) self . b . attach kretprobe ( event re = self . b . get syscall prefix ( ) + b " bpf " , fn name = b " goodbye " , maxactive = 128 )
major , minor version = distutils . version . loose version ( os . uname ( ) [ 2 ] ) . version if version [ 0 ] > major : return true if version [ 0 ] < major : return false if minor and version [ 1 ] < minor : return false return trur , minor version = distutils . version . loose version ( os . uname ( ) [ 2 ] ) . version if version [ 0 ] > major : return true if version [ 0 ] < major : return false if minor and version [ 1 ] < minor : return false return true
self , command , timeout = 10 full command = tools dir + command self . assert equal ( 0 , # clean exit subprocess . call ( " timeout s kill %ds %s > /dev/null " % ( timeout , full command ) , shell = true ) , command , timeout = 10 full command = tools dir + command self . assert equal ( 0 , # clean exit subprocess . call ( " timeout s kill %ds %s > /dev/null " % ( timeout , full command ) , shell = true ) )
self , mod with open ( " /proc/modules " , " r " ) as mods : reg = re . compile ( " ^%s\\s " % mod ) for line in mods : if reg . match ( line ) : return 1 return , mod with open ( " /proc/modules " , " r " ) as mods : reg = re . compile ( " ^%s\\s " % mod ) for line in mods : if reg . match ( line ) : return 1 return 0
self self . run with duration ( " argdist . py v c ' p::do sys open() ' n 1 i 1 " self . run with duration ( " argdist . py v c ' p::do sys open() ' n 1 i 1 " )
self self . run with int ( " bashreadline . py " self . run with int ( " bashreadline . py " )
self self . run with int ( " biosnoop . py " self . run with int ( " biosnoop . py " )
self self . run with duration ( " biotop . py 1 1 " self . run with duration ( " biotop . py 1 1 " )
self self . run with int ( " biotop . py " self . run with int ( " biotop . py " )
self self . run with duration ( " bpflist . py " self . run with duration ( " bpflist . py " )
self self . run with duration ( " btrfsdist . py 1 1 " self . run with duration ( " btrfsdist . py 1 1 " )
self self . run with int ( " btrfsslower . py " , allow early = true self . run with int ( " btrfsslower . py " , allow early = true )
self self . run with duration ( " cachestat . py 1 1 " self . run with duration ( " cachestat . py 1 1 " )
self self . run with int ( " capable . py " self . run with int ( " capable . py " )
self self . run with duration ( " cpudist . py 1 1 " self . run with duration ( " cpudist . py 1 1 " )
self self . run with duration ( " cpuunclaimed . py 1 1 " self . run with duration ( " cpuunclaimed . py 1 1 " )
self self . run with int ( " dcsnoop . py " self . run with int ( " dcsnoop . py " )
self self . run with int ( " drsnoop . py " self . run with int ( " drsnoop . py " )
self self . run with int ( " execsnoop . py " self . run with int ( " execsnoop . py " )
self self . run with duration ( " ext4dist . py 1 1 " self . run with duration ( " ext4dist . py 1 1 " )
self self . run with int ( " ext4slower . py " self . run with int ( " ext4slower . py " )
self self . run with int ( " filelife . py " self . run with int ( " filelife . py " )
self self . run with duration ( " filetop . py 1 1 " self . run with duration ( " filetop . py 1 1 " )
self self . run with int ( " funccount . py kmalloc i 1 " self . run with int ( " funccount . py kmalloc i 1 " )
self self . run with int ( " funclatency . py kmalloc i 1 " self . run with int ( " funclatency . py kmalloc i 1 " )
self self . run with int ( " funcslower . py kmalloc " self . run with int ( " funcslower . py kmalloc " )
self self . run with int ( " gethostlatency . py " self . run with int ( " gethostlatency . py " )
self self . run with int ( " killsnoop . py " , kill = true self . run with int ( " killsnoop . py " , kill = true )
self self . run with int ( " mdflush . py " self . run with int ( " mdflush . py " )
self if ( self . kmod loaded ( " nfs " ) ) : self . run with int ( " nfsslower . py " ) else : pas if ( self . kmod loaded ( " nfs " ) ) : self . run with int ( " nfsslower . py " ) else : pass
self if ( self . kmod loaded ( " nfs " ) ) : self . run with duration ( " nfsdist . py 1 1 " ) else : pas if ( self . kmod loaded ( " nfs " ) ) : self . run with duration ( " nfsdist . py 1 1 " ) else : pass
self self . run with duration ( " offcputime . py 1 " self . run with duration ( " offcputime . py 1 " )
self self . run with duration ( " offwaketime . py 1 " self . run with duration ( " offwaketime . py 1 " )
self self . run with int ( " oomkill . py " self . run with int ( " oomkill . py " )
self self . run with int ( " pidpersec . py " self . run with int ( " pidpersec . py " )
self self . run with duration ( " runqlat . py 1 1 " self . run with duration ( " runqlat . py 1 1 " )
self self . run with int ( " sofdsnoop . py " self . run with int ( " sofdsnoop . py " )
self self . run with duration ( " slabratetop . py 1 1 " self . run with duration ( " slabratetop . py 1 1 " )
self self . run with duration ( " softirqs . py 1 1 " ) pas self . run with duration ( " softirqs . py 1 1 " ) pass
self self . run with int ( " solisten . py " self . run with int ( " solisten . py " )
self self . run with int ( " sslsniff . py " self . run with int ( " sslsniff . py " )
self self . run with int ( " stackcount . py kmalloc i 1 " self . run with int ( " stackcount . py kmalloc i 1 " )
self self . run with int ( " syncsnoop . py " self . run with int ( " syncsnoop . py " )
self self . run with int ( " syscount . py i 1 " self . run with int ( " syscount . py i 1 " )
self self . run with int ( " tcpconnect . py " self . run with int ( " tcpconnect . py " )
self self . run with int ( " tcplife . py " self . run with int ( " tcplife . py " )
self self . run with int ( " tcpdrop . py " self . run with int ( " tcpdrop . py " )
self self . run with duration ( " tcptop . py 1 1 " self . run with duration ( " tcptop . py 1 1 " )
self self . run with duration ( " tplist . py p %d " % os . getpid ( ) self . run with duration ( " tplist . py p %d " % os . getpid ( ) )
self self . run with int ( " lib/ucalls . py l none s %d " % os . getpid ( ) self . run with int ( " lib/ucalls . py l none s %d " % os . getpid ( ) )
self self . run with int ( " cobjnew . sh %d " % os . getpid ( ) self . run with int ( " cobjnew . sh %d " % os . getpid ( ) )
self self . run with duration ( " lib/ustat . py 1 1 " self . run with duration ( " lib/ustat . py 1 1 " )
self self . run with int ( " lib/uthreads . py %d " % os . getpid ( ) self . run with int ( " lib/uthreads . py %d " % os . getpid ( ) )
self self . run with int ( " vfscount . py " , timeout = 15 , kill timeout = 15 self . run with int ( " vfscount . py " , timeout = 15 , kill timeout = 15 )
self self . run with duration ( " vfsstat . py 1 1 " self . run with duration ( " vfsstat . py 1 1 " )
self self . run with duration ( " wakeuptime . py 1 " self . run with duration ( " wakeuptime . py 1 " )
self self . app . kill ( ) self . app . wait ( ) os . system ( " rm rf " + self . tmp dir self . app . kill ( ) self . app . wait ( ) os . system ( " rm rf " + self . tmp dir )
self self . fp = tempfile . temporary file ( ) os . dup2 ( self . fp . fileno ( ) , sys . stderr . fileno ( ) self . fp = tempfile . temporary file ( ) os . dup2 ( self . fp . fileno ( ) , sys . stderr . fileno ( ) )
self self . fp . close ( self . fp . close ( )
self , lic return ' ' ' #define bpf license %s ' ' ' % ( lic , lic return ' ' ' #define bpf license %s ' ' ' % ( lic )
self , bpf code event name = bpf code . get syscall fnname ( " read " ) bpf code . attach kprobe ( event = event name , fn name = " license program " ) bpf code . detach kprobe ( event = event name , bpf code event name = bpf code . get syscall fnname ( " read " ) bpf code . attach kprobe ( event = event name , fn name = " license program " ) bpf code . detach kprobe ( event = event name )
self b = bpf ( text = self . gpl only text ) self . load bpf code ( b b = bpf ( text = self . gpl only text ) self . load bpf code ( b )
self b = bpf ( text = self . gpl only text + self . license ( ' gpl ' ) ) self . load bpf code ( b b = bpf ( text = self . gpl only text + self . license ( ' gpl ' ) ) self . load bpf code ( b )
self b = bpf ( text = self . proprietary text + self . license ( ' proprietary ' ) ) self . load bpf code ( b b = bpf ( text = self . proprietary text + self . license ( ' proprietary ' ) ) self . load bpf code ( b )
self b = bpf ( text = self . gpl only text + self . license ( ' dual bsd/ gpl ' ) ) self . load bpf code ( b b = bpf ( text = self . gpl only text + self . license ( ' dual bsd/ gpl ' ) ) self . load bpf code ( b )
self b = bpf ( text = self . proprietary text + self . license ( ' proprietary license ' ) ) self . load bpf code ( b b = bpf ( text = self . proprietary text + self . license ( ' proprietary license ' ) ) self . load bpf code ( b )
self b = bpf ( text = self . gpl only text , cflags = [ " dbpf license= gpl " ] ) self . load bpf code ( b b = bpf ( text = self . gpl only text , cflags = [ " dbpf license= gpl " ] ) self . load bpf code ( b )
self b = bpf ( text = self . gpl only text + self . license ( ' ' ) ) self . load bpf code ( b b = bpf ( text = self . gpl only text + self . license ( ' ' ) ) self . load bpf code ( b )
self b = bpf ( text = self . gpl only text + self . license ( ' proprietary license ' ) ) self . load bpf code ( b b = bpf ( text = self . gpl only text + self . license ( ' proprietary license ' ) ) self . load bpf code ( b )
self b = bpf ( text = self . proprietary text , cflags = [ " dbpf license= proprietary " ] ) self . load bpf code ( b b = bpf ( text = self . proprietary text , cflags = [ " dbpf license= proprietary " ] ) self . load bpf code ( b )
self test command . finalize options ( self ) self . test args = [ ] self . test suite = tru test command . finalize options ( self ) self . test args = [ ] self . test suite = true
self self . fix identities ( ) self . fix repeating arguments ( ) return sel self . fix identities ( ) self . fix repeating arguments ( ) return self
self , uniq = none if not hasattr ( self , ' children ' ) : return self uniq = list ( set ( self . flat ( ) ) ) if uniq is none else uniq for i , child in enumerate ( self . children ) : if not hasattr ( child , ' children ' ) : assert child in uniq self . children [ i ] = uniq [ uniq . index ( child ) ] else : child . fix identities ( uniq )
self either = [ list ( child . children ) for child in transform ( self ) . children ] for case in either : for e in [ child for child in case if case . count ( child ) > 1 ] : if type ( e ) is argument or type ( e ) is option and e . argcount : if e . value is none : e . value = [ ] elif type ( e . value ) is not list : e . value = e . value . split ( ) if type ( e ) is command or type ( e ) is option and e . argcount == 0 : e . value = 0 return self
self , * types return [ self ] if not types or type ( self ) in types else [ , * types return [ self ] if not types or type ( self ) in types else [ ]
self , left for n , pattern in enumerate ( left ) : if type ( pattern ) is argument : return n , argument ( self . name , pattern . value ) return none , non , left for n , pattern in enumerate ( left ) : if type ( pattern ) is argument : return n , argument ( self . name , pattern . value ) return none , none
class , source name = re . findall ( ' (<\\ s*?>) ' , source ) [ 0 ] value = re . findall ( ' \\[default: ( . *)\\] ' , source , flags = re . i ) return class ( name , value [ 0 ] if value else none s , source name = re . findall ( ' (<\\ s*?>) ' , source ) [ 0 ] value = re . findall ( ' \\[default: ( . *)\\] ' , source , flags = re . i ) return class ( name , value [ 0 ] if value else none )
self , left for n , pattern in enumerate ( left ) : if type ( pattern ) is argument : if pattern . value == self . name : return n , command ( self . name , true ) else : break return none , non , left for n , pattern in enumerate ( left ) : if type ( pattern ) is argument : if pattern . value == self . name : return n , command ( self . name , true ) else : break return none , none
self , left for n , pattern in enumerate ( left ) : if self . name == pattern . name : return n , pattern return none , non , left for n , pattern in enumerate ( left ) : if self . name == pattern . name : return n , pattern return none , none
self , left , collected = none collected = [ ] if collected is none else collected l = left c = collected for pattern in self . children : matched , l , c = pattern . match ( l , c ) if not matched : return false , left , collected return true , l , , left , collected = none collected = [ ] if collected is none else collected l = left c = collected for pattern in self . children : matched , l , c = pattern . match ( l , c ) if not matched : return false , left , collected return true , l , c
self , left , collected = none collected = [ ] if collected is none else collected for pattern in self . children : m , left , collected = pattern . match ( left , collected ) return true , left , collecte , left , collected = none collected = [ ] if collected is none else collected for pattern in self . children : m , left , collected = pattern . match ( left , collected ) return true , left , collected
source source = re . sub ( r ' ([\\[\\]\\(\\)\\|]|\\ . \\ . \\ . ) ' , r ' \\1 ' , source ) source = [ s for s in re . split ( ' \\s+|(\\ s*< . *?>) ' , source ) if s ] return tokens ( source , error = docopt language error ce source = re . sub ( r ' ([\\[\\]\\(\\)\\|]|\\ . \\ . \\ . ) ' , r ' \\1 ' , source ) source = [ s for s in re . split ( ' \\s+|(\\ s*< . *?>) ' , source ) if s ] return tokens ( source , error = docopt language error )
self return self [ 0 ] if len ( self ) else non return self [ 0 ] if len ( self ) else none
source , options tokens = tokens . from pattern ( source ) result = parse expr ( tokens , options ) if tokens . current ( ) is not none : raise tokens . error ( ' unexpected ending: %r ' % ' ' . join ( tokens ) ) return required ( * result ce , options tokens = tokens . from pattern ( source ) result = parse expr ( tokens , options ) if tokens . current ( ) is not none : raise tokens . error ( ' unexpected ending: %r ' % ' ' . join ( tokens ) ) return required ( * result )
tokens , options result = [ ] while tokens . current ( ) not in [ none , ' ] ' , ' ) ' , ' | ' ] : atom = parse atom ( tokens , options ) if tokens . current ( ) == ' . . . ' : atom = [ one or more ( * atom ) ] tokens . move ( ) result += atom return result
name , source pattern = re . compile ( ' ^([^\]* ' + name + ' [^\]*\?(?:[ \\t] . *?(?:\|$))*) ' , re . ignorecase | re . multiline ) return [ s . strip ( ) for s in pattern . findall ( source ) , source pattern = re . compile ( ' ^([^\]* ' + name + ' [^\]*\?(?:[ \\t] . *?(?:\|$))*) ' , re . ignorecase | re . multiline ) return [ s . strip ( ) for s in pattern . findall ( source ) ]
section , , section = section . partition ( ' : ' ) pu = section . split ( ) return ' ( ' + ' ' . join ( ' ) | ( ' if s == pu [ 0 ] else s for s in pu [ 1 : ] ) + ' ) 'ion , , section = section . partition ( ' : ' ) pu = section . split ( ) return ' ( ' + ' ' . join ( ' ) | ( ' if s == pu [ 0 ] else s for s in pu [ 1 : ] ) + ' ) '
def doc = usage , = parse section ( ' usage: ' , doc ) assert usage == " usage: prog [ hv] arg\ prog n m " assert formal usage ( usage ) == " ( [ hv] arg ) | ( n m ) "
def assert argument ( ' n ' ) == argument ( ' n ' ) assert set ( [ argument ( ' n ' ) , argument ( ' n ' ) ] ) == set ( [ argument ( ' n ' ) ] assert argument ( ' n ' ) == argument ( ' n ' ) assert set ( [ argument ( ' n ' ) , argument ( ' n ' ) ] ) == set ( [ argument ( ' n ' ) ] )
def with raises ( docopt language error ) : docopt ( ' usage: prog [a [b] ' ) with raises ( docopt language error ) : docopt ( ' usage: prog [a [b] ] c ) ' with raises ( docopt language error ) : docopt ( ' usage: prog [a [b] ' ) with raises ( docopt language error ) : docopt ( ' usage: prog [a [b] ] c ) ' )
def with raises ( docopt language error ) : docopt ( ' no usage with colon here ' ) with raises ( docopt language error ) : docopt ( ' usage: here \\ and again usage: here ' with raises ( docopt language error ) : docopt ( ' no usage with colon here ' ) with raises ( docopt language error ) : docopt ( ' usage: here \\ and again usage: here ' )
def doc = a = docopt ( doc , ' ' ) assert a == { ' data ' : [ ' x ' ] } doc = """ usage: prog [ data=<data> . . . ]\ options:\\\t d data=<arg> input data [default: x y] """ a = docopt ( doc , ' ' ) assert a == { ' data ' : [ ' x ' , ' y ' ] } doc = """ usage: prog [ data=<data> . . . ]\ options:\\\t d data=<arg> input data [default: x y] """ a = docopt ( doc , ' data=this ' ) assert a == { ' data ' : [ ' this ' ] }
def assert docopt ( ' usage: prog long=<a> ' , ' long= ' ) == { ' long ' : ' ' } assert docopt ( ' usage: prog l <a>\ ' ' options: l <a> ' , [ ' l ' , ' ' ] ) == { ' l ' : ' ' assert docopt ( ' usage: prog long=<a> ' , ' long= ' ) == { ' long ' : ' ' } assert docopt ( ' usage: prog l <a>\ ' ' options: l <a> ' , [ ' l ' , ' ' ] ) == { ' l ' : ' ' }
def args = docopt ( ' usage: prog [ ab] [options]\ ' ' options: x\ y ' , ' ax ' ) assert args [ ' a ' ] is true assert args [ ' b ' ] is false assert args [ ' x ' ] is true assert args [ ' y ' ] is falsargs = docopt ( ' usage: prog [ ab] [options]\ ' ' options: x\ y ' , ' ax ' ) assert args [ ' a ' ] is true assert args [ ' b ' ] is false assert args [ ' x ' ] is true assert args [ ' y ' ] is false
def section = ' options:\\\t foo=<arg> [default: bar] ' assert parse defaults ( section ) == [ option ( none , ' foo ' , 1 , ' bar ' ) section = ' options:\\\t foo=<arg> [default: bar] ' assert parse defaults ( section ) == [ option ( none , ' foo ' , 1 , ' bar ' ) ]
path , parent if path . ext == " . docopt " and path . basename . startswith ( " test " ) : return docopt test file ( path , parent , parent if path . ext == " . docopt " and path . basename . startswith ( " test " ) : return docopt test file ( path , parent )
self try : result = docopt . docopt ( self . doc , argv = self . argv ) except docopt . docopt exit : result = ' user error ' if self . expect != result : raise docopt test exception ( self , result try : result = docopt . docopt ( self . doc , argv = self . argv ) except docopt . docopt exit : result = ' user error ' if self . expect != result : raise docopt test exception ( self , result )
self , excinfo if isinstance ( excinfo . value , docopt test exception ) : return " \ " . join ( ( " usecase execution failed: " , self . doc . rstrip ( ) , " $ %s %s " % ( self . prog , self . argv ) , " result> %s " % json . dumps ( excinfo . value . args [ 1 ] ) , " expect> %s " % json . dumps ( self . expect ) , ) )
self return self . fspath , 0 , " usecase: %s " % self . nam return self . fspath , 0 , " usecase: %s " % self . name
func def fn ( self , arg ) : try : opt = docopt ( fn . doc , arg ) except docopt exit as e : # the docopt exit is thrown when the args do not match . # we print a message to the user and the usage block . print ( ' invalid command! ' ) print ( e ) return except system exit : # the system exit exception prints the usage for help # we do not need to do the print here . return return func ( self , opt ) fn . name = func . name fn . doc = func . doc fn . dict . update ( func . dict ) return fn
self , arg print ( arg )
self , arg print ( arg )
def import json source = ' ' ' { " force " : true , " timeout " : " 10 " , " baud " : " 9600 " } ' ' ' return json . loads ( source import json source = ' ' ' { " force " : true , " timeout " : " 10 " , " baud " : " 9600 " } ' ' ' return json . loads ( source )
self , val , weight self . val = val self . avg = val self . sum = val * weight self . count = weight self . initialized = tru , val , weight self . val = val self . avg = val self . sum = val * weight self . count = weight self . initialized = true
self , val , weight = 1 if not self . initialized : self . initialize ( val , weight ) else : self . add ( val , weight , val , weight = 1 if not self . initialized : self . initialize ( val , weight ) else : self . add ( val , weight )
self , val , weight self . val = val self . sum += val * weight self . count += weight self . avg = self . sum / self . coun , val , weight self . val = val self . sum += val * weight self . count += weight self . avg = self . sum / self . count
self return self . va return self . val
self return self . av return self . avg
preds , label valid = ( label >= 0 ) acc sum = ( valid * ( preds == label ) ) . sum ( ) valid sum = valid . sum ( ) acc = float ( acc sum ) / ( valid sum + 1e 10 ) return acc , valid sus , label valid = ( label >= 0 ) acc sum = ( valid * ( preds == label ) ) . sum ( ) valid sum = valid . sum ( ) acc = float ( acc sum ) / ( valid sum + 1e 10 ) return acc , valid sum
xpu , inp start , end = map ( int , inp ) if start > end : end , start = start , end return map ( lambda x : ' {}{} ' . format ( xpu , x ) , range ( start , end + 1 ) , inp start , end = map ( int , inp ) if start > end : end , start = start , end return map ( lambda x : ' {}{} ' . format ( xpu , x ) , range ( start , end + 1 ) )
input devices ret = [ ] for d in input devices . split ( ' , ' ) : for regex , func in regex : m = regex . match ( d . lower ( ) . strip ( ) ) if m : tmp = func ( m . groups ( ) ) # prevent duplicate for x in tmp : if x not in ret : ret . append ( x ) break else : raise not supported cli exception ( ' can not recognize device: " {} " ' . format ( d ) ) return ret
im , size , interp = ' bilinear ' if interp == ' nearest ' : resample = image . nearest elif interp == ' bilinear ' : resample = image . bilinear elif interp == ' bicubic ' : resample = image . bicubic else : raise exception ( ' resample method undefined! ' ) return im . resize ( size , resample , size , interp = ' bilinear ' if interp == ' nearest ' : resample = image . nearest elif interp == ' bilinear ' : resample = image . bilinear elif interp == ' bicubic ' : resample = image . bicubic else : raise exception ( ' resample method undefined! ' ) return im . resize ( size , resample )
self , img img = np . float32 ( np . array ( img ) ) / 255 . img = img . transpose ( ( 2 , 0 , 1 ) ) img = self . normalize ( torch . from numpy ( img . copy ( ) ) ) return im , img img = np . float32 ( np . array ( img ) ) / 255 . img = img . transpose ( ( 2 , 0 , 1 ) ) img = self . normalize ( torch . from numpy ( img . copy ( ) ) ) return img
self , segm segm = torch . from numpy ( np . array ( segm ) ) . long ( ) 1 return seg , segm segm = torch . from numpy ( np . array ( segm ) ) . long ( ) 1 return segm
self , x , p return ( ( x 1 ) // p + 1 ) * , x , p return ( ( x 1 ) // p + 1 ) * p
inp , oup , stride return nn . sequential ( nn . conv2d ( inp , oup , 3 , stride , 1 , bias = false ) , batch norm2d ( oup ) , nn . re lu6 ( inplace = true ) , oup , stride return nn . sequential ( nn . conv2d ( inp , oup , 3 , stride , 1 , bias = false ) , batch norm2d ( oup ) , nn . re lu6 ( inplace = true ) )
inp , oup return nn . sequential ( nn . conv2d ( inp , oup , 1 , 1 , 0 , bias = false ) , batch norm2d ( oup ) , nn . re lu6 ( inplace = true ) , oup return nn . sequential ( nn . conv2d ( inp , oup , 1 , 1 , 0 , bias = false ) , batch norm2d ( oup ) , nn . re lu6 ( inplace = true ) )
self , x if self . use res connect : return x + self . conv ( x ) else : return self . conv ( x , x if self . use res connect : return x + self . conv ( x ) else : return self . conv ( x )
pretrained = false , ** kwargs model = mobile net v2 ( n class = 1000 , ** kwargs ) if pretrained : model . load state dict ( load url ( model urls [ ' mobilenetv2 ' ] ) , strict = false ) return model
in planes , out planes , stride = 1 " 3x3 convolution with padding " return nn . conv2d ( in planes , out planes , kernel size = 3 , stride = stride , padding = 1 , bias = false lanes , out planes , stride = 1 " 3x3 convolution with padding " return nn . conv2d ( in planes , out planes , kernel size = 3 , stride = stride , padding = 1 , bias = false )
pretrained = false , ** kwargs model = res net ( bottleneck , [ 3 , 4 , 23 , 3 ] , ** kwargs ) if pretrained : model . load state dict ( load url ( model urls [ ' resnet101 ' ] ) , strict = false ) return model
in planes , out planes , stride = 1 return nn . conv2d ( in planes , out planes , kernel size = 3 , stride = stride , padding = 1 , bias = false )
self , num branches , block , num blocks , num channels branches = [ ] for i in range ( num branches ) : branches . append ( self . make one branch ( i , block , num blocks , num channels ) ) return nn . module list ( branches , num branches , block , num blocks , num channels branches = [ ] for i in range ( num branches ) : branches . append ( self . make one branch ( i , block , num blocks , num channels ) ) return nn . module list ( branches )
self return self . num inchannel return self . num inchannels
in planes , out planes , stride = 1 " 3x3 convolution with padding " return nn . conv2d ( in planes , out planes , kernel size = 3 , stride = stride , padding = 1 , bias = false lanes , out planes , stride = 1 " 3x3 convolution with padding " return nn . conv2d ( in planes , out planes , kernel size = 3 , stride = stride , padding = 1 , bias = false )
pretrained = false , ** kwargs model = res ne xt ( group bottleneck , [ 3 , 4 , 23 , 3 ] , ** kwargs ) if pretrained : model . load state dict ( load url ( model urls [ ' resnext101 ' ] ) , strict = false ) return model
sequence r , s = [ ] , 0 for e in sequence : l = len ( e ) r . append ( l + s ) s += l return ence r , s = [ ] , 0 for e in sequence : l = len ( e ) r . append ( l + s ) s += l return r
self warnings . warn ( " cummulative sizes attribute is renamed to " " cumulative sizes " , deprecation warning , stacklevel = 2 ) return self . cumulative size warnings . warn ( " cummulative sizes attribute is renamed to " " cumulative sizes " , deprecation warning , stacklevel = 2 ) return self . cumulative sizes
dataset , lengths if sum ( lengths ) != len ( dataset ) : raise value error ( " sum of input lengths does not equal the length of the input dataset! " ) indices = randperm ( sum ( lengths ) ) return [ subset ( dataset , indices [ offset length : offset ] ) for offset , length in zip ( accumulate ( lengths ) , lengths ) ]
self , epoch self . epoch = epoc , epoch self . epoch = epoch
self if self . timeout > 0 : try : return self . data queue . get ( timeout = self . timeout ) except queue . empty : raise runtime error ( ' data loader timed out after {} seconds ' . format ( self . timeout ) ) else : return self . data queue . get ( if self . timeout > 0 : try : return self . data queue . get ( timeout = self . timeout ) except queue . empty : raise runtime error ( ' data loader timed out after {} seconds ' . format ( self . timeout ) ) else : return self . data queue . get ( )
self assert self . batches outstanding < 2 * self . num workers indices = next ( self . sample iter , none ) if indices is none : return self . index queue . put ( ( self . send idx , indices ) ) self . batches outstanding += 1 self . send idx += assert self . batches outstanding < 2 * self . num workers indices = next ( self . sample iter , none ) if indices is none : return self . index queue . put ( ( self . send idx , indices ) ) self . batches outstanding += 1 self . send idx += 1
self , batch self . rcvd idx += 1 self . put indices ( ) if isinstance ( batch , exception wrapper ) : raise batch . exc type ( batch . exc msg ) return batc , batch self . rcvd idx += 1 self . put indices ( ) if isinstance ( batch , exception wrapper ) : raise batch . exc type ( batch . exc msg ) return batch
self with self . lock : if self . result is none : self . cond . wait ( ) res = self . result self . result = none return re with self . lock : if self . result is none : self . cond . wait ( ) res = self . result self . result = none return res
self , identifier if self . activated : assert self . queue . empty ( ) , ' queue is not clean before next initialization . ' self . activated = false self . registry . clear ( ) future = future result ( ) self . registry [ identifier ] = master registry ( future ) return slave pipe ( identifier , self . queue , future )
self return len ( self . registry return len ( self . registry )
self , module , device ids modules = super ( data parallel with callback , self ) . replicate ( module , device ids ) execute replication callbacks ( modules ) return module , module , device ids modules = super ( data parallel with callback , self ) . replicate ( module , device ids ) execute replication callbacks ( modules ) return modules
data parallel assert isinstance ( data parallel , data parallel ) old replicate = data parallel . replicate @ functools . wraps ( old replicate ) def new replicate ( module , device ids ) : modules = old replicate ( module , device ids ) execute replication callbacks ( modules ) return modules data parallel . replicate = new replicate
tensor return tensor . sum ( dim = 0 ) . sum ( dim = 1 )
tensor return tensor . unsqueeze ( 0 ) . unsqueeze ( 1 )
self , input if input . dim ( ) != 2 and input . dim ( ) != 3 : raise value error ( ' expected 2 d or 3 d input (got {} d input) ' . format ( input . dim ( ) ) ) super ( synchronized batch norm1d , self ) . check input dim ( input , input if input . dim ( ) != 2 and input . dim ( ) != 3 : raise value error ( ' expected 2 d or 3 d input (got {} d input) ' . format ( input . dim ( ) ) ) super ( synchronized batch norm1d , self ) . check input dim ( input )
self , input if input . dim ( ) != 4 : raise value error ( ' expected 4 d input (got {} d input) ' . format ( input . dim ( ) ) ) super ( synchronized batch norm2d , self ) . check input dim ( input , input if input . dim ( ) != 4 : raise value error ( ' expected 4 d input (got {} d input) ' . format ( input . dim ( ) ) ) super ( synchronized batch norm2d , self ) . check input dim ( input )
self , input if input . dim ( ) != 5 : raise value error ( ' expected 5 d input (got {} d input) ' . format ( input . dim ( ) ) ) super ( synchronized batch norm3d , self ) . check input dim ( input , input if input . dim ( ) != 5 : raise value error ( ' expected 5 d input (got {} d input) ' . format ( input . dim ( ) ) ) super ( synchronized batch norm3d , self ) . check input dim ( input )
v if isinstance ( v , variable ) : v = v . data return v . cpu ( ) . numpy ( isinstance ( v , variable ) : v = v . data return v . cpu ( ) . numpy ( )
a , unbias = true n = a . size ( 0 ) asum = a . sum ( dim = 0 ) as sum = ( a ** 2 ) . sum ( dim = 0 ) sumvar = as sum asum * asum / n if unbias : return sumvar / ( n 1 ) else : return sumvar / unbias = true n = a . size ( 0 ) asum = a . sum ( dim = 0 ) as sum = ( a ** 2 ) . sum ( dim = 0 ) sumvar = as sum asum * asum / n if unbias : return sumvar / ( n 1 ) else : return sumvar / n
module for m in module . modules ( ) : if isinstance ( m , ( nn . batch norm1d , nn . batch norm2d , synchronized batch norm1d , synchronized batch norm2d ) ) : return le for m in module . modules ( ) : if isinstance ( m , ( nn . batch norm1d , nn . batch norm2d , synchronized batch norm1d , synchronized batch norm2d ) ) : return m
self , bn1 , bn2 bn1 . reset parameters ( ) bn2 . reset parameters ( ) if bn1 . affine and bn2 . affine : bn2 . weight . data . copy ( bn1 . weight . data ) bn2 . bias . data . copy ( bn1 . bias . data , bn1 , bn2 bn1 . reset parameters ( ) bn2 . reset parameters ( ) if bn1 . affine and bn2 . affine : bn2 . weight . data . copy ( bn1 . weight . data ) bn2 . bias . data . copy ( bn1 . bias . data )
self bn = nn . batch norm1d ( 10 ) sync bn = synchronized batch norm1d ( 10 ) self . check batch norm result ( bn , sync bn , torch . rand ( 16 , 10 ) , true bn = nn . batch norm1d ( 10 ) sync bn = synchronized batch norm1d ( 10 ) self . check batch norm result ( bn , sync bn , torch . rand ( 16 , 10 ) , true )
self , outputs , output device return dict gather ( outputs , output device , dim = self . dim , outputs , output device return dict gather ( outputs , output device , dim = self . dim )
batch return batch return batch
device global streams if device == 1 : return none if streams is none : streams = [ none ] * cuda . device count ( ) if streams [ device ] is none : streams [ device ] = cuda . stream ( device ) return streams [ device ]
parts with codecs . open ( join ( here , * parts ) , " rb " , " utf 8 " ) as f : return f . read ( s with codecs . open ( join ( here , * parts ) , " rb " , " utf 8 " ) as f : return f . read ( )
env , path key = " pythonpath " pypath = [ p for p in env . get ( key , " " ) . split ( " : " ) if p ] pypath . insert ( 0 , path ) pypath = " : " . join ( pypath ) env [ key ] = pypat , path key = " pythonpath " pypath = [ p for p in env . get ( key , " " ) . split ( " : " ) if p ] pypath . insert ( 0 , path ) pypath = " : " . join ( pypath ) env [ key ] = pypath
m mod file = inspect . getsourcefile ( m ) is package = mod file . endswith ( " init . py " ) mod dir = dirname ( mod file ) if is package : mod dir , = split ( mod dir ) return mod did file = inspect . getsourcefile ( m ) is package = mod file . endswith ( " init . py " ) mod dir = dirname ( mod file ) if is package : mod dir , = split ( mod dir ) return mod dir
env , m append pythonpath ( env , get module import dir ( m ) , m append pythonpath ( env , get module import dir ( m ) )
self , record pas , record pass
self , record pas , record pass
self self . lock = non self . lock = none
condition , reason def wrapper ( test ) : if condition : return test else : @ wraps ( test ) def skip ( * args , ** kwargs ) : return return skip return wrappeition , reason def wrapper ( test ) : if condition : return test else : @ wraps ( test ) def skip ( * args , ** kwargs ) : return return skip return wrapper
progs missing = [ ] for prog in progs : try : sh . command ( prog ) except sh . command not found : missing . append ( prog ) friendly missing = " , " . join ( missing ) return skip unless ( len ( missing ) == 0 , " missing required system programs: %s " % friendly missing s missing = [ ] for prog in progs : try : sh . command ( prog ) except sh . command not found : missing . append ( prog ) friendly missing = " , " . join ( missing ) return skip unless ( len ( missing ) == 0 , " missing required system programs: %s " % friendly missing )
poller use select = bool ( int ( os . environ . get ( " sh tests use select " , " 0 " ) ) ) cur poller = " select " if use select else " poll " return skip unless ( cur poller == poller , " only enabled for select . %s " % cur poller er use select = bool ( int ( os . environ . get ( " sh tests use select " , " 0 " ) ) ) cur poller = " select " if use select else " poll " return skip unless ( cur poller == poller , " only enabled for select . %s " % cur poller )
key , new soft soft , hard = resource . getrlimit ( key ) resource . setrlimit ( key , ( new soft , hard ) ) try : yield finally : resource . setrlimit ( key , ( soft , hard ) , new soft soft , hard = resource . getrlimit ( key ) resource . setrlimit ( key , ( new soft , hard ) ) try : yield finally : resource . setrlimit ( key , ( soft , hard ) )
self , num , fn , * args , ** kwargs try : fn ( * args , ** kwargs ) except os error as e : self . assert equal ( e . errno , num , num , fn , * args , ** kwargs try : fn ( * args , ** kwargs ) except os error as e : self . assert equal ( e . errno , num )
self , fn , * args , ** kwargs with warnings . catch warnings ( record = true ) as w : fn ( * args , ** kwargs ) assert len ( w ) == 1 assert issubclass ( w [ 1 ] . category , deprecation warning , fn , * args , ** kwargs with warnings . catch warnings ( record = true ) as w : fn ( * args , ** kwargs ) assert len ( w ) == 1 assert issubclass ( w [ 1 ] . category , deprecation warning )
self self . environ = os . environ . copy ( self . environ = os . environ . copy ( )
self os . environ = self . enviro os . environ = self . environ
self from sh import echo test = " \u6f22\u5b57 " if not is py3 : test = test . decode ( " utf8 " ) p = echo ( test , encoding = " utf8 " ) output = p . strip ( ) self . assert equal ( test , output from sh import echo test = " \u6f22\u5b57 " if not is py3 : test = test . decode ( " utf8 " ) p = echo ( test , encoding = " utf8 " ) output = p . strip ( ) self . assert equal ( test , output )
self py = create tmp test ( ) read fd , write fd = os . pipe ( ) python ( py . name , out = write fd ) out = os . read ( read fd , 10 ) self . assert equal ( out , b " hi world\ " )
self py = create tmp test ( ) self . assert raises ( sh . error return code , python , py . name )
self py = create tmp test ( ) out = python ( py . name , 3 ) . strip ( ) self . assert equal ( out , " 3 " )
self from sh import error return code py = create tmp test ( ) self . assert raises ( error return code , python , py . name )
self from glob import glob py = create tmp test ( ) files = glob ( " * . faowjefoajweofj " ) out = python ( py . name , files ) . strip ( ) self . assert equal ( out , " [ ' * . faowjefoajweofj ' ] " )
self from glob import glob py = create tmp test ( ) files = glob ( " * . faowjefoajweofj " , recursive = true ) out = python ( py . name , files ) . strip ( ) self . assert equal ( out , " [ ' * . faowjefoajweofj ' ] " )
self from sh import error return code py = create tmp test ( ) try : out = python ( py . name , iter = true ) # hasattr can swallow exceptions hasattr ( out , ' something not there ' ) list ( out ) self . assert equal ( out . exit code , 3 ) self . fail ( " command exited with error , but no exception thrown " ) except error return code as e : pass
self from sh import error return code py = create tmp test ( ) self . assert raises ( error return code , python , py . name ) try : python ( py . name ) except exception as e : self . assert equal ( e . exit code , 3 )
self py = create tmp test ( " exit(0) " ) python ( py . name , ok code = none py = create tmp test ( " exit(0) " ) python ( py . name , ok code = none )
self from sh import tr out = tr ( " [:lower:] " , " [:upper:] " , in = " andrew " ) . strip ( ) self . assert equal ( out , " andrew " from sh import tr out = tr ( " [:lower:] " , " [:upper:] " , in = " andrew " ) . strip ( ) self . assert equal ( out , " andrew " )
self from sh import tr test = [ " testing\ " , " herp\ " , " derp\ " ] out = tr ( " [:lower:] " , " [:upper:] " , in = test ) match = " " . join ( [ t . upper ( ) for t in test ] ) self . assert equal ( out , match from sh import tr test = [ " testing\ " , " herp\ " , " derp\ " ] out = tr ( " [:lower:] " , " [:upper:] " , in = test ) match = " " . join ( [ t . upper ( ) for t in test ] ) self . assert equal ( out , match )
self from sh import which , ls self . assert equal ( which ( " fjoawjefojawe " ) , none ) self . assert equal ( which ( " ls " ) , str ( ls ) from sh import which , ls self . assert equal ( which ( " fjoawjefojawe " ) , none ) self . assert equal ( which ( " ls " ) , str ( ls ) )
self from sh import which py = create tmp test ( ) test path = dirname ( py . name ) , test name = os . path . split ( py . name ) found path = which ( test name ) self . assert equal ( found path , none ) found path = which ( test name , [ test path ] ) self . assert equal ( found path , py . name )
self import pwd from sh import whoami u1 = whoami ( ) . strip ( ) u2 = pwd . getpwuid ( os . geteuid ( ) ) [ 0 ] self . assert equal ( u1 , u2 import pwd from sh import whoami u1 = whoami ( ) . strip ( ) u2 = pwd . getpwuid ( os . geteuid ( ) ) [ 0 ] self . assert equal ( u1 , u2 )
self from sh import ls self . assert raises ( type error , ls , iter = true , piped = true from sh import ls self . assert raises ( type error , ls , iter = true , piped = true )
self from sh import error return code 2 py = create tmp test ( ) py2 = create tmp test ( " " ) def fn ( ) : list ( python ( python ( py . name , piped = true ) , " u " , py2 . name , iter = true ) ) self . assert raises ( error return code 2 , fn )
self from sh import error return code 2 py = create tmp test ( ) py2 = create tmp test ( " " ) def fn ( ) : python ( python ( py . name , piped = true ) , " u " , py2 . name ) self . assert raises ( error return code 2 , fn )
self from sh import command , ls , which self . assert equal ( command ( which ( " ls " ) ) , ls from sh import command , ls , which self . assert equal ( command ( which ( " ls " ) ) , ls )
self py = create tmp test ( ) num args = int ( python ( py . name , l = " one two three " ) ) self . assert equal ( num args , 3 ) num args = int ( python ( py . name , " l " , " one ' s two ' s three ' s " ) ) self . assert equal ( num args , 3 )
self from sh import sh s1 = sh ( c = " echo test " ) . strip ( ) s2 = " test " self . assert equal ( s1 , s2 from sh import sh s1 = sh ( c = " echo test " ) . strip ( ) s2 = " test " self . assert equal ( s1 , s2 )
self py = create tmp test ( ) self . assert true ( python ( py . name , long option = " testing " ) . strip ( ) == " testing " ) self . assert true ( python ( py . name ) . strip ( ) == " " )
self py = create tmp test ( ) self . assert equal ( python ( py . name , { " long option " : " underscore " } ) . strip ( ) , " underscore " ) self . assert equal ( python ( py . name , long option = " hyphen " ) . strip ( ) , " hyphen " )
self py = create tmp test ( ) opt = { " long option " : " underscore " } correct = " long option=custom=underscore " out = python ( py . name , opt , long sep = " =custom= " ) . strip ( ) self . assert equal ( out , correct ) correct = " long option=baked=underscore " python baked = python . bake ( py . name , opt , long sep = " =baked= " ) out = python baked ( ) . strip ( ) self . assert equal ( out , correct )
self py = create tmp test ( ) opt = { " long option " : " space " } correct = [ " long option " , " space " ] out = python ( py . name , opt , long sep = " " ) . strip ( ) self . assert equal ( out , str ( correct ) )
self py = create tmp test ( ) out = python ( py . name , { " long option " : " underscore " } , long prefix = " custom " ) . strip ( ) self . assert equal ( out , " custom long option=underscore " ) out = python . bake ( py . name , { " long option " : " underscore " } , long prefix = " baked " ) ( ) . strip ( ) self . assert equal ( out , " baked long option=underscore " )
self from sh import ls , error return code 1 , error return code 2 p = ls ( " /ofawjeofj " , bg = true ) exc to test = error return code 2 if is osx : exc to test = error return code 1 self . assert raises ( exc to test , p . wait from sh import ls , error return code 1 , error return code 2 p = ls ( " /ofawjeofj " , bg = true ) exc to test = error return code 2 if is osx : exc to test = error return code 1 self . assert raises ( exc to test , p . wait )
self from sh import whoami import getpass py = create tmp test ( ) cmd1 = python . bake ( py . name , with = true ) with cmd1 : out = whoami ( ) self . assert true ( " with context " in out ) self . assert true ( getpass . getuser ( ) in out )
self from sh import whoami import getpass py = create tmp test ( ) with python ( py . name , opt = true , with = true ) : out = whoami ( ) self . assert true ( getpass . getuser ( ) == out . strip ( ) ) with python ( py . name , with = true ) : out = whoami ( ) self . assert true ( out == " " )
self py = create tmp test ( ) data = b ' 1234 ' out = python ( py . name , in = data ) self . assert equal ( out , " 1234 " )
self py = create tmp test ( ) stdout = python ( py . name , err to out = true ) self . assert equal ( stdout , " stdoutstderr " )
self py = create tmp test ( ) master , slave = os . pipe ( ) stdout = python ( py . name , err to out = true , out = slave ) self . assert equal ( stdout , " " ) self . assert equal ( os . read ( master , 12 ) , b " stdoutstderr " )
self py = create tmp test ( ) py2 = create tmp test ( """ import syswhile true: line = sys . stdin . read() if not line: break sys . stdout . write(line) """ ) out = python ( python ( " u " , py . name , piped = " err " ) , " u " , py2 . name ) self . assert equal ( out , " stderr " )
self from sh import ls import getpass py = create tmp test ( ) cmd1 = python . bake ( py . name ) out = cmd1 . whoami ( ) self . assert true ( " subcommand " in out ) self . assert true ( getpass . getuser ( ) in out )
self py = create tmp test ( ) out = python . bake ( py . name ) . bake ( " bake1 " ) . bake ( " bake2 " ) ( ) self . assert equal ( " [ ' bake1 ' , ' bake2 ' ] " , out )
self py = create tmp test ( ) def arg preprocess ( args , kwargs ) : args . insert ( 0 , " preprocessed " ) kwargs [ " a kwarg " ] = 123 return args , kwargs cmd = python . bake ( py . name , arg preprocess = arg preprocess ) out = cmd ( " arg " ) self . assert equal ( " [ ' preprocessed ' , ' arg ' , ' a kwarg=123 ' ] " , out )
self from sh import ls ls = ls . bake ( h = true ) ran = ls ( " la " ) . ran ft = ran . index ( " h " ) self . assert true ( " la " in ran [ ft : ] from sh import ls ls = ls . bake ( h = true ) ran = ls ( " la " ) . ran ft = ran . index ( " h " ) self . assert true ( " la " in ran [ ft : ] )
self from sh import whoami iam1 = whoami ( ) iam2 = whoami ( ) self . assert equal ( iam1 , iam2 from sh import whoami iam1 = whoami ( ) iam2 = whoami ( ) self . assert equal ( iam1 , iam2 )
self py = create tmp test ( r ) read fd , write fd = os . pipe ( ) p = python ( py . name , out = write fd , u = true ) def alarm ( sig , action ) : self . fail ( " timeout while reading from pipe " ) import signal signal . signal ( signal . sigalrm , alarm ) signal . alarm ( 3 ) data = os . read ( read fd , 100 ) self . assert equal ( b " foobar\ " , data ) signal . alarm ( 0 ) signal . signal ( signal . sigalrm , signal . sig dfl )
self import time py = create tmp test ( ) stdout = [ ] def agg ( line ) : stdout . append ( line ) p = python ( " u " , py . name , out = agg , bg = true ) time . sleep ( . 5 ) self . assert true ( len ( stdout ) != 5 )
self py = create tmp test ( ) stdout = [ ] def agg ( line ) : stdout . append ( line ) p = python ( " u " , py . name , out = agg , out bufsize = 1 ) p . wait ( ) self . assert true ( len ( stdout ) == 5 )
self py = create tmp test ( ) stdout = [ ] def agg ( char ) : stdout . append ( char ) p = python ( " u " , py . name , out = agg , out bufsize = 0 ) p . wait ( ) self . assert true ( len ( stdout ) == ( len ( " herpderp " ) * 5 + 5 ) )
self py = create tmp test ( ) stdout = [ ] def agg ( chunk ) : stdout . append ( chunk ) p = python ( " u " , py . name , out = agg , out bufsize = 4 ) p . wait ( ) self . assert true ( len ( stdout ) == ( len ( " herp " ) / 2 * 5 ) )
self py = create tmp test ( ) def agg ( line , stdin ) : if line . strip ( ) == " 4 " : stdin . put ( " derp\ " ) p = python ( " u " , py . name , out = agg , tee = true ) p . wait ( ) self . assert true ( " derp " in p )
self py = create tmp test ( ) stdout = [ ] def agg ( line ) : line = line . strip ( ) stdout . append ( line ) if line == " 2 " : return true p = python ( " u " , py . name , out = agg , tee = true ) p . wait ( ) self . assert true ( " 4 " in p ) self . assert true ( " 4 " not in stdout )
self import signal from signal import sigint py = create tmp test ( ) stdout = [ ] def agg ( line , stdin , process ) : line = line . strip ( ) stdout . append ( line ) if line == " 3 " : process . signal ( sigint ) return true p = python ( py . name , out = agg , tee = true ) p . wait ( ) self . assert equal ( p . process . exit code , 0 ) self . assert equal ( p , " 0\1\2\3\10\ " )
self py = create tmp test ( ) out = [ ] for line in python ( py . name , iter = true ) : out . append ( int ( line . strip ( ) ) ) self . assert true ( len ( out ) == 42 and sum ( out ) == 861 )
self test string = " \\xe4\\xbd\\x95\\xe4\\xbd\\x95\ " * 150 txt = create tmp test ( test string ) for line in sh . cat ( txt . name , iter = true ) : break self . assert true ( len ( line ) < 1024 test string = " \\xe4\\xbd\\x95\\xe4\\xbd\\x95\ " * 150 txt = create tmp test ( test string ) for line in sh . cat ( txt . name , iter = true ) : break self . assert true ( len ( line ) < 1024 )
self py = create tmp test ( ) out = [ ] for line in python ( " u " , py . name , iter = " err " ) : out . append ( line ) self . assert true ( len ( out ) == 42 ) out = [ ] for line in python ( " u " , py . name , iter = " out " ) : out . append ( line ) self . assert true ( len ( out ) == 0 )
self import sh py1 = create tmp test ( ) py2 = create tmp test ( """ import sysimport osimport timewhile true: line = sys . stdin . readline() if not line: break print(line . strip() . upper()) exit(0) """ ) p1 = python ( " u " , py1 . name , piped = " out " ) p2 = python ( p1 , " u " , py2 . name ) self . assert equal ( p1 . exit code , signal . sigpipe ) self . assert equal ( p2 . exit code , 0 )
self py = create tmp test ( ) stderr = [ ] def agg ( line ) : stderr . append ( int ( line . strip ( ) ) ) out = [ ] for line in python ( " u " , py . name , iter = true , err = agg ) : out . append ( line ) self . assert true ( len ( out ) == 42 ) self . assert true ( sum ( stderr ) == 1722 )
self py = create tmp test ( ) self . assert equal ( int ( python ( py . name , " 123 " , bg = true ) ) , 123 ) self . assert equal ( long ( python ( py . name , " 456 " , bg = true ) ) , 456 ) self . assert equal ( float ( python ( py . name , " 789 " , bg = true ) ) , 789 . 0 )
self py = create tmp test ( ) env = os . environ . copy ( ) env [ " exit " ] = " 3 " self . assert raises ( sh . error return code 3 , python , py . name , fg = true , env = env )
self py = create tmp test ( " exit(0) " ) python ( py . name , in = sys . stdin , out = sys . stdout , err = sys . stderr py = create tmp test ( " exit(0) " ) python ( py . name , in = sys . stdin , out = sys . stdout , err = sys . stderr )
self py = create tmp test ( " exit(1) " ) self . assert raises ( sh . error return code 1 , python , py . name , fg = true py = create tmp test ( " exit(1) " ) self . assert raises ( sh . error return code 1 , python , py . name , fg = true )
self outfile = tempfile . named temporary file ( ) py = create tmp test ( " print( ' output ' ) " ) python ( py . name , out = outfile . name ) outfile . seek ( 0 ) self . assert equal ( b " output\ " , outfile . read ( ) outfile = tempfile . named temporary file ( ) py = create tmp test ( " print( ' output ' ) " ) python ( py . name , out = outfile . name ) outfile . seek ( 0 ) self . assert equal ( b " output\ " , outfile . read ( ) )
self py = create tmp test ( ) p = python ( py . name , ok code = 49 , bg = true ) self . assert equal ( 49 , p . exit code )
self py = create tmp test ( ) out = python ( py . name , tty out = true ) self . assert equal ( out , " tty attached " ) out = python ( py . name , tty out = false ) self . assert equal ( out , " no tty attached " )
self from sh import cat input = string io ( ) input . write ( " herpderp " ) input . seek ( 0 ) out = cat ( in = input ) self . assert equal ( out , " herpderp " from sh import cat input = string io ( ) input . write ( " herpderp " ) input . seek ( 0 ) out = cat ( in = input ) self . assert equal ( out , " herpderp " )
self py = create tmp test ( ) class callable ( object ) : def init ( self ) : self . line = none def call ( self , line ) : self . line = line cb = callable ( ) python ( py . name , out = cb ) self . assert equal ( cb . line , " line1 " )
self started = time . time ( ) sh . sleep ( 1 , timeout = 5 ) elapsed = time . time ( ) started self . assert true ( abs ( elapsed 1 ) < 0 . 5 started = time . time ( ) sh . sleep ( 1 , timeout = 5 ) elapsed = time . time ( ) started self . assert true ( abs ( elapsed 1 ) < 0 . 5 )
self binary = b ' \\xec;\\xedr\\xdb f ' py1 = create tmp test ( ) py2 = create tmp test ( """ import sysimport ossys . stdin = os . fdopen(sys . stdin . fileno() , " rb " , 0)sys . stdout = os . fdopen(sys . stdout . fileno() , " wb " , 0)sys . stdout . write(sys . stdin . read()) """ ) out = python ( python ( py1 . name ) , py2 . name ) self . assert equal ( out . stdout , binary )
self from sh import error return code 1 py = create tmp test ( ) self . assert raises ( error return code 1 , python , py . name )
self from sh import ls , error return code test = " /\u00e1 " if is py3 : pass else : test = test . decode ( " utf8 " ) self . assert raises ( error return code , ls , test from sh import ls , error return code test = " /\u00e1 " if is py3 : pass else : test = test . decode ( " utf8 " ) self . assert raises ( error return code , ls , test )
self py = create tmp test ( ) out = python ( py . name , in = " test\ " , tty in = true ) self . assert equal ( " test\ " , out )
self from functools import partial py = create tmp test ( ) fn = partial ( python , py . name , encoding = " ascii " ) def s ( fn ) : str ( fn ( ) ) self . assert raises ( unicode decode error , s , fn ) p = python ( py . name , encoding = " ascii " , decode errors = " ignore " ) self . assert equal ( p , " test " )
self from sh import signal exception 15 def throw terminate signal ( ) : py = create tmp test ( ) to kill = python ( py . name , bg = true ) to kill . terminate ( ) to kill . wait ( ) self . assert raises ( signal exception 15 , throw terminate signal )
self import sh from sh import mkdir child = realpath ( tempfile . mkdtemp ( ) ) try : old wd = os . getcwd ( ) with sh . pushd ( tempdir ) : self . assert equal ( tempdir , os . getcwd ( ) ) sh . cd ( child ) self . assert equal ( child , os . getcwd ( ) ) self . assert equal ( old wd , os . getcwd ( ) ) finally : os . rmdir ( child )
self from sh import ls non exist dir = join ( tempdir , " aowjgoahewro " ) self . assert false ( exists ( non exist dir ) ) self . assert raises ( os error , ls , cwd = non exist dir from sh import ls non exist dir = join ( tempdir , " aowjgoahewro " ) self . assert false ( exists ( non exist dir ) ) self . assert raises ( os error , ls , cwd = non exist dir )
self from sh import ls ll = ls . bake ( " l " ) self . assert true ( str ( ll ) . endswith ( " /ls l " ) from sh import ls ll = ls . bake ( " l " ) self . assert true ( str ( ll ) . endswith ( " /ls l " ) )
self from sh import fork exception py = create tmp test ( " " ) def fail ( ) : raise runtime error ( " nooo " ) self . assert raises ( fork exception , python , py . name , preexec fn = fail from sh import fork exception py = create tmp test ( " " ) def fail ( ) : raise runtime error ( " nooo " ) self . assert raises ( fork exception , python , py . name , preexec fn = fail )
self py = create tmp test ( ) def create stdin ( ) : state = { " count " : 0 } def stdin ( ) : count = state [ " count " ] if count == 4 : return none state [ " count " ] += 1 return str ( count ) return stdin out = python ( py . name , in = create stdin ( ) ) self . assert equal ( " 0123 " , out )
self from sh import timeout exception import signal py = create tmp test ( ) try : python ( py . name , timeout = 1 , timeout signal = signal . sigquit ) except timeout exception as e : self . assert equal ( e . exit code , signal . sigquit ) else : self . fail ( " we should have handled a timeout exception " )
self py = create tmp test ( ) append file = tempfile . named temporary file ( mode = " a+b " ) python ( py . name , in = " 1 " , out = append file ) python ( py . name , in = " 2 " , out = append file ) append file . seek ( 0 ) output = append file . read ( ) self . assert equal ( b " 12 " , output )
self py = create tmp test ( ) out = python . bake ( py . name ) . bake ( ) self . assert equal ( " bake " , out )
self py = create tmp test ( " " ) with python ( py . name ) as p : self . assert raises ( attribute error , getattr , p , " exit code " py = create tmp test ( " " ) with python ( py . name ) as p : self . assert raises ( attribute error , getattr , p , " exit code " )
self import time child = create tmp test ( ) parent = create tmp test ( """ import osimport timeimport syschild file = sys . argv[1]output file = sys . argv[2]os . spawnlp(os . p nowait , " python " , " python " , child file , output file)time . sleep(1) # give child a chance to set up """ ) output file = tempfile . named temporary file ( delete = true ) python ( parent . name , child . name , output file . name ) time . sleep ( 3 ) out = output file . readlines ( ) [ 0 ] self . assert equal ( out , b " made it!\ " )
self from sh import error return code 2 producer = create tmp test ( ) consumer = create tmp test ( """ import sysfor line in sys . stdin: pass """ ) direct pipe = python ( producer . name , piped = true ) self . assert raises ( error return code 2 , python , direct pipe , consumer . name )
self from sh import error return code 2 producer = create tmp test ( ) middleman = create tmp test ( """ import sysfor line in sys . stdin: print( " > " + line) """ ) consumer = create tmp test ( """ import sysfor line in sys . stdin: pass """ ) producer normal pipe = python ( producer . name , piped = true ) middleman normal pipe = python ( producer normal pipe , middleman . name , piped = true ) self . assert raises ( error return code 2 , python , middleman normal pipe , consumer . name )
self py = create tmp test ( ) with ulimit ( resource . rlimit nofile , 2048 ) : cutoff fd = 1024 pipes = [ ] for i in xrange ( cutoff fd ) : master , slave = os . pipe ( ) pipes . append ( ( master , slave ) ) if slave >= cutoff fd : break python ( py . name ) for master , slave in pipes : os . close ( master ) os . close ( slave )
self self . assert raises ( deprecation warning , sh . args , env = { } self . assert raises ( deprecation warning , sh . args , env = { } )
self def go ( ) : # we have to use exec , because in py3 , this syntax raises a # syntax error upon compilation exec ( " from sh import * " ) self . assert raises ( runtime error , go def go ( ) : # we have to use exec , because in py3 , this syntax raises a # syntax error upon compilation exec ( " from sh import * " ) self . assert raises ( runtime error , go )
self py = create tmp test ( """ print( " cool " ) """ ) out = python ( py . name , " % " ) out = python ( py . name , " %% " ) out = python ( py . name , " %%% " )
self py = create tmp test ( ) read , write = os . pipe ( ) stdin = os . fdopen ( read , " r " ) python ( py . name , in = stdin )
self from sh import ls wraps ( ls ) ( lambda f : true from sh import ls wraps ( ls ) ( lambda f : true )
self import signal import sh sig name = " signal exception %d " % signal . sigquit sig = getattr ( sh , sig name ) from sh import signal exception sigquit self . assert equal ( sig , signal exception sigquit )
self import sh py = create tmp test ( """ print( " cool " ) """ ) p = python ( py . name , iter = true ) for i in range ( 100 ) : try : next ( p ) except stop iteration : pass
self import signal def handler ( num , frame ) : pass signal . signal ( signal . sigalrm , handler ) py = create tmp test ( ) p = python ( py . name , bg = true ) signal . alarm ( 1 ) p . wait ( )
self import sh out = string io ( ) sh = sh ( out = out ) sh . echo ( " n " , " test " ) self . assert equal ( " test " , out . getvalue ( ) import sh out = string io ( ) sh = sh ( out = out ) sh . echo ( " n " , " test " ) self . assert equal ( " test " , out . getvalue ( ) )
self import sh out = string io ( ) from sh import echo sh = sh ( out = out ) echo ( " n " , " test " ) self . assert equal ( " " , out . getvalue ( ) import sh out = string io ( ) from sh import echo sh = sh ( out = out ) echo ( " n " , " test " ) self . assert equal ( " " , out . getvalue ( ) )
self import sh out = string io ( ) sh = sh ( out = out ) import sh sh . echo ( " n " , " test " ) self . assert equal ( " test " , out . getvalue ( ) import sh out = string io ( ) sh = sh ( out = out ) import sh sh . echo ( " n " , " test " ) self . assert equal ( " test " , out . getvalue ( ) )
self import sh sh = sh ( ) omg = sh from omg import pytho import sh sh = sh ( ) omg = sh from omg import python
self def unallowed import ( ) : os = os from os import path self . assert raises ( import error , unallowed import def unallowed import ( ) : os = os from os import path self . assert raises ( import error , unallowed import )
ob return hasattr ( ob , " call " eturn hasattr ( ob , " call " )
fn return len ( inspect . getfullargspec ( fn ) . args eturn len ( inspect . getfullargspec ( fn ) . args )
fn return len ( inspect . getargspec ( fn ) . args eturn len ( inspect . getargspec ( fn ) . args )
self , f if hasattr ( f , " fileno " ) : fd = f . fileno ( ) self . fd lookup [ fd ] = f self . fo lookup [ f ] = fd else : self . fd lookup [ f ] = f self . fo lookup [ f ] = , f if hasattr ( f , " fileno " ) : fd = f . fileno ( ) self . fd lookup [ fd ] = f self . fo lookup [ f ] = fd else : self . fd lookup [ f ] = f self . fo lookup [ f ] = f
self , f if hasattr ( f , " fileno " ) : fd = f . fileno ( ) del self . fd lookup [ fd ] del self . fo lookup [ f ] else : del self . fd lookup [ f ] del self . fo lookup [ f , f if hasattr ( f , " fileno " ) : fd = f . fileno ( ) del self . fd lookup [ fd ] del self . fo lookup [ f ] else : del self . fd lookup [ f ] del self . fo lookup [ f ]
self , f return self . fo lookup . get ( f , f return self . fo lookup . get ( f )
self , fd return self . fd lookup . get ( fd , fd return self . fd lookup . get ( fd )
self , f self . register ( f , select . pollout , f self . register ( f , select . pollout )
self , f self . register ( f , select . pollerr | select . pollhup | select . pollnval , f self . register ( f , select . pollerr | select . pollhup | select . pollnval )
self , f fd = self . get file descriptor ( f ) self . poll . unregister ( fd ) self . remove fileobject ( f , f fd = self . get file descriptor ( f ) self . poll . unregister ( fd ) self . remove fileobject ( f )
self , f , l if f not in l : l . append ( f , f , l if f not in l : l . append ( f )
self , f , l if f in l : l . remove ( f , f , l if f in l : l . remove ( f )
self , f self . register ( f , self . rlist , f self . register ( f , self . rlist )
self , f self . register ( f , self . wlist , f self . register ( f , self . wlist )
self , f self . register ( f , self . xlist , f self . register ( f , self . xlist )
self , f self . unregister ( f , self . rlist ) self . unregister ( f , self . wlist ) self . unregister ( f , self . xlist , f self . unregister ( f , self . rlist ) self . unregister ( f , self . wlist ) self . unregister ( f , self . xlist )
text , num = 4 lines = [ ] for line in text . split ( " \ " ) : line = ( " " * num ) + line lines . append ( line ) return " \ " . join ( lines , num = 4 lines = [ ] for line in text . split ( " \ " ) : line = ( " " * num ) + line lines . append ( line ) return " \ " . join ( lines )
name exc = none try : return rc exc cache [ name ] except key error : m = rc exc regex . match ( name ) if m : base = m . group ( 1 ) rc or sig name = m . group ( 2 ) if base == " signal exception " : try : rc = int ( rc or sig name ) except value error : rc = getattr ( signal , rc or sig name ) else : rc = int ( rc or sig name ) exc = get rc exc ( rc ) return exc
rc try : return rc exc cache [ rc ] except key error : pass if rc > 0 : name = " error return code %d " % rc base = error return code else : signame = signal mapping [ abs ( rc ) ] name = " signal exception " + signame base = signal exception exc = error return code meta ( name , ( base , ) , { " exit code " : rc } ) rc exc cache [ rc ] = exc return exc
path , * args , ** kwargs expanded = glob results ( path , old glob ( path , * args , ** kwargs ) ) return expande , * args , ** kwargs expanded = glob results ( path , old glob ( path , * args , ** kwargs ) ) return expanded
name , baked args = none path = resolve command path ( name ) cmd = none if path : cmd = command ( path ) if baked args : cmd = cmd . bake ( ** baked args ) return cm , baked args = none path = resolve command path ( name ) cmd = none if path : cmd = command ( path ) if baked args : cmd = cmd . bake ( ** baked args ) return cmd
self , context if context : context = context . replace ( " % " , " %% " ) self . context = context or " " , context if context : context = context . replace ( " % " , " %% " ) self . context = context or " "
self , name , context new name = self . name + " . " + name new context = self . context + " . " + context l = logger ( new name , new context ) return , name , context new name = self . name + " . " + name new context = self . context + " . " + context l = logger ( new name , new context ) return l
self , msg , * args self . log . info ( self . format msg ( msg , * args ) , msg , * args self . log . info ( self . format msg ( msg , * args ) )
self , msg , * args self . log . debug ( self . format msg ( msg , * args ) , msg , * args self . log . debug ( self . format msg ( msg , * args ) )
self , msg , * args self . log . error ( self . format msg ( msg , * args ) , msg , * args self . log . error ( self . format msg ( msg , * args ) )
self , msg , * args self . log . exception ( self . format msg ( msg , * args ) , msg , * args self . log . exception ( self . format msg ( msg , * args ) )
cmd , call args , pid = none if pid : s = " < command %r , pid %d> " % ( cmd , pid ) else : s = " < command %r> " % cmd return , call args , pid = none if pid : s = " < command %r , pid %d> " % ( cmd , pid ) else : s = " < command %r> " % cmd return s
self , code ca = self . call args exc class = get exc exit code would raise ( code , ca [ " ok code " ] , ca [ " piped " ] ) if exc class : exc = exc class ( self . ran , self . process . stdout , self . process . stderr , ca [ " truncate exc " ] ) raise exc
self self . wait ( ) return self . process . stdou self . wait ( ) return self . process . stdout
self self . wait ( ) return self . process . exit cod self . wait ( ) return self . process . exit code
self if self . stopped iteration : raise stop iteration ( ) while true : try : chunk = self . process . pipe queue . get ( true , 0 . 001 ) except empty : if self . call args [ " iter noblock " ] : return errno . ewouldblock else : if chunk is none : self . wait ( ) self . stopped iteration = true raise stop iteration ( ) try : return chunk . decode ( self . call args [ " encoding " ] , self . call args [ " decode errors " ] ) except unicode decode error : return chunk
def tl = command . thread local if not hasattr ( tl , " prepend stack " ) : tl . prepend stack = [ ] return tl . prepend stactl = command . thread local if not hasattr ( tl , " prepend stack " ) : tl . prepend stack = [ ] return tl . prepend stack
ob fileno = get fileno ( ob ) is tty = false if fileno : is tty = os . isatty ( fileno ) return is tty
ob fileno = get fileno ( ob ) is pipe = false if fileno : fd stat = os . fstat ( fileno ) is pipe = stat . s isfifo ( fd stat . st mode ) return is pipileno = get fileno ( ob ) is pipe = false if fileno : fd stat = os . fstat ( fileno ) is pipe = stat . s isfifo ( fd stat . st mode ) return is pipe
args , kwargs , sep , prefix processed args = [ ] encode = encode to py3bytes or py2str for arg in args : if isinstance ( arg , ( list , tuple ) ) : if isinstance ( arg , glob results ) and not arg : arg = [ arg . path ] for sub arg in arg : processed args . append ( encode ( sub arg ) ) elif isinstance ( arg , dict ) : processed args += aggregate keywords ( arg , sep , prefix , raw = true ) else : processed args . append ( encode ( arg ) ) processed args += aggregate keywords ( kwargs , sep , prefix ) return processed args
fd , rows cols rows , cols = rows cols tiocswinsz = getattr ( termios , ' tiocswinsz ' , 2146929561 ) s = struct . pack ( ' hhhh ' , rows , cols , 0 , 0 ) fcntl . ioctl ( fd , tiocswinsz , s )
exit code if os . wifsignaled ( exit code ) : exit code = os . wtermsig ( exit code ) # otherwise just give us a normal exit code elif os . wifexited ( exit code ) : exit code = os . wexitstatus ( exit code ) else : raise runtime error ( " unknown child exit status! " ) return exit code
syscall , * args , ** kwargs ret = none while true : try : ret = syscall ( * args , ** kwargs ) except os error as e : if e . errno == errno . eintr : continue else : raise else : break return ret
self exc = none try : exc = self . output thread exc queue . get ( false ) except empty : pass return ex exc = none try : exc = self . output thread exc queue . get ( false ) except empty : pass return exc
self exc = none try : exc = self . input thread exc queue . get ( false ) except empty : pass return ex exc = none try : exc = self . input thread exc queue . get ( false ) except empty : pass return exc
self , buf self . stdout stream . stream bufferer . change buffering ( buf , buf self . stdout stream . stream bufferer . change buffering ( buf )
self , buf self . stderr stream . stream bufferer . change buffering ( buf , buf self . stderr stream . stream bufferer . change buffering ( buf )
self return " " . encode ( self . call args [ " encoding " ] ) . join ( self . stdout return " " . encode ( self . call args [ " encoding " ] ) . join ( self . stdout )
self return " " . encode ( self . call args [ " encoding " ] ) . join ( self . stderr return " " . encode ( self . call args [ " encoding " ] ) . join ( self . stderr )
self return os . getpgid ( self . pid )
self , sig self . log . debug ( " sending signal %d to group " , sig ) os . killpg ( self . get pgid ( ) , sig , sig self . log . debug ( " sending signal %d to group " , sig ) os . killpg ( self . get pgid ( ) , sig )
self , sig self . log . debug ( " sending signal %d " , sig ) os . kill ( self . pid , sig , sig self . log . debug ( " sending signal %d " , sig ) os . kill ( self . pid , sig )
self self . log . debug ( " killing group " ) self . signal group ( signal . sigkill self . log . debug ( " killing group " ) self . signal group ( signal . sigkill )
self self . log . debug ( " killing " ) self . signal ( signal . sigkill self . log . debug ( " killing " ) self . signal ( signal . sigkill )
self self . log . debug ( " terminating " ) self . signal ( signal . sigterm self . log . debug ( " terminating " ) self . signal ( signal . sigterm )
ev , timeout = none triggered = ev . wait ( timeout ) if is py26 : triggered = ev . is set ( ) return triggere, timeout = none triggered = ev . wait ( timeout ) if is py26 : triggered = ev . is set ( ) return triggered
timeout fn , timeout event , handle exit code , is alive , quit if timeout event : while not quit . is set ( ) : timed out = event wait ( timeout event , 0 . 1 ) if timed out : timeout fn ( ) break if handle exit code and not running tests : # pragma: no cover alive = true while alive : quit . wait ( 1 ) alive , exit code = is alive ( ) handle exit code ( exit code )
stdin def fn ( ) : try : chunk = stdin . get ( true , 0 . 1 ) except empty : raise not yet ready to read if chunk is none : raise done reading forever return chunk return fn def fn ( ) : try : chunk = stdin . get ( true , 0 . 1 ) except empty : raise not yet ready to read if chunk is none : raise done reading forever return chunk return fn
stdin def fn ( ) : try : data = stdin ( ) except done reading forever : raise if not data : raise done reading forever return data return fn def fn ( ) : try : data = stdin ( ) except done reading forever : raise if not data : raise done reading forever return data return fn
stdin bufsize = 1024 iter str = ( stdin [ i : i + bufsize ] for i in range ( 0 , len ( stdin ) , bufsize ) ) return get iter chunk reader ( iter str )
stdin def fn ( ) : try : if is py3 : chunk = stdin . next ( ) else : chunk = stdin . next ( ) return chunk except stop iteration : raise done reading forever return fn def fn ( ) : try : if is py3 : chunk = stdin . next ( ) else : chunk = stdin . next ( ) return chunk except stop iteration : raise done reading forever return fn
bf type if bf type == 1 : bufsize = 1024 # unbuffered elif bf type == 0 : bufsize = 1 # or buffered by specific amount else : bufsize = bf type return bufsize
handler handler = fdopen ( handler , " w " , closefd = false ) return get file chunk consumer ( handler ler handler = fdopen ( handler , " w " , closefd = false ) return get file chunk consumer ( handler )
handler , encoding , decode errors def process ( chunk ) : handler . write ( chunk . decode ( encoding , decode errors ) ) return false def finish ( ) : pass return process , finisler , encoding , decode errors def process ( chunk ) : handler . write ( chunk . decode ( encoding , decode errors ) ) return false def finish ( ) : pass return process , finish
self return self . stream
lock def wrapped ( fn ) : fn = contextmanager ( fn ) @ contextmanager def wrapped2 ( * args , ** kwargs ) : with lock : with fn ( * args , ** kwargs ) : yield return wrapped2 return wrappe def wrapped ( fn ) : fn = contextmanager ( fn ) @ contextmanager def wrapped2 ( * args , ** kwargs ) : with lock : with fn ( * args , ** kwargs ) : yield return wrapped2 return wrapped
path orig path = os . getcwd ( ) os . chdir ( path ) try : yield finally : os . chdir ( orig path )
kwargs kwargs str = " , " . join ( [ " %s=%r " % ( k , v ) for k , v in kwargs . items ( ) ] ) raise deprecation warning ( """ sh . args() has been deprecated because it was never thread safe . use thefollowing instead: sh2 = sh({kwargs}) sh2 . your command()or sh2 = sh({kwargs}) from sh2 import your command your command() """ . format ( kwargs = kwargs str ) )
self , path = none if path : os . chdir ( path ) else : os . chdir ( os . path . expanduser ( ' ~ ' ) , path = none if path : os . chdir ( path ) else : os . chdir ( os . path . expanduser ( ' ~ ' ) )
self , program , paths = none return which ( program , paths , program , paths = none return which ( program , paths )
orig cmd = orig . bake ( tty out = false ) return cmd
orig prompt = " [sudo] password for %s: " % getpass . getuser ( ) def stdin ( ) : pw = getpass . getpass ( prompt = prompt ) + " \ " yield pw def process ( args , kwargs ) : password = kwargs . pop ( " password " , none ) if password is none : pass getter = stdin ( ) else : pass getter = password . rstrip ( " \ " ) + " \ " kwargs [ " in " ] = pass getter return args , kwargs cmd = orig . bake ( " s " , arg preprocess = process ) return cmd
frame return frame . f code . co filename == " <frozen importlib . bootstrap> "
name , frame mod = frame . f locals . get ( name , frame . f globals . get ( name , none ) ) return mo , frame mod = frame . f locals . get ( name , frame . f globals . get ( name , none ) ) return mod
self , mod fullname , path = none parent frame = inspect . currentframe ( ) . f back while in importlib ( parent frame ) : parent frame = parent frame . f back module = fetch module from frame ( mod fullname , parent frame ) if not module : return none if module . class . name not in self . restrict to : return none return self
parentdir prefix , root , verbose dirname = os . path . basename ( root ) if not dirname . startswith ( parentdir prefix ) : if verbose : print ( " guessing rootdir is ' %s ' , but ' %s ' doesn ' t start with " " prefix ' %s ' " % ( root , dirname , parentdir prefix ) ) raise not this method ( " rootdir doesn ' t start with parentdir prefix " ) return { " version " : dirname [ len ( parentdir prefix ) : ] , " full revisionid " : none , " dirty " : false , " error " : none }
filename try : with open ( filename ) as f : contents = f . read ( ) except environment error : raise not this method ( " unable to read version . py " ) mo = re . search ( r " version json = ' ' ' \( . *) ' ' ' # end version json " , contents , re . m | re . s ) if not mo : raise not this method ( " no version json in version . py " ) return json . loads ( mo . group ( 1 ) )
filename , versions os . unlink ( filename ) contents = json . dumps ( versions , sort keys = true , indent = 1 , separators = ( " , " , " : " ) ) with open ( filename , " w " ) as f : f . write ( short version py % contents ) print ( " set %s to ' %s ' " % ( filename , versions [ " version " ] ) )
pieces if " + " in pieces . get ( " closest tag " , " " ) : return " . " return " + "
pieces if pieces [ " closest tag " ] : rendered = pieces [ " closest tag " ] if pieces [ " distance " ] or pieces [ " dirty " ] : rendered += plus or dot ( pieces ) rendered += " %d . g%s " % ( pieces [ " distance " ] , pieces [ " short " ] ) if pieces [ " dirty " ] : rendered += " . dirty " else : # exception #1 rendered = " 0+untagged . %d . g%s " % ( pieces [ " distance " ] , pieces [ " short " ] ) if pieces [ " dirty " ] : rendered += " . dirty " return rendered
pieces if pieces [ " closest tag " ] : rendered = pieces [ " closest tag " ] if pieces [ " distance " ] : rendered += " . post . dev%d " % pieces [ " distance " ] else : # exception #1 rendered = " 0 . post . dev%d " % pieces [ " distance " ] return rendered
pieces if pieces [ " closest tag " ] : rendered = pieces [ " closest tag " ] if pieces [ " distance " ] or pieces [ " dirty " ] : rendered += " . post%d " % pieces [ " distance " ] if pieces [ " dirty " ] : rendered += " . dev0 " rendered += plus or dot ( pieces ) rendered += " g%s " % pieces [ " short " ] else : # exception #1 rendered = " 0 . post%d " % pieces [ " distance " ] if pieces [ " dirty " ] : rendered += " . dev0 " rendered += " +g%s " % pieces [ " short " ] return rendered
pieces if pieces [ " closest tag " ] : rendered = pieces [ " closest tag " ] if pieces [ " distance " ] : rendered += " %d g%s " % ( pieces [ " distance " ] , pieces [ " short " ] ) else : # exception #1 rendered = pieces [ " short " ] if pieces [ " dirty " ] : rendered += " dirty " return rendered
pieces if pieces [ " closest tag " ] : rendered = pieces [ " closest tag " ] rendered += " %d g%s " % ( pieces [ " distance " ] , pieces [ " short " ] ) else : # exception #1 rendered = pieces [ " short " ] if pieces [ " dirty " ] : rendered += " dirty " return rendered
item if " slow " in item . keywords and not item . config . getoption ( " runslow " ) : pytest . skip ( " need runslow option to run " if " slow " in item . keywords and not item . config . getoption ( " runslow " ) : pytest . skip ( " need runslow option to run " )
x try : return x . dask graph ( ) is not none except ( attribute error , type error ) : return false
self , filename = " mydask " , format = none , optimize graph = false , ** kwargs return visualize ( self , filename = filename , format = format , optimize graph = optimize graph , ** kwargs )
self , ** kwargs ( result , ) = persist ( self , traverse = false , ** kwargs ) return result
self , ** kwargs ( result , ) = compute ( self , traverse = false , ** kwargs ) return result
cls , dsk , keys , scheduler = none , get = none , ** kwargs schedule = get scheduler ( scheduler = scheduler , cls = cls , get = get ) dsk2 = optimization function ( cls ) ( ensure dict ( dsk ) , keys , ** kwargs ) return schedule ( dsk2 , keys , ** kwargs )
dsk , keys , ** kwargs return ds , keys , ** kwargs return dsk
x return getattr ( x , " dask optimize " , dont optimize turn getattr ( x , " dask optimize " , dont optimize )
d return type ( d ) . name , normalize token ( list ( d . items ( ) ) turn type ( d ) . name , normalize token ( list ( d . items ( ) ) )
s return normalize token ( sorted ( s , key = str ) turn normalize token ( sorted ( s , key = str ) )
seq return type ( seq ) . name , list ( map ( normalize token , seq ) return type ( seq ) . name , list ( map ( normalize token , seq ) )
o method = getattr ( o , " dask tokenize " , none ) if method is not none : return method ( ) return normalize function ( o ) if callable ( o ) else uuid . uuid4 ( ) . hethod = getattr ( o , " dask tokenize " , none ) if method is not none : return method ( ) return normalize function ( o ) if callable ( o ) else uuid . uuid4 ( ) . hex
t t = t [ : 3 ] i = sum ( v * 256 ** ( len ( t ) i 1 ) for i , v in enumerate ( t ) ) h = hex ( int ( i ) ) [ 2 : ] . upper ( ) h = " 0 " * ( 6 len ( h ) ) + h return " # " + h
x , timeout = none , return when = " all completed " try : from distributed import wait return wait ( x , timeout = timeout , return when = return when ) except ( import error , value error ) : return x
buf return xxhash . xxh64 ( buf ) . digest ( )
buf return hashlib . sha1 ( buf ) . digest ( )
buf , hasher = none if hasher is not none : try : return hasher ( buf ) except ( type error , overflow error ) : # some hash libraries may have overly strict type checking , # not accepting all buffers pass for hasher in hashers : try : return hasher ( buf ) except ( type error , overflow error ) : pass raise type error ( " unsupported type for hashing: %s " % ( type ( buf ) , ) )
buf , hasher = none h = hash buffer ( buf , hasher ) s = binascii . b2a hex ( h ) return s . decode ( )
x if x is none : return set ( ) elif isinstance ( x , set ) : return x elif not isinstance ( x , ( list , set ) ) : x = [ x ] return set ( x x is none : return set ( ) elif isinstance ( x , set ) : return x elif not isinstance ( x , ( list , set ) ) : x = [ x ] return set ( x )
func while hasattr ( func , " func " ) : func = func . func return fun while hasattr ( func , " func " ) : func = func . func return func
task funcs = set ( ) work = [ task ] sequence types = { list , tuple } while work : new work = [ ] for task in work : if type ( task ) in sequence types : if istask ( task ) : funcs . add ( unwrap partial ( task [ 0 ] ) ) new work += task [ 1 : ] else : new work += task work = new work return funcs
dsk , head1 , head2 , merge dsk2 = dict ( ) for k , v in dsk . items ( ) : try : if ( istask ( v ) and v [ 0 ] == head1 and v [ 1 ] in dsk and istask ( dsk [ v [ 1 ] ] ) and dsk [ v [ 1 ] ] [ 0 ] == head2 ) : dsk2 [ k ] = merge ( v , dsk [ v [ 1 ] ] ) else : dsk2 [ k ] = v except type error : dsk2 [ k ] = v return dsk2
x try : hash ( x ) return true except type error : return false
dsk , x if istask ( x ) : return true try : if x in dsk : return true except exception : pass if isinstance ( x , list ) : for i in x : if has tasks ( dsk , i ) : return true return false
task for item in task : if istask ( item ) : for i in preorder traversal ( item ) : yield i elif isinstance ( item , list ) : yield list for i in preorder traversal ( item ) : yield i else : yield item
res , keys if isinstance ( keys , list ) : return tuple ( lists to tuples ( r , k ) for r , k in zip ( res , keys ) ) return re , keys if isinstance ( keys , list ) : return tuple ( lists to tuples ( r , k ) for r , k in zip ( res , keys ) ) return res
arg , cache , dsk = none if isinstance ( arg , list ) : return [ execute task ( a , cache ) for a in arg ] elif istask ( arg ) : func , args = arg [ 0 ] , arg [ 1 : ] args2 = [ execute task ( a , cache ) for a in args ] return func ( * args2 ) elif not ishashable ( arg ) : return arg elif arg in cache : return cache [ arg ] else : return arg
dsk , out , cache = none for k in flatten ( out ) if isinstance ( out , list ) else [ out ] : if k not in dsk : raise key error ( " {0} is not a key in the graph " . format ( k ) ) if cache is none : cache = { } for key in toposort ( dsk ) : task = dsk [ key ] result = execute task ( task , cache ) cache [ key ] = result result = execute task ( out , cache ) if isinstance ( out , list ) : result = lists to tuples ( result , out ) return result
seq , container = list if isinstance ( seq , str ) : yield seq else : for item in seq : if isinstance ( item , container ) : for item2 in flatten ( item , container = container ) : yield item2 else : yield item
d , keys return toposort ( d , keys = keys , returncycle = true )
d , keys return not getcycle ( d , keys )
x if istask ( x ) or type ( x ) is list : return ( literal ( x ) , ) return x
q while true : try : return q . get ( block = true , timeout = 0 . 1 ) except empty : pasile true : try : return q . get ( block = true , timeout = 0 . 1 ) except empty : pass
key , state , delete = true if key in state [ " waiting data " ] : assert not state [ " waiting data " ] [ key ] del state [ " waiting data " ] [ key ] state [ " released " ] . add ( key ) if delete : del state [ " cache " ] [ key ]
ind , coll if isinstance ( ind , list ) : return tuple ( [ nested get ( i , coll ) for i in ind ] ) else : return coll [ ind ]
e , dumps rais dumps raise
exc , tb = none if exc . traceback is not tb : raise exc . with traceback ( tb ) raise ex , tb = none if exc . traceback is not tb : raise exc . with traceback ( tb ) raise exc
func , args = ( ) , kwds = { } , callback = none res = func ( * args , ** kwds ) if callback is not none : callback ( res )
item return ( type ( item ) . name , item )
x return x + turn x + 1
x , y return x + y return x + y
self d = { " x " : 1 , " y " : ( add , " x " , 10 ) } assert self . get ( d , " y " ) == 1 d = { " x " : 1 , " y " : ( add , " x " , 10 ) } assert self . get ( d , " y " ) == 11
self f = lambda x , y : x + len ( y ) d = { " x " : 1 , " y " : ( f , " x " , set ( [ 1 ] ) ) } assert self . get ( d , " y " ) == f = lambda x , y : x + len ( y ) d = { " x " : 1 , " y " : ( f , " x " , set ( [ 1 ] ) ) } assert self . get ( d , " y " ) == 2
self d = { " x%d " % ( i + 1 ) : ( inc , " x%d " % i ) for i in range ( 10000 ) } d [ " x0 " ] = 0 assert self . get ( d , " x10000 " ) == 1000 d = { " x%d " % ( i + 1 ) : ( inc , " x%d " % i ) for i in range ( 10000 ) } d [ " x0 " ] = 0 assert self . get ( d , " x10000 " ) == 10000
func , args , kwargs = none if kwargs : return func ( * args , ** kwargs ) else : return func ( * args , args , kwargs = none if kwargs : return func ( * args , ** kwargs ) else : return func ( * args )
func , * seqs if isinstance ( seqs [ 0 ] , ( list , iterator ) ) : return [ deepmap ( func , * items ) for items in zip ( * seqs ) ] else : return func ( * seqs )
func , seq if not seq : return seq n = 0 tmp = seq while isinstance ( tmp , list ) : n += 1 tmp = tmp [ 0 ] return ndeepmap ( n , func , seq , seq if not seq : return seq n = 0 tmp = seq while isinstance ( tmp , list ) : n += 1 tmp = tmp [ 0 ] return ndeepmap ( n , func , seq )
n , func , seq if n == 1 : return [ func ( item ) for item in seq ] elif n > 1 : return [ ndeepmap ( n 1 , func , item ) for item in seq ] elif isinstance ( seq , list ) : return func ( seq [ 0 ] ) else : return func ( seq )
exceptions try : yield except exceptions : pasptions try : yield except exceptions : pass
mod name , error msg try : return import module ( mod name ) except import error : raise runtime error ( error msg )
text , extension = " " , open = open , mode = " w " with tmpfile ( extension = extension ) as filename : f = open ( filename , mode = mode ) try : f . write ( text ) finally : try : f . close ( ) except attribute error : pass yield filenam , extension = " " , open = open , mode = " w " with tmpfile ( extension = extension ) as filename : f = open ( filename , mode = mode ) try : f . write ( text ) finally : try : f . close ( ) except attribute error : pass yield filename
new cwd old cwd = os . getcwd ( ) os . chdir ( new cwd ) try : yield finally : os . chdir ( old cwd cwd old cwd = os . getcwd ( ) os . chdir ( new cwd ) try : yield finally : os . chdir ( old cwd )
dir = none with tmpdir ( dir ) as dirname : with changed cwd ( dirname ) : yield dirnam= none with tmpdir ( dir ) as dirname : with changed cwd ( dirname ) : yield dirname
seq if isinstance ( seq , iterator ) : seq = list ( seq ) if isinstance ( seq , ( tuple , list ) ) : seq = list ( map ( concrete , seq ) ) return seq
n , random state = none import numpy as np if not all ( hasattr ( random state , attr ) for attr in [ " normal " , " beta " , " bytes " , " uniform " ] ) : random state = np . random . random state ( random state ) random data = random state . bytes ( 624 * n * 4 ) l = list ( np . frombuffer ( random data , dtype = np . uint32 ) . reshape ( ( n , 1 ) ) ) assert len ( l ) == n return l
i return isinstance ( i , integral ) or ( isinstance ( i , float ) and i . is integer ( ) )
func if isinstance ( func , functools . partial ) : return getargspec ( func . func ) func = getattr ( func , " wrapped " , func ) if isinstance ( func , type ) : return inspect . getfullargspec ( func . init ) else : return inspect . getfullargspec ( func )
func s = inspect . signature ( func ) return [ n for n , p in s . parameters . items ( ) if p . kind in [ p . positional or keyword , p . positional only , p . keyword only ] ]
self , type , func = none def wrapper ( func ) : if isinstance ( type , tuple ) : for t in type : self . register ( t , func ) else : self . lookup [ type ] = func return func return wrapper ( func ) if func is not none else wrapper
self , cls lk = self . lookup try : impl = lk [ cls ] except key error : pass else : return impl toplevel , , = cls . module . partition ( " . " ) try : register = self . lazy . pop ( toplevel ) except key error : pass else : register ( ) return self . dispatch ( cls ) for cls2 in inspect . getmro ( cls ) [ 1 : ] : if cls2 in lk : lk [ cls ] = lk [ cls2 ] return lk [ cls2 ] raise type error ( " no dispatch for {0} " . format ( cls ) )
filename try : os . unlink ( filename ) except os error as e : if e . errno != enoent : raise
doc if doc is none : return " " return " \ " . join ( [ skip doctest ( line ) for line in doc . split ( " \ " ) ] if doc is none : return " " return " \ " . join ( [ skip doctest ( line ) for line in doc . split ( " \ " ) ] )
doc , args lines = doc . split ( " \ " ) for arg in args : subset = [ ( i , line ) for i , line in enumerate ( lines ) if re . match ( r " ^\\s* " + arg + " ?: " , line ) ] if len ( subset ) == 1 : [ ( i , line ) ] = subset lines [ i ] = line + " ( not supported in dask) " return " \ " . join ( lines )
typ if not typ . module or typ . module == " builtins " : return typ . name else : return typ . module + " . " + typ . name
s if isinstance ( s , bytes ) : return s if hasattr ( s , " encode " ) : return s . encode ( ) msg = " object %s is neither a bytes object nor has an encode method " raise type error ( msg % s )
s if isinstance ( s , str ) : return s if hasattr ( s , " decode " ) : return s . decode ( ) msg = " object %s is neither a bytes object nor has an encode method " raise type error ( msg % s )
tup , loc , val l = list ( tup ) l [ loc ] = val return tuple ( l )
buf , lines if any ( not isinstance ( x , str ) for x in lines ) : lines = [ str ( x ) for x in lines ] buf . write ( " \ " . join ( lines ) , lines if any ( not isinstance ( x , str ) for x in lines ) : lines = [ str ( x ) for x in lines ] buf . write ( " \ " . join ( lines ) )
self , * args , ** kwargs return self . lock . acquire ( * args , ** kwargs , * args , ** kwargs return self . lock . acquire ( * args , ** kwargs )
self , * args , ** kwargs return self . lock . release ( * args , ** kwargs , * args , ** kwargs return self . lock . release ( * args , ** kwargs )
self return self . lock . locked ( return self . lock . locked ( )
collection = none , scheduler = none from . import multiprocessing from . base import get scheduler actual get = get scheduler ( collections = [ collection ] , scheduler = scheduler ) if actual get == multiprocessing . get : return multiprocessing . get context ( ) . manager ( ) . lock ( ) return serializable lock ( )
d if type ( d ) is dict : return d elif hasattr ( d , " dicts " ) : result = { } for dd in d . dicts . values ( ) : result . update ( dd ) return result return dict ( d type ( d ) is dict : return d elif hasattr ( d , " dicts " ) : result = { } for dd in d . dicts . values ( ) : result . update ( dd ) return result return dict ( d )
cls , op raise not implemented error
cls , op , inv = false raise not implemented error
args , ** kwargs function = kwargs . pop ( " function " ) other = kwargs . pop ( " other " ) args2 = list ( args ) for i , arg in other : args2 . insert ( i , arg ) return function ( * args2 , ** kwargs )
x from . base import is dask collection return bool ( hasattr ( x , " shape " ) and isinstance ( x . shape , tuple ) and hasattr ( x , " dtype " ) and not any ( is dask collection ( n ) for n in x . shape ) )
df typ = type ( df ) return ( all ( hasattr ( typ , name ) for name in ( " groupby " , " head " , " merge " , " mean " ) ) and all ( hasattr ( df , name ) for name in ( " dtypes " , " columns " ) ) and not any ( hasattr ( typ , name ) for name in ( " name " , " dtype " ) ) )
s typ = type ( s ) return ( all ( hasattr ( typ , name ) for name in ( " groupby " , " head " , " mean " ) ) and all ( hasattr ( s , name ) for name in ( " dtype " , " name " ) ) and " index " not in typ . name . lower ( ) )
n if n >= 1 : return " % . 2f s " % n if n >= 1e 3 : return " % . 2f ms " % ( n * 1e3 ) return " % . 2f us " % ( n * 1e6 )
n if n > 1e15 : return " %0 . 2f pb " % ( n / 1e15 ) if n > 1e12 : return " %0 . 2f tb " % ( n / 1e12 ) if n > 1e9 : return " %0 . 2f gb " % ( n / 1e9 ) if n > 1e6 : return " %0 . 2f mb " % ( n / 1e6 ) if n > 1e3 : return " %0 . 2f k b " % ( n / 1000 ) return " %d b " % n
func , keyword try : return keyword in inspect . signature ( func ) . parameters except exception : return fals , keyword try : return keyword in inspect . signature ( func ) . parameters except exception : return false
task func = task [ 0 ] if func is apply : func = task [ 1 ] if hasattr ( func , " funcs " ) : if len ( func . funcs ) > 1 : return " {0}( . . . ) " . format ( funcname ( func . funcs [ 0 ] ) ) else : head = funcname ( func . funcs [ 0 ] ) else : head = funcname ( func ) if any ( has sub tasks ( i ) for i in task [ 1 : ] ) : return " {0}( . . . ) " . format ( head ) else : return head
task if istask ( task ) : return true elif isinstance ( task , list ) : return any ( has sub tasks ( i ) for i in task ) else : return false
x try : return str ( hash ( x ) ) except type error : return str ( hash ( str ( x ) ) y : return str ( hash ( x ) ) except type error : return str ( hash ( str ( x ) ) )
x , cache = none s = str ( x ) for pattern in ( hashpat , uuidpat ) : m = re . search ( pattern , s ) if m is not none : for h in m . groups ( ) : if cache is not none : n = cache . get ( h , len ( cache ) ) label = " #{0} " . format ( n ) # cache will be overwritten destructively cache [ h ] = n else : label = " # " s = s . replace ( h , label ) return s
key if isinstance ( key , tuple ) : key = key [ 1 : ] if len ( key ) == 1 : [ key ] = key return str ( key ) else : return " "
dsk , filename = " mydask " , format = none , ** kwargs g = to graphviz ( dsk , ** kwargs ) return graphviz to file ( g , filename , format )
old , new , priority = " new " for k , v in new . items ( ) : k = canonical name ( k , old ) if isinstance ( v , mapping ) : if k not in old or old [ k ] is none : old [ k ] = { } update ( old [ k ] , v , priority = priority ) else : if priority == " new " or k not in old : old [ k ] = v return old
dicts result = { } for d in dicts : update ( result , d ) return result
env = none if env is none : env = os . environ d = { } for name , value in env . items ( ) : if name . startswith ( " dask " ) : varname = name [ 5 : ] . lower ( ) . replace ( " " , " . " ) try : d [ varname ] = ast . literal eval ( value ) except ( syntax error , value error ) : d [ varname ] = value result = { } set ( d , config = result ) return result
paths = paths , env = none if env is none : env = os . environ configs = [ ] if yaml : configs . extend ( collect yaml ( paths = paths ) ) configs . append ( collect env ( env = env ) ) return merge ( * configs )
config = config , defaults = defaults , ** kwargs config . clear ( ) for d in defaults : update ( config , d , priority = " old " ) update ( config , collect ( ** kwargs ) )
key , default = no default , config = config keys = key . split ( " . " ) result = config for k in keys : k = canonical name ( k , result ) try : result = result [ k ] except ( type error , index error , key error ) : if default is not no default : return default else : raise return result
aliases , config = config old = [ ] new = { } for o , n in aliases . items ( ) : value = get ( o , none , config = config ) if value is not none : old . append ( o ) new [ n ] = value for k in old : del config [ canonical name ( k , config ) ] set ( new , config = config )
new , config = config , defaults = defaults defaults . append ( new ) update ( config , new , priority = " old " )
config if isinstance ( config , mapping ) : return { k : expand environment variables ( v ) for k , v in config . items ( ) } elif isinstance ( config , str ) : return os . path . expandvars ( config ) elif isinstance ( config , ( list , tuple , builtins . set ) ) : return type ( config ) ( [ expand environment variables ( v ) for v in config ] ) else : return config
self return reverse dict ( self . dependencies return reverse dict ( self . dependencies )
self return self . layer return self . layers
self items = [ ] seen = set ( ) for d in self . layers . values ( ) : for key in d : if key not in seen : seen . add ( key ) items . append ( ( key , d [ key ] ) ) return item items = [ ] seen = set ( ) for d in self . layers . values ( ) : for key in d : if key not in seen : seen . add ( key ) items . append ( ( key , d [ key ] ) ) return items
self return [ key for key , in self . items ( ) return [ key for key , in self . items ( ) ]
self return [ value for , value in self . items ( ) return [ value for , value in self . items ( ) ]
task , substitution if isinstance ( task , dict ) : return { k : subs ( v , substitution ) for k , v in task . items ( ) } if type ( task ) in ( tuple , list , set ) : return type ( task ) ( [ subs ( x , substitution ) for x in task ] ) try : return substitution [ task ] except ( key error , type error ) : return task
ind , substitution if ind is none : return ind else : return tuple ( [ substitution . get ( c , c ) for c in ind ] )
lol , nblocks f = lambda t : ( t [ 0 ] , ) + tuple ( 0 if d == 1 else i for i , d in zip ( t [ 1 : ] , nblocks ) ) return homogeneous deepmap ( f , lol )
task if istask ( task ) : return task [ 1 : ] elif isinstance ( task , list ) : return task else : return ( )
self return traverser ( self . term , deque ( self . stack ) )
self subterms = args ( self . term ) if not subterms : # no subterms , pop off stack self . term = self . stack . pop ( ) else : self . term = subterms [ 0 ] self . stack . extend ( reversed ( subterms [ 1 : ] ) )
self return head ( self . term return head ( self . term )
self self . term = self . stack . pop ( )
self return self [ 0 ]
self return self [ 1 ]
self , sub dict term = self . rhs for key , val in sub dict . items ( ) : term = subs ( term , key , val ) return ter , sub dict term = self . rhs for key , val in sub dict . items ( ) : term = subs ( term , key , val ) return term
self , term s = traverser ( term ) for m , syms in match ( s , self . net ) : for i in m : rule = self . rules [ i ] subs = process match ( rule , syms ) if subs is not none : yield rule , subs
self , task , strategy = " bottom up " return strategies [ strategy ] ( self , task )
rule , syms subs = { } varlist = rule . varlist if not len ( varlist ) == len ( syms ) : raise runtime error ( " length of varlist doesn ' t match length of syms . " ) for v , s in zip ( varlist , syms ) : if v in subs and subs [ v ] != s : return none else : subs [ v ] = s return subs
self , key , dsk , state self . starttimes [ key ] = default timer ( , key , dsk , state self . starttimes [ key ] = default timer ( )
self , dsk , state , errored self . starttimes . clear ( ) self . durations . clear ( , dsk , state , errored self . starttimes . clear ( ) self . durations . clear ( )
x return cloudpickle . dumps ( x , protocol = pickle . highest protocol turn cloudpickle . dumps ( x , protocol = pickle . highest protocol )
exc , tb if type ( exc ) in exceptions : typ = exceptions [ type ( exc ) ] return typ ( exc , tb ) else : try : typ = type ( exc . class . name , ( remote exception , type ( exc ) ) , { " exception type " : type ( exc ) } , ) exceptions [ type ( exc ) ] = typ return typ ( exc , tb ) except type error : return exc
exc , tb exc = remote exception ( exc , tb ) raise ex , tb exc = remote exception ( exc , tb ) raise exc
def np = sys . modules . get ( " numpy " ) if np is not none : np . random . seed ( )
start = " 2000 01 01 " , end = " 2000 01 31 " , freq = " 1s " , partition freq = " 1d " , dtypes = { " name " : str , " id " : int , " x " : float , " y " : float } , seed = none , ** kwargs from dask . dataframe . io . demo import make timeseries return make timeseries ( start = start , end = end , freq = freq , partition freq = partition freq , seed = seed , dtypes = dtypes , ** kwargs )
field , schema description , records per partition , seed from mimesis . schema import schema , field field = field ( seed = seed , ** field ) schema = schema ( schema = lambda : schema description ( field ) ) for i in range ( records per partition ) : yield schema . create ( iterations = 1 ) [ 0 ]
field , schema , npartitions , records per partition , seed = none import dask . bag as db from dask . base import tokenize field = field or { } if seed is none : seed = random . random ( ) seeds = db . core . random state data python ( npartitions , seed ) name = " mimesis " + tokenize ( field , schema , npartitions , records per partition , seed ) dsk = { ( name , i ) : ( generate mimesis , field , schema , records per partition , seed ) for i , seed in enumerate ( seeds ) } return db . bag ( dsk , name , npartitions )
ls , nout out = list ( zip ( * ls ) ) if not out : out = [ ( ) ] * nout return out
args , ** kwargs pure = kwargs . pop ( " pure " , none ) if pure is none : pure = config . get ( " delayed pure " , false ) if pure : return tokenize ( * args , ** kwargs ) else : return str ( uuid . uuid4 ( ) )
method def inner ( self , other ) : return method ( other , self ) return inner
dsk , key , length return delayed ( key , dsk , length , key , length return delayed ( key , dsk , length )
self return self . ke return self . key
self return high level graph . from collections ( self . key , { self . key : self . obj } , dependencies = ( ) return high level graph . from collections ( self . key , { self . key : self . obj } , dependencies = ( ) )
self layer = { self . key : ( getattr , self . obj . key , self . attr ) } return high level graph . from collections ( self . key , layer , dependencies = [ self . obj ] layer = { self . key : ( getattr , self . obj . key , self . attr ) } return high level graph . from collections ( self . key , layer , dependencies = [ self . obj ] )
seq return seq [ 0 ]
default = none , key = none , falsey = none if default is none : return partial ( globalmethod , key = key , falsey = falsey ) return global method ( default = default , key = key , falsey = falsey )
def git refnames = " $ format:%d$ " git full = " $ format:% h$ " keywords = { " refnames " : git refnames , " full " : git full } return keywords
def cfg = versioneer config ( ) cfg . vcs = " git " cfg . style = " pep440 " cfg . tag prefix = " " cfg . parentdir prefix = " dask " cfg . versionfile source = " dask/ version . py " cfg . verbose = false return cfg
vcs , method def decorate ( f ) : """ store f in handlers[vcs][method] . """ if vcs not in handlers : handlers [ vcs ] = { } handlers [ vcs ] [ method ] = f return f return decorate
parentdir prefix , root , verbose dirname = os . path . basename ( root ) if not dirname . startswith ( parentdir prefix ) : if verbose : print ( " guessing rootdir is ' %s ' , but ' %s ' doesn ' t start with " " prefix ' %s ' " % ( root , dirname , parentdir prefix ) ) raise not this method ( " rootdir doesn ' t start with parentdir prefix " ) return { " version " : dirname [ len ( parentdir prefix ) : ] , " full revisionid " : none , " dirty " : false , " error " : none , }
pieces if pieces [ " closest tag " ] : rendered = pieces [ " closest tag " ] if pieces [ " distance " ] or pieces [ " dirty " ] : rendered += plus or dot ( pieces ) rendered += " %d . g%s " % ( pieces [ " distance " ] , pieces [ " short " ] ) if pieces [ " dirty " ] : rendered += " . dirty " else : # exception #1 rendered = " 0+untagged . %d . g%s " % ( pieces [ " distance " ] , pieces [ " short " ] ) if pieces [ " dirty " ] : rendered += " . dirty " return rendered
pieces if pieces [ " closest tag " ] : rendered = pieces [ " closest tag " ] if pieces [ " distance " ] : rendered += " . post . dev%d " % pieces [ " distance " ] else : # exception #1 rendered = " 0 . post . dev%d " % pieces [ " distance " ] return rendered
pieces if pieces [ " closest tag " ] : rendered = pieces [ " closest tag " ] if pieces [ " distance " ] or pieces [ " dirty " ] : rendered += " . post%d " % pieces [ " distance " ] if pieces [ " dirty " ] : rendered += " . dev0 " rendered += plus or dot ( pieces ) rendered += " g%s " % pieces [ " short " ] else : # exception #1 rendered = " 0 . post%d " % pieces [ " distance " ] if pieces [ " dirty " ] : rendered += " . dev0 " rendered += " +g%s " % pieces [ " short " ] return rendered
pieces if pieces [ " closest tag " ] : rendered = pieces [ " closest tag " ] if pieces [ " distance " ] or pieces [ " dirty " ] : rendered += " . post%d " % pieces [ " distance " ] if pieces [ " dirty " ] : rendered += " . dev0 " else : # exception #1 rendered = " 0 . post%d " % pieces [ " distance " ] if pieces [ " dirty " ] : rendered += " . dev0 " return rendered
seq return getsizeof ( seq ) + sum ( map ( sizeof , seq ) return getsizeof ( seq ) + sum ( map ( sizeof , seq ) )
@ import cupy @ sizeof . register ( cupy . ndarray ) def sizeof cupy ndarray ( x ) : return int ( x . nbytes port cupy @ sizeof . register ( cupy . ndarray ) def sizeof cupy ndarray ( x ) : return int ( x . nbytes )
@ import numpy as np @ sizeof . register ( np . ndarray ) def sizeof numpy ndarray ( x ) : return int ( x . nbytes port numpy as np @ sizeof . register ( np . ndarray ) def sizeof numpy ndarray ( x ) : return int ( x . nbytes )
@ from scipy import sparse @ sizeof . register ( sparse . dok matrix ) def sizeof spmatrix dok ( s ) : return s . sizeof ( ) @ sizeof . register ( sparse . spmatrix ) def sizeof spmatrix ( s ) : return sum ( sizeof ( v ) for v in s . dict . values ( ) om scipy import sparse @ sizeof . register ( sparse . dok matrix ) def sizeof spmatrix dok ( s ) : return s . sizeof ( ) @ sizeof . register ( sparse . spmatrix ) def sizeof spmatrix ( s ) : return sum ( sizeof ( v ) for v in s . dict . values ( ) )
self fields = [ " start " , " start state " , " pretask " , " posttask " , " finish " ] return tuple ( getattr ( self , i , none ) for i in fields fields = [ " start " , " start state " , " pretask " , " posttask " , " finish " ] return tuple ( getattr ( self , i , none ) for i in fields )
self callback . active . add ( self . callback callback . active . add ( self . callback )
cbs if cbs : return [ [ i for i in f if i ] for f in zip ( * cbs ) ] else : return [ ( ) , ( ) , ( ) , ( ) , ( ) ]
callbacks = none global callbacks = callbacks is none if global callbacks : callbacks , callback . active = callback . active , set ( ) try : yield callbacks or ( ) finally : if global callbacks : callback . active = callbacks
cb if isinstance ( cb , callback ) : return cb . callback elif isinstance ( cb , tuple ) : return cb else : raise type error ( " callbacks must be either ` callback` or `tuple` " )
def return current thread ( ) . idenreturn current thread ( ) . ident
x return [ turn [ ]
@ import dask cudport dask cudf
results return concat ( results lts return concat ( results )
self return self . met return self . meta
self return self . meta . dtyp return self . meta . dtype
self return ( self . dask , self . name , self . meta return ( self . dask , self . name , self . meta )
self return ( self . name , 0 return ( self . name , 0 )
self , optimize graph = true dsk = self . dask graph ( ) if optimize graph : dsk = self . dask optimize ( dsk , self . dask keys ( ) ) name = " delayed " + self . name dsk = high level graph . from collections ( name , dsk , dependencies = ( ) ) return delayed ( self . key , dsk )
self return new dd objec return new dd object
self return len ( self . divisions ) 1
self return self . reduction ( methods . size , np . sum , token = " size " , meta = int , split every = false )
self return meta nonempty ( self . meta )
self return ( self . dask , self . name , self . meta , self . divisions return ( self . dask , self . name , self . meta , self . divisions )
self return new dd object ( self . dask , self . name , self . meta , self . divisions )
self return elemwis return elemwise
self raise not implemented erro raise not implemented error
self return self . map partitions ( getattr , " index " , token = self . name + " index " , meta = self . meta . index )
self , value self . divisions = value . divisions result = map partitions ( methods . assign index , self , value ) self . dask = result . dask self . name = result . name self . meta = result . met , value self . divisions = value . divisions result = map partitions ( methods . assign index , self , value ) self . dask = result . dask self . name = result . name self . meta = result . meta
self , drop = false return self . map partitions ( m . reset index , drop = drop ) . clear divisions ( )
self return len ( self . divisions ) > 0 and self . divisions [ 0 ] is not none
self divisions = ( none , ) * ( self . npartitions + 1 ) return type ( self ) ( self . dask , self . name , self . meta , divisions )
self , n if 0 <= n < self . npartitions : name = " get partition %s %s " % ( str ( n ) , self . name ) divisions = self . divisions [ n : n + 2 ] layer = { ( name , 0 ) : ( self . name , n ) } graph = high level graph . from collections ( name , layer , dependencies = [ self ] ) return new dd object ( graph , name , self . meta , divisions ) else : msg = " n must be 0 <= n < {0} " . format ( self . npartitions ) raise value error ( msg )
self , cast type def wrapper ( ) : raise type error ( " cannot convert the series to {0} " . format ( str ( cast type ) ) ) return wrappe , cast type def wrapper ( ) : raise type error ( " cannot convert the series to {0} " . format ( str ( cast type ) ) ) return wrapper
self , func , * args , ** kwargs return map partitions ( func , self , * args , ** kwargs )
self , func , before , after , * args , ** kwargs from . rolling import map overlap return map overlap ( func , self , before , after , * args , ** kwargs )
self , n = 5 , npartitions = 1 , compute = true return self . head ( n = n , npartitions = npartitions , compute = compute , safe = true )
self , n = 5 , compute = true name = " tail %d %s " % ( n , self . name ) dsk = { ( name , 0 ) : ( m . tail , ( self . name , self . npartitions 1 ) , n ) } graph = high level graph . from collections ( name , dsk , dependencies = [ self ] ) result = new dd object ( graph , name , self . meta , self . divisions [ 2 : ] ) if compute : result = result . compute ( ) return result
self from . indexing import loc indexer return loc indexer ( self )
self return index callable ( self . partitions )
self , to replace = none , value = none , regex = false return self . map partitions ( m . replace , to replace = to replace , value = value , regex = regex , to replace = none , value = none , regex = false return self . map partitions ( m . replace , to replace = to replace , value = value , regex = regex )
self , lengths = none if lengths is true : lengths = tuple ( self . map partitions ( len ) . compute ( ) ) arr = self . values chunks = self . validate chunks ( arr , lengths ) arr . chunks = chunks return arr
self , path or buf , key , mode = " a " , append = false , ** kwargs from . io import to hdf return to hdf ( self , path or buf , key , mode , append , ** kwargs )
self , filename , ** kwargs from . io import to csv return to csv ( self , filename , ** kwargs )
self , optimize graph = true keys = self . dask keys ( ) graph = self . dask graph ( ) if optimize graph : graph = self . dask optimize ( graph , self . dask keys ( ) ) name = " delayed " + self . name graph = high level graph . from collections ( name , graph , dependencies = ( ) ) return [ delayed ( k , graph ) for k in keys ]
cls , op return lambda self : elemwise ( op , self , op return lambda self : elemwise ( op , self )
cls , op , inv = false if inv : return lambda self , other : elemwise ( op , other , self ) else : return lambda self , other : elemwise ( op , self , other , op , inv = false if inv : return lambda self , other : elemwise ( op , other , self ) else : return lambda self , other : elemwise ( op , self , other )
self , periods = 1 , axis = 0 axis = self . validate axis ( axis ) if not isinstance ( periods , integral ) : raise type error ( " periods must be an integer " ) if axis == 1 : return self . map partitions ( m . diff , token = " diff " , periods = periods , axis = 1 ) before , after = ( periods , 0 ) if periods > 0 else ( 0 , periods ) return self . map overlap ( m . diff , before , after , token = " diff " , periods = periods )
self raise if object series ( self , " abs " ) meta = self . meta nonempty . abs ( ) return self . map partitions ( m . abs , meta = meta raise if object series ( self , " abs " ) meta = self . meta nonempty . abs ( ) return self . map partitions ( m . abs , meta = meta )
self , axis = none , skipna = true , split every = false , out = none return self . reduction agg ( " all " , axis = axis , skipna = skipna , split every = split every , out = out , axis = none , skipna = true , split every = false , out = none return self . reduction agg ( " all " , axis = axis , skipna = skipna , split every = split every , out = out )
self , axis = none , skipna = true , split every = false , out = none return self . reduction agg ( " any " , axis = axis , skipna = skipna , split every = split every , out = out , axis = none , skipna = true , split every = false , out = none return self . reduction agg ( " any " , axis = axis , skipna = skipna , split every = split every , out = out )
self , axis = none , skipna = true , split every = false , out = none return self . reduction agg ( " min " , axis = axis , skipna = skipna , split every = split every , out = out , axis = none , skipna = true , split every = false , out = none return self . reduction agg ( " min " , axis = axis , skipna = skipna , split every = split every , out = out )
self , axis = none , skipna = true , out = none return self . cum agg ( " cummin " , chunk = m . cummin , aggregate = methods . cummin aggregate , axis = axis , skipna = skipna , chunk kwargs = dict ( axis = axis , skipna = skipna ) , out = out , , axis = none , skipna = true , out = none return self . cum agg ( " cummin " , chunk = m . cummin , aggregate = methods . cummin aggregate , axis = axis , skipna = skipna , chunk kwargs = dict ( axis = axis , skipna = skipna ) , out = out , )
self , cond , other = np . nan return map partitions ( m . where , self , cond , other , cond , other = np . nan return map partitions ( m . where , self , cond , other )
self if hasattr ( pd , " isna " ) : return self . map partitions ( m . isna ) else : raise not implemented error ( " need more recent version of pandas " " to support isna . " " please use isnull instead . " if hasattr ( pd , " isna " ) : return self . map partitions ( m . isna ) else : raise not implemented error ( " need more recent version of pandas " " to support isna . " " please use isnull instead . " )
self , other , func , fill value = none , overwrite = true return self . map partitions ( m . combine , other , func , fill value = fill value , overwrite = overwrite , other , func , fill value = none , overwrite = true return self . map partitions ( m . combine , other , func , fill value = fill value , overwrite = overwrite )
self , other return self . map partitions ( m . combine first , other , other return self . map partitions ( m . combine first , other )
cls , name , op raise not implemented error
self , rule , closed = none , label = none from . tseries . resample import resampler return resampler ( self , rule , closed = closed , label = label , rule , closed = none , label = none from . tseries . resample import resampler return resampler ( self , rule , closed = closed , label = label )
self , split every = none from . import hyperloglog return aca ( [ self ] , chunk = hyperloglog . compute hll array , combine = hyperloglog . reduce state , aggregate = hyperloglog . estimate count , split every = split every , b = 16 , meta = float , )
self return self . map partitions ( methods . values )
self , key return ( self . index . name is not none and not is dask collection ( key ) and ( np . isscalar ( key ) or isinstance ( key , tuple ) ) and key == self . index . name and key not in getattr ( self , " columns " , ( ) ) )
self , columns or index if isinstance ( columns or index , list ) : return any ( self . is index level reference ( n ) for n in columns or index ) else : return self . is index level reference ( columns or index )
self return self . meta . nam return self . meta . name
self , name self . meta . name = name renamed = rename dask ( self , name ) self . dask = renamed . dask self . name = renamed . nam , name self . meta . name = name renamed = rename dask ( self , name ) self . dask = renamed . dask self . name = renamed . name
self return ( self . size , )
self return self . meta . dtype
self return datetime accessor ( self )
self return self . reduction ( methods . nbytes , np . sum , token = " nbytes " , meta = int , split every = false )
self return repr data series ( self . meta , self . repr divisions return repr data series ( self . meta , self . repr divisions )
self , freq = none , how = " start " , axis = 0 df = elemwise ( m . to timestamp , self , freq , how , axis ) df . divisions = tuple ( pd . index ( self . divisions ) . to timestamp ( ) ) return d , freq = none , how = " start " , axis = 0 df = elemwise ( m . to timestamp , self , freq , how , axis ) df . divisions = tuple ( pd . index ( self . divisions ) . to timestamp ( ) ) return df
self , how = " any " , subset = none return sel , how = " any " , subset = none return self
self for i in range ( self . npartitions ) : s = self . get partition ( i ) . compute ( ) for item in s . iteritems ( ) : yield ite for i in range ( self . npartitions ) : s = self . get partition ( i ) . compute ( ) for item in s . iteritems ( ) : yield item
cls , axis = 0 if axis not in ( 0 , " index " , none ) : raise value error ( " no axis named {0} " . format ( axis ) ) return { none : 0 , " index " : 0 } . get ( axis , axis , axis = 0 if axis not in ( 0 , " index " , none ) : raise value error ( " no axis named {0} " . format ( axis ) ) return { none : 0 , " index " : 0 } . get ( axis , axis )
self , by = none , ** kwargs from dask . dataframe . groupby import series group by return series group by ( self , by = by , ** kwargs , by = none , ** kwargs from dask . dataframe . groupby import series group by return series group by ( self , by = by , ** kwargs )
self , split every = false return super ( series , self ) . count ( split every = split every , split every = false return super ( series , self ) . count ( split every = split every )
self meta = self . meta . explode ( ) return self . map partitions ( m . explode , meta = meta meta = self . meta . explode ( ) return self . map partitions ( m . explode , meta = meta )
self , split every = none , split out = 1 return aca ( self , chunk = methods . unique , aggregate = methods . unique , meta = self . meta , token = " unique " , split every = split every , series name = self . name , split out = split out , )
self , split every = none return self . drop duplicates ( split every = split every ) . count ( , split every = none return self . drop duplicates ( split every = split every ) . count ( )
self , n = 5 , split every = none return aca ( self , chunk = m . nlargest , aggregate = m . nlargest , meta = self . meta , token = " series nlargest " , split every = split every , n = n , , n = 5 , split every = none return aca ( self , chunk = m . nlargest , aggregate = m . nlargest , meta = self . meta , token = " series nlargest " , split every = split every , n = n , )
self return self . map partitions ( m . dropna return self . map partitions ( m . dropna )
self , left , right , inclusive = true return self . map partitions ( m . between , left = left , right = right , inclusive = inclusive , left , right , inclusive = true return self . map partitions ( m . between , left = left , right = right , inclusive = inclusive )
self , threshold return self . map partitions ( m . clip lower , threshold = threshold , threshold return self . map partitions ( m . clip lower , threshold = threshold )
self , threshold return self . map partitions ( m . clip upper , threshold = threshold , threshold return self . map partitions ( m . clip upper , threshold = threshold )
self return sel return self
self , other return self . map partitions ( m . combine first , other , other return self . map partitions ( m . combine first , other )
self , index = false from . io import to bag return to bag ( self , index )
self , name = none return self . map partitions ( m . to frame , name , meta = self . meta . to frame ( name ) , name = none return self . map partitions ( m . to frame , name , meta = self . meta . to frame ( name ) )
self , max rows = 5 return self . repr data ( ) . to string ( max rows = max rows , max rows = 5 return self . repr data ( ) . to string ( max rows = max rows )
cls , name , comparison def meth ( self , other , level = none , fill value = none , axis = 0 ) : if level is not none : raise not implemented error ( " level must be none " ) axis = self . validate axis ( axis ) if fill value is none : return elemwise ( comparison , self , other , axis = axis ) else : op = partial ( comparison , fill value = fill value ) return elemwise ( op , self , other , axis = axis ) meth . doc = skip doctest ( comparison . doc ) setattr ( cls , name , meth )
self , func , convert dtype = true , meta = no default , args = ( ) , ** kwds if meta is no default : meta = emulate ( m . apply , self . meta nonempty , func , convert dtype = convert dtype , args = args , udf = true , ** kwds ) warnings . warn ( meta warning ( meta ) ) return map partitions ( m . apply , self , func , convert dtype , args , meta = meta , ** kwds )
self , index = true , deep = false result = self . map partitions ( m . memory usage , index = index , deep = deep ) return delayed ( sum ) ( result . to delayed ( ) , index = true , deep = false result = self . map partitions ( m . memory usage , index = index , deep = deep ) return delayed ( sum ) ( result . to delayed ( ) )
self msg = " ' {0} ' object has no attribute ' index ' " raise attribute error ( msg . format ( self . class . name ) msg = " ' {0} ' object has no attribute ' index ' " raise attribute error ( msg . format ( self . class . name ) )
self , n = 5 , compute = true name = " head %d %s " % ( n , self . name ) dsk = { ( name , 0 ) : ( operator . getitem , ( self . name , 0 ) , slice ( 0 , n ) ) } graph = high level graph . from collections ( name , dsk , dependencies = [ self ] ) result = new dd object ( graph , name , self . meta , self . divisions [ : 2 ] ) if compute : result = result . compute ( ) return result
self , split every = false return self . reduction ( m . max , meta = self . meta nonempty . max ( ) , token = self . token prefix + " max " , split every = split every , , split every = false return self . reduction ( m . max , meta = self . meta nonempty . max ( ) , token = self . token prefix + " max " , split every = split every , )
self , split every = false return self . reduction ( m . min , meta = self . meta nonempty . min ( ) , token = self . token prefix + " min " , split every = split every , , split every = false return self . reduction ( m . min , meta = self . meta nonempty . min ( ) , token = self . token prefix + " min " , split every = split every , )
self return self . map partitions ( m . to series , meta = self . meta . to series ( ) return self . map partitions ( m . to series , meta = self . meta . to series ( ) )
self , columns renamed = rename dask ( self , columns ) self . meta = renamed . meta self . name = renamed . name self . dask = renamed . das , columns renamed = rename dask ( self , columns ) self . meta = renamed . meta self . name = renamed . name self . dask = renamed . dask
self from . indexing import i loc indexer return i loc indexer ( self )
self return self . columns . tolist ( return self . columns . tolist ( )
self col size = len ( self . columns ) row size = delayed ( int ) ( self . size / col size ) return ( row size , col size )
self return self . meta . dtypes
self return self . meta . get dtype counts ( return self . meta . get dtype counts ( )
self return self . meta . get ftype counts ( return self . meta . get ftype counts ( )
self , include = none , exclude = none cs = self . meta . select dtypes ( include = include , exclude = exclude ) . columns return self [ list ( cs ) , include = none , exclude = none cs = self . meta . select dtypes ( include = include , exclude = exclude ) . columns return self [ list ( cs ) ]
self , other , drop = true , sorted = false , npartitions = none , divisions = none , inplace = false , ** kwargs if inplace : raise not implemented error ( " the inplace= keyword is not supported " ) pre sorted = sorted del sorted if divisions is not none : check divisions ( divisions ) if pre sorted : from . shuffle import set sorted index return set sorted index ( self , other , drop = drop , divisions = divisions , ** kwargs ) else : from . shuffle import set index return set index ( self , other , drop = drop , npartitions = npartitions , divisions = divisions , ** kwargs )
self , item out = self [ item ] del self [ item ] return ou , item out = self [ item ] del self [ item ] return out
self , n = 5 , columns = none , split every = none token = " dataframe nlargest " return aca ( self , chunk = m . nlargest , aggregate = m . nlargest , meta = self . meta , token = token , split every = split every , n = n , columns = columns , , n = 5 , columns = none , split every = none token = " dataframe nlargest " return aca ( self , chunk = m . nlargest , aggregate = m . nlargest , meta = self . meta , token = token , split every = split every , n = n , columns = columns , )
self , n = 5 , columns = none , split every = none token = " dataframe nsmallest " return aca ( self , chunk = m . nsmallest , aggregate = m . nsmallest , meta = self . meta , token = token , split every = split every , n = n , columns = columns , , n = 5 , columns = none , split every = none token = " dataframe nsmallest " return aca ( self , chunk = m . nsmallest , aggregate = m . nsmallest , meta = self . meta , token = token , split every = split every , n = n , columns = columns , )
self , by = none , ** kwargs from dask . dataframe . groupby import data frame group by return data frame group by ( self , by = by , ** kwargs , by = none , ** kwargs from dask . dataframe . groupby import data frame group by return data frame group by ( self , by = by , ** kwargs )
self , columns = none , index = none , split every = none , ** kwargs return categorize ( self , columns = columns , index = index , split every = split every , ** kwargs , columns = none , index = none , split every = none , ** kwargs return categorize ( self , columns = columns , index = index , split every = split every , ** kwargs )
self , index = none , columns = none if index is not none : raise value error ( " cannot rename index . " ) return self . map partitions ( m . rename , none , columns = columns , index = none , columns = none if index is not none : raise value error ( " cannot rename index . " ) return self . map partitions ( m . rename , none , columns = columns )
self , how = " any " , subset = none , thresh = none return self . map partitions ( m . dropna , how = how , subset = subset , thresh = thresh , how = " any " , subset = none , thresh = none return self . map partitions ( m . dropna , how = how , subset = subset , thresh = thresh )
self , lower = none , upper = none , out = none if out is not none : raise value error ( " ' out ' must be none " ) return self . map partitions ( m . clip , lower = lower , upper = upper , lower = none , upper = none , out = none if out is not none : raise value error ( " ' out ' must be none " ) return self . map partitions ( m . clip , lower = lower , upper = upper )
self , threshold return self . map partitions ( m . clip lower , threshold = threshold , threshold return self . map partitions ( m . clip lower , threshold = threshold )
self , threshold return self . map partitions ( m . clip upper , threshold = threshold , threshold return self . map partitions ( m . clip upper , threshold = threshold )
self , freq = none , how = " start " , axis = 0 df = elemwise ( m . to timestamp , self , freq , how , axis ) df . divisions = tuple ( pd . index ( self . divisions ) . to timestamp ( ) ) return d , freq = none , how = " start " , axis = 0 df = elemwise ( m . to timestamp , self , freq , how , axis ) df . divisions = tuple ( pd . index ( self . divisions ) . to timestamp ( ) ) return df
self , column meta = self . meta . explode ( column ) return self . map partitions ( m . explode , column , meta = meta , column meta = self . meta . explode ( column ) return self . map partitions ( m . explode , column , meta = meta )
self , index = false from . io import to bag return to bag ( self , index )
self , path , * args , ** kwargs from . io import to parquet return to parquet ( self , path , * args , ** kwargs )
self , max rows = 5 return self . repr data ( ) . to string ( max rows = max rows , show dimensions = false , max rows = 5 return self . repr data ( ) . to string ( max rows = max rows , show dimensions = false )
self for i in range ( self . npartitions ) : df = self . get partition ( i ) . compute ( ) for row in df . iterrows ( ) : yield ro for i in range ( self . npartitions ) : df = self . get partition ( i ) . compute ( ) for row in df . iterrows ( ) : yield row
self , index = true , name = " pandas " for i in range ( self . npartitions ) : df = self . get partition ( i ) . compute ( ) for row in df . itertuples ( index = index , name = name ) : yield ro , index = true , name = " pandas " for i in range ( self . npartitions ) : df = self . get partition ( i ) . compute ( ) for row in df . itertuples ( index = index , name = name ) : yield row
cls , name , comparison def meth ( self , other , axis = " columns " , level = none ) : if level is not none : raise not implemented error ( " level must be none " ) axis = self . validate axis ( axis ) return elemwise ( comparison , self , other , axis = axis ) meth . doc = skip doctest ( comparison . doc ) setattr ( cls , name , meth )
self , func , meta = " no default " return elemwise ( m . applymap , self , func , meta = meta , func , meta = " no default " return elemwise ( m . applymap , self , func , meta = meta )
self , min periods = none , split every = false return cov corr ( self , min periods , split every = split every , min periods = none , split every = false return cov corr ( self , min periods , split every = split every )
self , method = " pearson " , min periods = none , split every = false if method != " pearson " : raise not implemented error ( " only pearson correlation has been implemented " ) return cov corr ( self , min periods , true , split every = split every , method = " pearson " , min periods = none , split every = false if method != " pearson " : raise not implemented error ( " only pearson correlation has been implemented " ) return cov corr ( self , min periods , true , split every = split every )
self , index = true , deep = false result = self . map partitions ( m . memory usage , index = index , deep = deep ) result = result . groupby ( result . index ) . sum ( ) return resul , index = true , deep = false result = self . map partitions ( m . memory usage , index = index , deep = deep ) result = result . groupby ( result . index ) . sum ( ) return result
self , index = none , columns = none , values = none , aggfunc = " mean " from . reshape import pivot table return pivot table ( self , index = index , columns = columns , values = values , aggfunc = aggfunc )
self , id vars = none , value vars = none , var name = none , value name = " value " , col level = none from . reshape import melt return melt ( self , id vars = id vars , value vars = value vars , var name = var name , value name = value name , col level = col level , )
self , max rows = 5 data = self . repr data ( ) . to html ( max rows = max rows , show dimensions = false ) return self . html fmt . format ( data = data , name = key split ( self . name ) , task = len ( self . dask ) , max rows = 5 data = self . repr data ( ) . to html ( max rows = max rows , show dimensions = false ) return self . html fmt . format ( data = data , name = key split ( self . name ) , task = len ( self . dask ) )
self meta = self . meta index = self . repr divisions series list = [ repr data series ( s , index = index ) for , s in meta . iteritems ( ) ] return pd . concat ( series list , axis = 1 meta = self . meta index = self . repr divisions series list = [ repr data series ( s , index = index ) for , s in meta . iteritems ( ) ] return pd . concat ( series list , axis = 1 )
self data = self . repr data ( ) . to html ( max rows = 5 , show dimensions = false , notebook = true ) return self . html fmt . format ( data = data , name = key split ( self . name ) , task = len ( self . dask ) data = self . repr data ( ) . to html ( max rows = 5 , show dimensions = false , notebook = true ) return self . html fmt . format ( data = data , name = key split ( self . name ) , task = len ( self . dask ) )
self , columns or index columns or index = ( columns or index if isinstance ( columns or index , list ) else [ columns or index ] ) column names = [ n for n in columns or index if self . is column label reference ( n ) ] selected df = self [ column names ] if self . contains index name ( columns or index ) : # index name was included selected df = selected df . assign ( index = self . index ) return selected df
self , key return ( not is dask collection ( key ) and ( np . isscalar ( key ) or isinstance ( key , tuple ) ) and key in self . columns )
dfs , s return ( isinstance ( s , series ) and s . npartitions == 1 and s . known divisions and any ( s . divisions == ( min ( df . columns ) , max ( df . columns ) ) for df in dfs if isinstance ( df , data frame ) ) )
dfs from . io import from pandas dfs = [ from pandas ( df , 1 ) if ( is series like ( df ) or is dataframe like ( df ) ) and not is dask collection ( df ) else df for df in dfs ] return dffrom . io import from pandas dfs = [ from pandas ( df , 1 ) if ( is series like ( df ) or is dataframe like ( df ) ) and not is dask collection ( df ) else df for df in dfs ] return dfs
df , k divisions = np . linspace ( 0 , len ( df ) , k + 1 ) . astype ( int ) return { i : df . iloc [ divisions [ i ] : divisions [ i + 1 ] ] for i in range ( k ) }
df h = df . index if isinstance ( h , pd . multi index ) : h = pd . data frame ( [ ] , index = h ) . reset index ( ) return = df . index if isinstance ( h , pd . multi index ) : h = pd . data frame ( [ ] , index = h ) . reset index ( ) return h
df , cols = none return df [ cols , cols = none return df [ cols ]
func , * args , ** kwargs with raise on meta error ( funcname ( func ) , udf = kwargs . pop ( " udf " , false ) ) : return func ( * extract meta ( args , true ) , ** extract meta ( kwargs , true ) )
df , names assert isinstance ( df , frame ) metadata = rename ( names , df . meta ) name = " rename {0} " . format ( tokenize ( df , metadata ) ) dsk = partitionwise graph ( rename , name , metadata , df ) graph = high level graph . from collections ( name , dsk , dependencies = [ df ] ) return new dd object ( graph , name , metadata , df . divisions )
df , p , random state = none p = list ( p ) index = pseudorandom ( len ( df ) , p , random state ) return [ df . iloc [ index == i ] for i in range ( len ( p ) ) ]
df mem usage = df . memory usage ( deep = true ) if is series like ( mem usage ) : mem usage = mem usage . sum ( ) return mem usagem usage = df . memory usage ( deep = true ) if is series like ( mem usage ) : mem usage = mem usage . sum ( ) return mem usage
sizes , max size chunk , chunk sum = [ ] , 0 iter sizes = iter ( sizes ) size = next ( iter sizes , none ) while size is not none : assert size <= max size if chunk sum + size <= max size : chunk . append ( size ) chunk sum += size size = next ( iter sizes , none ) else : assert chunk yield chunk chunk , chunk sum = [ ] , 0 if chunk : yield chunk
x , aca chunk = none , ** kwargs o = aca chunk ( x , ** kwargs ) return o . to frame ( ) . t if is series like ( o ) else aca chunk = none , ** kwargs o = aca chunk ( x , ** kwargs ) return o . to frame ( ) . t if is series like ( o ) else o
x , aca combine = none , ** kwargs if isinstance ( x , list ) : x = pd . series ( x ) o = aca combine ( x , ** kwargs ) return o . to frame ( ) . t if is series like ( o ) else aca combine = none , ** kwargs if isinstance ( x , list ) : x = pd . series ( x ) o = aca combine ( x , ** kwargs ) return o . to frame ( ) . t if is series like ( o ) else o
x , aca aggregate = none , ** kwargs if isinstance ( x , list ) : x = pd . series ( x ) return aca aggregate ( x , ** kwargs aca aggregate = none , ** kwargs if isinstance ( x , list ) : x = pd . series ( x ) return aca aggregate ( x , ** kwargs )
arg , unit = " ns " , errors = " raise " meta = pd . series ( [ pd . timedelta ( 1 , unit = unit ) ] ) return map partitions ( pd . to timedelta , arg , unit = unit , errors = errors , meta = meta , unit = " ns " , errors = " raise " meta = pd . series ( [ pd . timedelta ( 1 , unit = unit ) ] ) return map partitions ( pd . to timedelta , arg , unit = unit , errors = errors , meta = meta )
arg return map partitions ( pd . isna , arg return map partitions ( pd . isna , arg )
s , index npartitions = len ( index ) 1 if is categorical dtype ( s ) : if has known categories ( s ) : dtype = " category[known] " else : dtype = " category[unknown] " else : dtype = str ( s . dtype ) return pd . series ( [ dtype ] + [ " . . . " ] * npartitions , index = index , name = s . name )
return data framturn data frame
o return get parallel type ( o . meta turn get parallel type ( o . meta )
def return tuple ( k for k , v in get parallel type . lookup . items ( ) if v is not get parallel type object return tuple ( k for k , v in get parallel type . lookup . items ( ) if v is not get parallel type object )
base chunk , concat map return base chunk . map ( concat map chunk , concat map return base chunk . map ( concat map )
index , concat result final series = concat result . sort index ( ) final series = index . to series ( ) . map ( final series ) return final seriex , concat result final series = concat result . sort index ( ) final series = index . to series ( ) . map ( final series ) return final series
name from dask . dataframe import data frame return register accessor ( name , data frame )
name from dask . dataframe import series return register accessor ( name , series )
name from dask . dataframe import index return register accessor ( name , index )
df , divisions if isinstance ( divisions , iterator ) : divisions = list ( divisions ) if not len ( divisions ) : yield df else : divisions = np . array ( divisions ) df = df . sort index ( ) index = df . index if is categorical dtype ( index ) : index = index . as ordered ( ) indices = index . searchsorted ( divisions ) yield df . iloc [ : indices [ 0 ] ] for i in range ( len ( indices ) 1 ) : yield df . iloc [ indices [ i ] : indices [ i + 1 ] ] yield df . iloc [ indices [ 1 ] : ]
x x = getattr ( x , " meta " , x ) if is series like ( x ) : return unknown categories not in x . cat . categories elif is index like ( x ) and hasattr ( x , " categories " ) : return unknown categories not in x . categories raise type error ( " expected series or categorical index " )
x , index = none return x . iloc [ : 0 index = none return x . iloc [ : 0 ]
x , index = none return x [ 0 : 0 index = none return x [ 0 : 0 ]
obj , index = true , encoding = " utf8 " , hash key = none , categorize = true return pd . util . hash pandas object ( obj , index = index , encoding = encoding , hash key = hash key , categorize = categorize , index = true , encoding = " utf8 " , hash key = none , categorize = true return pd . util . hash pandas object ( obj , index = index , encoding = encoding , hash key = hash key , categorize = categorize )
dtype return scalar from dtype ( dtype e return scalar from dtype ( dtype )
df return dask is dataframe like ( df eturn dask is dataframe like ( df )
s return dask is series like ( s turn dask is series like ( s )
idx , name = none n = len ( idx ) if name is none : name = idx . class . name if n : head = idx [ 0 ] tail = idx [ 1 ] summary = " , {} to {} " . format ( head , tail ) else : summary = " " return " {}: {} entries{} " . format ( name , n , summary )
x , n , eq = true dependencies , dependents = get deps ( x . dask ) if eq : assert max ( map ( len , dependencies . values ( ) ) ) == n else : assert max ( map ( len , dependencies . values ( ) ) ) <= n , eq = true dependencies , dependents = get deps ( x . dask ) if eq : assert max ( map ( len , dependencies . values ( ) ) ) == n else : assert max ( map ( len , dependencies . values ( ) ) ) <= n
divisions if not isinstance ( divisions , ( tuple , list ) ) : return false for i , x in enumerate ( divisions [ : 2 ] ) : if x >= divisions [ i + 1 ] : return false if isinstance ( x , numbers . number ) and math . isnan ( x ) : return false for x in divisions [ 2 : ] : if isinstance ( x , numbers . number ) and math . isnan ( x ) : return false if divisions [ 2 ] > divisions [ 1 ] : return false return true
df , index if not isinstance ( df , data frame ) : return index elif isinstance ( index , list ) : return [ normalize index ( df , col ) for col in index ] elif ( is series like ( index ) and index . name in df . columns and index . name == df [ index . name ] . name ) : return index . name elif ( isinstance ( index , data frame ) and set ( index . columns ) . issubset ( df . columns ) and index . name == df [ index . columns ] . name ) : return list ( index . columns ) else : return index
df , by if is series like ( by ) or is dataframe like ( by ) : return df . index . equals ( by . index ) elif isinstance ( by , ( list , tuple ) ) : return all ( is aligned ( df , i ) for i in by ) else : return true
df , grouper , key , func , * args , ** kwargs group keys = kwargs . pop ( " group keys " , true ) g = df . groupby ( grouper , group keys = group keys ) if key : g = g [ key ] return g . apply ( func , * args , ** kwargs , grouper , key , func , * args , ** kwargs group keys = kwargs . pop ( " group keys " , true ) g = df . groupby ( grouper , group keys = group keys ) if key : g = g [ key ] return g . apply ( func , * args , ** kwargs )
df , aggfunc = none , levels = none , ** kwargs return aggfunc ( df . groupby ( level = levels , sort = false ) , ** kwargs , aggfunc = none , levels = none , ** kwargs return aggfunc ( df . groupby ( level = levels , sort = false ) , ** kwargs )
g , levels return levels return g
df , cols df = type ( df ) ( ) for i , j in it . combinations with replacement ( cols , 2 ) : col = " %s%s " % ( i , j ) df [ col ] = df [ i ] * df [ j ] return df
df names = [ none ] * df . index . nlevels return df . drop duplicates ( ) . rename axis ( names , copy = false ames = [ none ] * df . index . nlevels return df . drop duplicates ( ) . rename axis ( names , copy = false )
df , * index , ** ignored assert is series like ( df ) df = df . to frame ( ) kwargs = dict ( name = df . columns [ 0 ] , levels = determine levels ( index ) ) return nunique df chunk ( df , * index , ** kwargs , * index , ** ignored assert is series like ( df ) df = df . to frame ( ) kwargs = dict ( name = df . columns [ 0 ] , levels = determine levels ( index ) ) return nunique df chunk ( df , * index , ** kwargs )
func , column return " {!s} {!s} {} " . format ( func , column , tokenize ( func , column ) , column return " {!s} {!s} {} " . format ( func , column , tokenize ( func , column ) )
result column , func , input column impls = build agg args var ( result column , func , input column ) result column , , kwargs = impls [ " finalizer " ] impls [ " finalizer " ] = ( result column , finalize std , kwargs ) return impllt column , func , input column impls = build agg args var ( result column , func , input column ) result column , , kwargs = impls [ " finalizer " ] impls [ " finalizer " ] = ( result column , finalize std , kwargs ) return impls
grouped , column base = grouped [ column ] if column is not none else grouped return base . apply ( lambda x : ( x ** 2 ) . sum ( ) ped , column base = grouped [ column ] if column is not none else grouped return base . apply ( lambda x : ( x ** 2 ) . sum ( ) )
df like , column , func if column is none : return func ( df like ) return func ( df like [ column ] ike , column , func if column is none : return func ( df like ) return func ( df like [ column ] )
df , sum column , count column return df [ sum column ] / df [ count column , sum column , count column return df [ sum column ] / df [ count column ]
df , count column , sum column , sum2 column , ddof = 1 result = finalize var ( df , count column , sum column , sum2 column , ddof ) return np . sqrt ( result , count column , sum column , sum2 column , ddof = 1 result = finalize var ( df , count column , sum column , sum2 column , ddof ) return np . sqrt ( result )
part , cum last , index , columns , func , initial align = cum last . reindex ( part . set index ( index ) . index , fill value = initial ) align . index = part . index return func ( part [ columns ] , align , cum last , index , columns , func , initial align = cum last . reindex ( part . set index ( index ) . index , fill value = initial ) align . index = part . index return func ( part [ columns ] , align )
a , b , func , initial union = a . index . union ( b . index ) return func ( a . reindex ( union , fill value = initial ) , b . reindex ( union , fill value = initial ) , fill value = initial , b , func , initial union = a . index . union ( b . index ) return func ( a . reindex ( union , fill value = initial ) , b . reindex ( union , fill value = initial ) , fill value = initial , )
a , b , fill value = none return a . add ( b , fill value = fill value ) + b , fill value = none return a . add ( b , fill value = fill value ) + 1
self sample = self . obj . meta nonempty if isinstance ( self . index , list ) : index meta = [ item . meta nonempty if isinstance ( item , series ) else item for item in self . index ] elif isinstance ( self . index , series ) : index meta = self . index . meta nonempty else : index meta = self . index grouped = sample . groupby ( index meta , group keys = self . group keys ) return maybe slice ( grouped , self . slice )
self , axis = 0 if axis : return self . obj . cumprod ( axis = axis ) else : return self . cum agg ( " cumprod " , chunk = m . cumprod , aggregate = m . mul , initial = 1 , axis = 0 if axis : return self . obj . cumprod ( axis = axis ) else : return self . cum agg ( " cumprod " , chunk = m . cumprod , aggregate = m . mul , initial = 1 )
self , axis = none return self . cum agg ( " cumcount " , chunk = m . cumcount , aggregate = cumcount aggregate , initial = 1 , axis = none return self . cum agg ( " cumcount " , chunk = m . cumcount , aggregate = cumcount aggregate , initial = 1 )
self , split every = none , split out = 1 return self . aca agg ( token = " min " , func = m . min , split every = split every , split out = split out , split every = none , split out = 1 return self . aca agg ( token = " min " , func = m . min , split every = split every , split out = split out )
self , split every = none , split out = 1 return self . aca agg ( token = " max " , func = m . max , split every = split every , split out = split out , split every = none , split out = 1 return self . aca agg ( token = " max " , func = m . max , split every = split every , split out = split out )
self , split every = none , split out = 1 return self . aca agg ( token = " count " , func = m . count , aggfunc = m . sum , split every = split every , split out = split out , , split every = none , split out = 1 return self . aca agg ( token = " count " , func = m . count , aggfunc = m . sum , split every = split every , split out = split out , )
self , split every = none , split out = 1 return self . aca agg ( token = " size " , func = m . size , aggfunc = m . sum , split every = split every , split out = split out , , split every = none , split out = 1 return self . aca agg ( token = " size " , func = m . size , aggfunc = m . sum , split every = split every , split out = split out , )
self , ddof = 1 , split every = none , split out = 1 v = self . var ( ddof , split every = split every , split out = split out ) result = map partitions ( np . sqrt , v , meta = v ) return resul , ddof = 1 , split every = none , split out = 1 v = self . var ( ddof , split every = split every , split out = split out ) result = map partitions ( np . sqrt , v , meta = v ) return result
self , ddof = 1 , split every = none , split out = 1 return self . cov ( split every = split every , split out = split out , std = true )
self , split every = none , split out = 1 return self . aca agg ( token = " last " , func = m . last , split every = split every , split out = split out , split every = none , split out = 1 return self . aca agg ( token = " last " , func = m . last , split every = split every , split out = split out )
self , arg , split every = none , split out = 1 if arg == " size " : return self . size ( ) return super ( data frame group by , self ) . aggregate ( arg , split every = split every , split out = split out , arg , split every = none , split out = 1 if arg == " size " : return self . size ( ) return super ( data frame group by , self ) . aggregate ( arg , split every = split every , split out = split out )
self , arg , split every = none , split out = 1 return self . aggregate ( arg , split every = split every , split out = split out , arg , split every = none , split out = 1 return self . aggregate ( arg , split every = split every , split out = split out )
self , arg , split every = none , split out = 1 return self . aggregate ( arg , split every = split every , split out = split out , arg , split every = none , split out = 1 return self . aggregate ( arg , split every = split every , split out = split out )
self return self . obj . nam return self . obj . name
self raise not implemented erro raise not implemented error
self , iindexer , cindexer if cindexer is none : return self . obj else : return self . meta indexer [ : , cindexer ]
self return self . obj . meta . ilo return self . obj . meta . iloc
self , iindexer , cindexer assert iindexer == slice ( none ) meta = self . make meta ( iindexer , cindexer ) return self . obj . map partitions ( methods . iloc , cindexer , meta = meta , iindexer , cindexer assert iindexer == slice ( none ) meta = self . make meta ( iindexer , cindexer ) return self . obj . map partitions ( methods . iloc , cindexer , meta = meta )
self return self . obj . meta . lo return self . obj . meta . loc
self , iindexer iindexer = maybe partial time string ( self . obj . meta nonempty . index , iindexer , kind = " loc " ) return iindexer
self , iindexer , cindexer meta = self . make meta ( iindexer , cindexer ) return self . obj . map partitions ( methods . loc , iindexer , cindexer , token = " loc series " , meta = meta , iindexer , cindexer meta = self . make meta ( iindexer , cindexer ) return self . obj . map partitions ( methods . loc , iindexer , cindexer , token = " loc series " , meta = meta )
self , iindexer , cindexer iindexer series = iindexer . to dask dataframe ( " " , self . obj . index ) return self . loc series ( iindexer series , cindexer , iindexer , cindexer iindexer series = iindexer . to dask dataframe ( " " , self . obj . index ) return self . loc series ( iindexer series , cindexer )
self , keys if isinstance ( keys , ( list , np . ndarray ) ) : return partitions of index values ( self . obj . divisions , keys ) else : # element return partition of index value ( self . obj . divisions , keys , keys if isinstance ( keys , ( list , np . ndarray ) ) : return partitions of index values ( self . obj . divisions , keys ) else : # element return partition of index value ( self . obj . divisions , keys )
self , key return coerce loc index ( self . obj . divisions , key , key return coerce loc index ( self . obj . divisions , key )
divisions , values if divisions [ 0 ] is none : msg = " can not use loc on data frame without known divisions " raise value error ( msg ) results = defaultdict ( list ) values = pd . index ( values , dtype = object ) for val in values : i = bisect . bisect right ( divisions , val ) div = min ( len ( divisions ) 2 , max ( 0 , i 1 ) ) results [ div ] . append ( val ) return results
divisions , o if divisions and isinstance ( divisions [ 0 ] , datetime ) : return pd . timestamp ( o ) if divisions and isinstance ( divisions [ 0 ] , np . datetime64 ) : return np . datetime64 ( o ) . astype ( divisions [ 0 ] . dtype ) return o
ms , b m = 1 << b ms = ms . reshape ( ( len ( ms ) // m ) , m ) return ms . max ( axis = 0 , b m = 1 << b ms = ms . reshape ( ( len ( ms ) // m ) , m ) return ms . max ( axis = 0 )
self return has known categories ( self . series )
self , ** kwargs if self . known : return self . series categories = self . property map ( " categories " ) . unique ( ) . compute ( ** kwargs ) return self . set categories ( categories . values )
self return self . delegate property ( self . series . meta , " cat " , " ordered " return self . delegate property ( self . series . meta , " cat " , " ordered " )
self if not self . known : msg = ( " `df . column . cat . codes` with unknown categories is not " " supported . please use `column . cat . as known()` or " " `df . categorize()` beforehand to ensure known categories " ) raise not implemented error ( msg ) return self . property map ( " codes " )
n , num groups group size = n // num groups dx = num groups dy = n group size * num groups d = 2 * dy dx rv = [ ] for in range ( num groups ) : if d < 0 : rv . append ( group size ) else : rv . append ( group size + 1 ) d = 2 * dx d += 2 * dy return rv
qs , vals , length if length == 0 : return ( ) diff = np . ediff1d ( qs , 0 . 0 , 0 . 0 ) weights = 0 . 5 * length * ( diff [ 1 : ] + diff [ : 1 ] ) return vals . tolist ( ) , weights . tolist ( )
df info = none if is categorical dtype ( df ) : data = df . values info = ( data . categories , data . ordered ) return df . dtype , infnfo = none if is categorical dtype ( df ) : data = df . values info = ( data . categories , data . ordered ) return df . dtype , info
divisions divisions = list ( divisions ) for i in range ( len ( divisions ) 2 , 1 , 1 ) : if pd . isnull ( divisions [ i ] ) : divisions [ i ] = divisions [ i + 1 ] for i in range ( len ( divisions ) 1 , 1 , 1 ) : if not pd . isnull ( divisions [ i ] ) : for j in range ( i + 1 , len ( divisions ) ) : divisions [ j ] = divisions [ i ] break return divisions
df , column , divisions , max branch = none , shuffle = none divisions = df . meta . constructor sliced ( divisions ) meta = df . meta . constructor sliced ( [ 0 ] ) partitions = df [ column ] . map partitions ( set partitions pre , divisions = divisions , meta = meta ) df2 = df . assign ( partitions = partitions ) df3 = rearrange by column ( df2 , " partitions " , max branch = max branch , npartitions = len ( divisions ) 1 , shuffle = shuffle , ) del df3 [ " partitions " ] return df3
df , npartitions return hash object dispatch ( df , index = false ) % int ( npartitions )
args list ( args ) return list ( args ) return 0
p , part , meta , barrier token res = p . get ( part ) return res if len ( res ) > 0 else meta
g head , i g , head = g head if i in g : return g [ i ] else : return heaad , i g , head = g head if i in g : return g [ i ] else : return head
df , col , stage , k , npartitions if col == " partitions " : ind = df [ col ] else : ind = hash object dispatch ( df , index = false ) c = ind . values typ = np . min scalar type ( npartitions * 2 ) c = np . mod ( c , npartitions ) . astype ( typ , copy = false ) np . floor divide ( c , k ** stage , out = c ) np . mod ( c , k , out = c ) return group split dispatch ( df , c . astype ( np . int64 ) , k )
df , col , npartitions , p g = df . groupby ( col ) d = { i : g . get group ( i ) for i in g . groups } p . append ( d , fsync = true , col , npartitions , p g = df . groupby ( col ) d = { i : g . get group ( i ) for i in g . groups } p . append ( d , fsync = true )
df , index name , drop , column dtype df2 = df . drop ( " partitions " , axis = 1 ) . set index ( index name , drop = drop ) df2 . columns = df2 . columns . astype ( column dtype ) return df, index name , drop , column dtype df2 = df . drop ( " partitions " , axis = 1 ) . set index ( index name , drop = drop ) df2 . columns = df2 . columns . astype ( column dtype ) return df2
df , index name , drop , column dtype df2 = df . drop ( " partitions " , axis = 1 ) . set index ( " index " , drop = true ) df2 . index . name = index name df2 . columns = df2 . columns . astype ( column dtype ) return df, index name , drop , column dtype df2 = df . drop ( " partitions " , axis = 1 ) . set index ( " index " , drop = true ) df2 . index . name = index name df2 . columns = df2 . columns . astype ( column dtype ) return df2
current , next , after return next [ next . index < ( current . index . max ( ) + after ) ]
prevs , current , before selected = methods . concat ( [ prev [ prev . index > ( current . index . min ( ) before ) ] for prev in prevs ] ) return selected
self return { " window " : self . window , " min periods " : self . min periods , " center " : self . center , " win type " : self . win type , " axis " : self . axis , return { " window " : self . window , " min periods " : self . min periods , " center " : self . center , " win type " : self . win type , " axis " : self . axis , }
self return ( self . axis in ( 1 , " columns " ) or ( isinstance ( self . window , integral ) and self . window <= 1 ) or self . obj . npartitions == 1 )
self return self . call method ( " count " return self . call method ( " count " )
self return self . call method ( " cov " return self . call method ( " cov " )
self return self . call method ( " sum " return self . call method ( " sum " )
self return self . call method ( " min " return self . call method ( " min " )
self return self . call method ( " max " return self . call method ( " max " )
self , ddof = 1 return self . call method ( " std " , ddof = 1 , ddof = 1 return self . call method ( " std " , ddof = 1 )
self , ddof = 1 return self . call method ( " var " , ddof = 1 , ddof = 1 return self . call method ( " var " , ddof = 1 )
self return self . call method ( " skew " return self . call method ( " skew " )
self return self . call method ( " kurt " return self . call method ( " kurt " )
self , quantile return self . call method ( " quantile " , quantile , quantile return self . call method ( " quantile " , quantile )
args is broadcastable = partial ( is broadcastable , args ) dfs = [ df for df in args if isinstance ( df , frame ) and not is broadcastable ( df ) ] if not dfs : return args divisions = dfs [ 0 ] . divisions if not all ( df . divisions == divisions for df in dfs ) : dfs2 = iter ( align partitions ( * dfs ) [ 0 ] ) return [ a if not isinstance ( a , frame ) else next ( dfs2 ) for a in args ] return args
divisions , parts , required = none if not required : return divisions , parts for i in required : present = [ j for j , p in enumerate ( parts ) if p [ i ] is not none ] divisions = tuple ( divisions [ min ( present ) : max ( present ) + 2 ] ) parts = tuple ( parts [ min ( present ) : max ( present ) + 1 ] ) return divisions , parts
left , right if right . empty : return left return right . tail ( 1 , right if right . empty : return left return right . tail ( 1 )
left , right , by = none return pd . concat ( [ left , right ] ) . drop duplicates ( subset = by , keep = " last " , right , by = none return pd . concat ( [ left , right ] ) . drop duplicates ( subset = by , keep = " last " )
ddf , by = none empty = ddf . meta . iloc [ 0 : 0 ] if by is none : return prefix reduction ( most recent tail , ddf , empty ) else : kwargs = { " by " : by } return prefix reduction ( most recent tail summary , ddf , empty , ** kwargs )
left , right if left . empty : return right return left . head ( 1 , right if left . empty : return right return left . head ( 1 )
left , right , by = none return pd . concat ( [ left , right ] ) . drop duplicates ( subset = by , keep = " first " , right , by = none return pd . concat ( [ left , right ] ) . drop duplicates ( subset = by , keep = " first " )
ddf , by = none empty = ddf . meta . iloc [ 0 : 0 ] if by is none : return suffix reduction ( most recent head , ddf , empty ) else : kwargs = { " by " : by } return suffix reduction ( most recent head summary , ddf , empty , ** kwargs )
left , right , prev = none , next = none , ** kwargs frames = [ ] if prev is not none : frames . append ( prev ) frames . append ( right ) if next is not none : frames . append ( next ) frame = pd . concat ( frames ) return pd . merge asof ( left , frame , ** kwargs )
frames new columns = pd . concat ( [ frame . meta for frame in frames ] ) . columns order = [ ] for frame in frames : order . append ( new columns . get indexer for ( frame . columns ) ) order = np . concatenate ( order ) order = pd . unique ( order ) order = new columns . take ( order ) return order
frames , columns return pd . concat ( frames ) [ columns ]
dfs if len ( set ( map ( len , dfs ) ) ) != 1 : raise value error ( " concatenated data frames of different lengths " ) return pd . concat ( dfs , axis = 1 if len ( set ( map ( len , dfs ) ) ) != 1 : raise value error ( " concatenated data frames of different lengths " ) return pd . concat ( dfs , axis = 1 )
df , iindexer , cindexer = none if cindexer is none : return df . loc [ iindexer ] else : return df . loc [ iindexer , cindexer ]
df , cindexer = none return df . iloc [ : , cindexer , cindexer = none return df . iloc [ : , cindexer ]
df , iindexer , cindexer = none try : return loc ( df , iindexer , cindexer ) except key error : return df . head ( 0 ) . loc [ : , cindexer ]
x return pd . notnull ( x ) . sum ( turn pd . notnull ( x ) . sum ( )
s , n try : with warnings . catch warnings ( record = true ) : warnings . simplefilter ( " always " ) return s / n except zero division error : return np . float64 ( np . nan n try : with warnings . catch warnings ( record = true ) : warnings . simplefilter ( " always " ) return s / n except zero division error : return np . float64 ( np . nan )
array var , index if isinstance ( array var , np . ndarray ) or isinstance ( array var , list ) : return pd . series ( array var , index = index ) return array vay var , index if isinstance ( array var , np . ndarray ) or isinstance ( array var , list ) : return pd . series ( array var , index = index ) return array var
numeric var , timedelta var , columns vars = pd . concat ( [ numeric var , timedelta var ] ) return vars . reindex ( index = columns ric var , timedelta var , columns vars = pd . concat ( [ numeric var , timedelta var ] ) return vars . reindex ( index = columns )
x , y if is series like ( x ) or is dataframe like ( x ) : return x . where ( ( x < y ) | x . isnull ( ) , y , axis = x . ndim 1 ) else : # scalar return x if x < y else y if is series like ( x ) or is dataframe like ( x ) : return x . where ( ( x < y ) | x . isnull ( ) , y , axis = x . ndim 1 ) else : # scalar return x if x < y else y
x , y if is series like ( x ) or is dataframe like ( x ) : return x . where ( ( x > y ) | x . isnull ( ) , y , axis = x . ndim 1 ) else : # scalar return x if x > y else y if is series like ( x ) or is dataframe like ( x ) : return x . where ( ( x > y ) | x . isnull ( ) , y , axis = x . ndim 1 ) else : # scalar return x if x > y else y
df , * pairs kwargs = dict ( partition ( 2 , pairs ) ) return df . assign ( ** kwargs , * pairs kwargs = dict ( partition ( 2 , pairs ) ) return df . assign ( ** kwargs )
x , series name = none out = x . unique ( ) if not is series like ( out ) : out = pd . series ( out , name = series name ) return ou series name = none out = x . unique ( ) if not is series like ( out ) : out = pd . series ( out , name = series name ) return out
x return x . groupby ( level = 0 ) . sum ( turn x . groupby ( level = 0 ) . sum ( )
x return x . groupby ( level = 0 ) . sum ( ) . sort values ( ascending = false turn x . groupby ( level = 0 ) . sum ( ) . sort values ( ascending = false )
x return x . nbyteturn x . nbytes
x return x . sizturn x . size
df return df . valueeturn df . values
df , state , frac , replace rs = np . random . random state ( state ) return df . sample ( random state = rs , frac = frac , replace = replace ) if len ( df ) > 0 else d, state , frac , replace rs = np . random . random state ( state ) return df . sample ( random state = rs , frac = frac , replace = replace ) if len ( df ) > 0 else df
df , columns , dtype df = df . drop ( columns , axis = 1 ) df . columns = df . columns . astype ( dtype ) return d, columns , dtype df = df . drop ( columns , axis = 1 ) df . columns = df . columns . astype ( dtype ) return df
df return df . groupby ( level = 0 ) . sum ( eturn df . groupby ( level = 0 ) . sum ( )
df , index , columns , values return pd . pivot table ( df , index = index , columns = columns , values = values , aggfunc = " sum " , index , columns , values return pd . pivot table ( df , index = index , columns = columns , values = values , aggfunc = " sum " )
df , ind df = df . copy ( ) df . index = ind return d, ind df = df . copy ( ) df . index = ind return df
obj , x if isinstance ( x , np . ndarray ) : if isinstance ( obj , pd . series ) : return pd . series ( x , index = obj . index , dtype = x . dtype ) return pd . index ( x ) return , x if isinstance ( x , np . ndarray ) : if isinstance ( obj , pd . series ) : return pd . series ( x , index = obj . index , dtype = x . dtype ) return pd . index ( x ) return x
obj , accessor , attr out = getattr ( getattr ( obj , accessor , obj ) , attr ) return maybe wrap pandas ( obj , out , accessor , attr out = getattr ( getattr ( obj , accessor , obj ) , attr ) return maybe wrap pandas ( obj , out )
self return set ( dir ( self . meta ) ) . difference ( self . not implemented return set ( dir ( self . meta ) ) . difference ( self . not implemented )
series , pat , flags return series . str . extractall ( pat , flags = flags es , pat , flags return series . str . extractall ( pat , flags = flags )
rule try : return getattr ( rule , " nanos " , none ) except value error : return non try : return getattr ( rule , " nanos " , none ) except value error : return none
self , agg funcs , * args , ** kwargs return self . agg ( " agg " , how args = ( agg funcs , ) + args , how kwargs = kwargs , agg funcs , * args , ** kwargs return self . agg ( " agg " , how args = ( agg funcs , ) + args , how kwargs = kwargs )
self return self . agg ( " count " , fill value = 0 return self . agg ( " count " , fill value = 0 )
self return self . agg ( " last " return self . agg ( " last " )
self return self . agg ( " mean " return self . agg ( " mean " )
self return self . agg ( " min " return self . agg ( " min " )
self return self . agg ( " median " return self . agg ( " median " )
self return self . agg ( " max " return self . agg ( " max " )
self return self . agg ( " ohlc " return self . agg ( " ohlc " )
self return self . agg ( " std " return self . agg ( " std " )
self return self . agg ( " var " return self . agg ( " var " )
df , freq , how = " mean " , ** kwargs return getattr ( df . resample ( freq , ** kwargs ) , how ) ( , freq , how = " mean " , ** kwargs return getattr ( df . resample ( freq , ** kwargs ) , how ) ( )
f , orient , lines , engine , kwargs with f as f : return engine ( f , orient = orient , lines = lines , ** kwargs orient , lines , engine , kwargs with f as f : return engine ( f , orient = orient , lines = lines , ** kwargs )
total memory , cpu count memory factor = 10 blocksize = int ( total memory // cpu count / memory factor ) return min ( blocksize , int ( 64e6 ) l memory , cpu count memory factor = 10 blocksize = int ( total memory // cpu count / memory factor ) return min ( blocksize , int ( 64e6 ) )
df , fil , * , depend on = none , ** kwargs with fil as f : df . to csv ( f , ** kwargs ) return non, fil , * , depend on = none , ** kwargs with fil as f : df . to csv ( f , ** kwargs ) return none
n , rstate return rstate . rand ( n ) * 2 rstate return rstate . rand ( n ) * 2 1
n , rstate , lam = 1000 return rstate . poisson ( lam , size = n rstate , lam = 1000 return rstate . poisson ( lam , size = n )
n , rstate return rstate . choice ( names , size = n rstate return rstate . choice ( names , size = n )
n , rstate return pd . categorical . from codes ( rstate . randint ( 0 , len ( names ) , size = n ) , names rstate return pd . categorical . from codes ( rstate . randint ( 0 , len ( names ) , size = n ) , names )
pd to hdf , lock , args , kwargs = none if lock : lock . acquire ( ) try : pd to hdf ( * args , ** kwargs ) finally : if lock : lock . release ( ) return none
fs , path , stripe , columns = none orc = import required ( " pyarrow . orc " , " please install pyarrow >= 0 . 9 . 0 " ) import pyarrow as pa with fs . open ( path , " rb " ) as f : o = orc . orc file ( f ) table = o . read stripe ( stripe , columns ) if pa . version < loose version ( " 0 . 11 . 0 " ) : return table . to pandas ( ) else : return table . to pandas ( date as object = false )
df , index = false if isinstance ( df , pd . data frame ) : return list ( map ( tuple , df . itertuples ( index ) ) ) elif isinstance ( df , pd . series ) : return list ( df . iteritems ( ) ) if index else list ( df , index = false if isinstance ( df , pd . data frame ) : return list ( map ( tuple , df . itertuples ( index ) ) ) elif isinstance ( df , pd . series ) : return list ( df . iteritems ( ) ) if index else list ( df )
df return df . map partitions ( m . to records )
func , fs , meta , part , columns , index , kwargs df = func ( fs , part , columns , index , ** kwargs ) if meta . columns . name : df . columns . name = meta . columns . name columns = columns or [ ] index = index or [ ] return df [ [ c for c in columns if c not in index ] ]
fs , paths , categories = none , index = none , gather statistics = none , filters = none , ** kwargs raise not implemented error ( )
fs , piece , columns , index , ** kwargs raise not implemented error ( )
df , fs , path , append = false , partition on = none , ignore divisions = false , division info = none , ** kwargs raise not implemented error
df , path , fs , filename , partition on , return metadata , ** kwargs raise not implemented error
parts , meta , fs , path , append = false , ** kwargs raise not implemented error ( )
pieces row groups = [ ] for piece in pieces : for rg in range ( piece . get metadata ( ) . num row groups ) : row group = piece . get metadata ( ) . row group ( rg ) for c in range ( row group . num columns ) : if not row group . column ( c ) . statistics : return [ ] row groups . append ( row group ) return row groups
def if skip fastparquet : pytest . skip ( skip fastparquet reason if skip fastparquet : pytest . skip ( skip fastparquet reason )
def if skip pyarrow : pytest . skip ( skip pyarrow reason if skip pyarrow : pytest . skip ( skip pyarrow reason )
request return request . paraest return request . param
tmpdir , write engine , read engine fn = str ( tmpdir ) ddf . to parquet ( fn , engine = write engine , write index = false ) df = dd . read parquet ( fn , engine = read engine , index = false ) assert df . index . name is none assert not df . known divisionir , write engine , read engine fn = str ( tmpdir ) ddf . to parquet ( fn , engine = write engine , write index = false ) df = dd . read parquet ( fn , engine = read engine , index = false ) assert df . index . name is none assert not df . known divisions
request return request . paraest return request . param
def with pytest . raises ( value error ) as info : dd . read parquet ( " foo " , engine = " foo " ) assert " foo " in str ( info . value ) assert " arrow " in str ( info . value ) assert " fastparquet " in str ( info . value with pytest . raises ( value error ) as info : dd . read parquet ( " foo " , engine = " foo " ) assert " foo " in str ( info . value ) assert " arrow " in str ( info . value ) assert " fastparquet " in str ( info . value )
s return " \ " . join ( map ( str . strip , s . strip ( ) . split ( " \ " ) ) turn " \ " . join ( map ( str . strip , s . strip ( ) . split ( " \ " ) ) )
path return os . path . split ( path ) [ 1 return os . path . split ( path ) [ 1 ]
reader , files b = files [ " 2014 01 01 . csv " ] df = pandas read text ( reader , b , b " " , { " usecols " : [ " name " , " id " ] } ) assert list ( df . columns ) == [ " name " , " id " er , files b = files [ " 2014 01 01 . csv " ] df = pandas read text ( reader , b , b " " , { " usecols " : [ " name " , " id " ] } ) assert list ( df . columns ) == [ " name " , " id " ]
dd read , pd read , text , skip names = [ " name " , " amount " ] with filetext ( text ) as fn : actual = dd read ( fn , skiprows = skip , names = names ) assert eq ( actual , pd read ( fn , skiprows = skip , names = names ) ead , pd read , text , skip names = [ " name " , " amount " ] with filetext ( text ) as fn : actual = dd read ( fn , skiprows = skip , names = names ) assert eq ( actual , pd read ( fn , skiprows = skip , names = names ) )
def text = normalize text ( ) with filetext ( text ) as fn : df = dd . read csv ( fn , skipinitialspace = true , blocksize = 20 ) assert " amount " in df . columns assert df . amount . max ( ) . compute ( ) == 600
def text = normalize text ( ) with filetext ( text ) as fn : df = dd . read csv ( fn , blocksize = 30 ) assert df . amount . compute ( ) . dtype == float
def text1 = normalize text ( ) text2 = normalize text ( """ name , amount 1 , 400 2 , 500 frank , 600 """ ) with filetexts ( { " foo . 1 . csv " : text1 , " foo . 2 . csv " : text2 } ) : df = dd . read csv ( " foo . * . csv " , blocksize = 25 ) assert df . name . dtype == object assert df . name . compute ( ) . dtype == object
def with filetext ( " a , b " ) as fn : df = dd . read csv ( fn , header = 0 ) assert len ( df . compute ( ) ) == 0 assert list ( df . columns ) == [ " a " , " b " with filetext ( " a , b " ) as fn : df = dd . read csv ( fn , header = 0 ) assert len ( df . compute ( ) ) == 0 assert list ( df . columns ) == [ " a " , " b " ]
def with filetexts ( csv files , mode = " b " ) as fn : df = dd . read csv ( fn , sample = false ) assert list ( df . columns ) == [ " name " , " amount " , " id " with filetexts ( csv files , mode = " b " ) as fn : df = dd . read csv ( fn , sample = false ) assert list ( df . columns ) == [ " name " , " amount " , " id " ]
def with filetexts ( csv files , mode = " b " ) : a = dd . read csv ( " 2014 01 * . csv " , enforce = true ) b = dd . read csv ( " 2014 01 * . csv " , enforce = false ) assert a . name != b . namwith filetexts ( csv files , mode = " b " ) : a = dd . read csv ( " 2014 01 * . csv " , enforce = true ) b = dd . read csv ( " 2014 01 * . csv " , enforce = false ) assert a . name != b . name
def assert isinstance ( auto blocksize ( 3000 , 15 ) , int ) assert auto blocksize ( 3000 , 3 ) == 100 assert auto blocksize ( 5000 , 2 ) == 25assert isinstance ( auto blocksize ( 3000 , 15 ) , int ) assert auto blocksize ( 3000 , 3 ) == 100 assert auto blocksize ( 5000 , 2 ) == 250
def fn = " . not . a . real . file . csv " try : dd . read csv ( fn ) assert false except ( os error , io error ) as e : assert fn in str ( e fn = " . not . a . real . file . csv " try : dd . read csv ( fn ) assert false except ( os error , io error ) as e : assert fn in str ( e )
def with filetext ( " alice , 1\bob , 2 " ) as fn : df = dd . read csv ( fn , header = none ) assert list ( df . columns ) == [ 0 , 1 with filetext ( " alice , 1\bob , 2 " ) as fn : df = dd . read csv ( fn , header = none ) assert list ( df . columns ) == [ 0 , 1 ]
def text = . replace ( " " , " \\t " ) with filetext ( text ) as fn : df = dd . read csv ( fn , sep = " \\t " ) assert eq ( df , pd . read csv ( fn , sep = " \\t " ) ) df = dd . read csv ( fn , delimiter = " \\t " ) assert eq ( df , pd . read csv ( fn , delimiter = " \\t " ) )
def with filetext ( csv text ) as fn : df = dd . read csv ( fn , usecols = none ) assert eq ( df , pd . read csv ( fn , usecols = none ) with filetext ( csv text ) as fn : df = dd . read csv ( fn , usecols = none ) assert eq ( df , pd . read csv ( fn , usecols = none ) )
def pdmc text = normalize text ( ) with filetext ( pdmc text ) as fn : ddf = dd . read csv ( fn , parse dates = [ [ " date " , " time " ] ] ) df = pd . read csv ( fn , parse dates = [ [ " date " , " time " ] ] ) assert ( df . columns == ddf . columns ) . all ( ) assert len ( df ) == len ( ddf )
def sep text = normalize text ( ) with filetext ( sep text ) as fn : ddf = dd . read csv ( fn , sep = " ### " , engine = " python " ) df = pd . read csv ( fn , sep = " ### " , engine = " python " ) assert ( df . columns == ddf . columns ) . all ( ) assert len ( df ) == len ( ddf )
def data = b " a , b\1 , 2\3 , 4\5 , 6 " with filetext ( data , mode = " wb " ) as fn : assert eq ( pd . read csv ( fn , dtype = float ) , dd . read csv ( fn , dtype = float ) data = b " a , b\1 , 2\3 , 4\5 , 6 " with filetext ( data , mode = " wb " ) as fn : assert eq ( pd . read csv ( fn , dtype = float ) , dd . read csv ( fn , dtype = float ) )
@ with tmpfile ( ) as f : uri = " sqlite:///%s " % f df . to sql ( " test " , uri , index = true , if exists = " replace " ) yield urth tmpfile ( ) as f : uri = " sqlite:///%s " % f df . to sql ( " test " , uri , index = true , if exists = " replace " ) yield uri
db data = read sql table ( " test " , db , npartitions = 2 , index col = " number " ) . compute ( ) assert ( data . name == df . name ) . all ( ) assert data . index . name == " number " assert eq ( data , df ata = read sql table ( " test " , db , npartitions = 2 , index col = " number " ) . compute ( ) assert ( data . name == df . name ) . all ( ) assert data . index . name == " number " assert eq ( data , df )
db data = read sql table ( " test " , db , npartitions = 2 , index col = " number " , limits = [ 1 , 4 ] ) assert data . index . min ( ) . compute ( ) == 1 assert data . index . max ( ) . compute ( ) == ata = read sql table ( " test " , db , npartitions = 2 , index col = " number " , limits = [ 1 , 4 ] ) assert data . index . min ( ) . compute ( ) == 1 assert data . index . max ( ) . compute ( ) == 4
db with pytest . raises ( type error ) : read sql table ( " test " , db , npartitions = 2 , index col = " name " , divisions = none ith pytest . raises ( type error ) : read sql table ( " test " , db , npartitions = 2 , index col = " name " , divisions = none )
@ pytest . importorskip ( " requests " ) d = read orc ( url ) assert set ( d . columns ) == { " time " , " date " } assert len ( d ) == 7000test . importorskip ( " requests " ) d = read orc ( url ) assert set ( d . columns ) == { " time " , " date " } assert len ( d ) == 70000
dtype kwargs = { } if pandas version >= " 0 . 24 . 0rc1 " : kwargs [ " dtype " ] = dtype return decimal array . from sequence ( [ decimal ( " 0 " ) , decimal ( " na n " ) ] , ** kwargs e kwargs = { } if pandas version >= " 0 . 24 . 0rc1 " : kwargs [ " dtype " ] = dtype return decimal array . from sequence ( [ decimal ( " 0 " ) , decimal ( " na n " ) ] , ** kwargs )
x return decimal ( " 1 " turn decimal ( " 1 " )
def result = dd . utils . make meta ( decimal ( " 1 . 0 " ) ) assert result == decimal ( " 1 . 0 " result = dd . utils . make meta ( decimal ( " 1 . 0 " ) ) assert result == decimal ( " 1 . 0 " )
df , before , after , c = 0 a = df . shift ( before ) b = df . shift ( after ) return df + a + b + , before , after , c = 0 a = df . shift ( before ) b = df . shift ( after ) return df + a + b + c
def ddf = dd . from pandas ( pd . data frame ( [ 10 ] * 30 ) , npartitions = 3 ) assert repr ( ddf . rolling ( 4 ) ) == " rolling [window=4 , center= false , axis=0] "ddf = dd . from pandas ( pd . data frame ( [ 10 ] * 30 ) , npartitions = 3 ) assert repr ( ddf . rolling ( 4 ) ) == " rolling [window=4 , center= false , axis=0] "
def assert repr ( dts . rolling ( " 4s " ) ) == ( " rolling [window=4000000000 , center= false , win type=freq , axis=0] " assert repr ( dts . rolling ( " 4s " ) ) == ( " rolling [window=4000000000 , center= false , win type=freq , axis=0] " )
def result = dts . rolling ( " 4s " ) assert result . window == " 4s " assert result . min periods is none assert result . win type is none assert result . win type == " freq " assert result . window == 4000000000 assert result . min periods == result = dts . rolling ( " 4s " ) assert result . window == " 4s " assert result . min periods is none assert result . win type is none assert result . win type == " freq " assert result . window == 4000000000 assert result . min periods == 1
method from dask . dataframe . tests . test multi import list eq list eq ( shuffle ( d , d . b , shuffle = method ) , shuffle ( d , " b " , shuffle = method ) od from dask . dataframe . tests . test multi import list eq list eq ( shuffle ( d , d . b , shuffle = method ) , shuffle ( d , " b " , shuffle = method ) )
n return pd . data frame ( { " x " : np . random . random ( n ) , " y " : np . random . random ( n ) } turn pd . data frame ( { " x " : np . random . random ( n ) , " y " : np . random . random ( n ) } )
def for t in [ pd . timestamp , np . datetime64 ] : assert isinstance ( coerce loc index ( [ t ( " 2014 " ) ] , " 2014 " ) , t for t in [ pd . timestamp , np . datetime64 ] : assert isinstance ( coerce loc index ( [ t ( " 2014 " ) ] , " 2014 " ) , t )
def s = pd . series ( [ 1 , 2 , 3 ] ) ds = dd . from pandas ( s , 2 ) with pytest . raises ( attribute error ) : ds . iloc [ : s = pd . series ( [ 1 , 2 , 3 ] ) ds = dd . from pandas ( s , 2 ) with pytest . raises ( attribute error ) : ds . iloc [ : ]
pandas , scalar dask compare = scalar >= dd . from pandas ( pandas , npartitions = 3 ) pandas compare = scalar >= pandas assert eq ( dask compare , pandas compare as , scalar dask compare = scalar >= dd . from pandas ( pandas , npartitions = 3 ) pandas compare = scalar >= pandas assert eq ( dask compare , pandas compare )
def arr = da . from array ( np . arange ( 10 ) . reshape ( 5 , 2 ) , chunks = ( 5 , 2 ) ) frame = dd . from dask array ( arr , columns = [ " a " , " a " ] ) repr ( frame arr = da . from array ( np . arange ( 10 ) . reshape ( 5 , 2 ) , chunks = ( 5 , 2 ) ) frame = dd . from dask array ( arr , columns = [ " a " , " a " ] ) repr ( frame )
@ a = pd . series ( [ 1 , none , 2 ] , dtype = pd . int32 dtype ( ) ) b = dd . from pandas ( a , 2 ) assert eq ( a . sum ( ) , b . sum ( ) = pd . series ( [ 1 , none , 2 ] , dtype = pd . int32 dtype ( ) ) b = dd . from pandas ( a , 2 ) assert eq ( a . sum ( ) , b . sum ( ) )
data exp = pd . get dummies ( data ) ddata = dd . from pandas ( data , 2 ) res = dd . get dummies ( ddata ) assert eq ( res , exp ) tm . assert index equal ( res . columns , exp . columns exp = pd . get dummies ( data ) ddata = dd . from pandas ( data , 2 ) res = dd . get dummies ( ddata ) assert eq ( res , exp ) tm . assert index equal ( res . columns , exp . columns )
def assert eq ( d . index . head ( 2 ) , full . index [ : 2 ] ) assert eq ( d . index . head ( 3 ) , full . index [ : 3 ] assert eq ( d . index . head ( 2 ) , full . index [ : 2 ] ) assert eq ( d . index . head ( 3 ) , full . index [ : 3 ] )
def assert isinstance ( d . a , dd . series ) assert isinstance ( d . a + 1 , dd . series ) assert eq ( ( d + 1 ) , full + 1 assert isinstance ( d . a , dd . series ) assert isinstance ( d . a + 1 , dd . series ) assert eq ( ( d + 1 ) , full + 1 )
def result = d . map partitions ( type ) . compute ( scheduler = " single threaded " ) assert isinstance ( result , pd . series ) assert all ( x == pd . data frame for x in result result = d . map partitions ( type ) . compute ( scheduler = " single threaded " ) assert isinstance ( result , pd . series ) assert all ( x == pd . data frame for x in result )
def assert d . ndim == 2 assert d . a . ndim == 1 assert d . index . ndim == assert d . ndim == 2 assert d . a . ndim == 1 assert d . index . ndim == 1
def assert len ( d ) == len ( full ) assert len ( d . a ) == len ( full . a assert len ( d ) == len ( full ) assert len ( d . a ) == len ( full . a )
def assert eq ( d . size , full . size ) assert eq ( d . a . size , full . a . size ) assert eq ( d . index . size , full . index . size assert eq ( d . size , full . size ) assert eq ( d . a . size , full . a . size ) assert eq ( d . index . size , full . index . size )
def assert eq ( d . a . nbytes , full . a . nbytes ) assert eq ( d . index . nbytes , full . index . nbytes assert eq ( d . a . nbytes , full . a . nbytes ) assert eq ( d . index . nbytes , full . index . nbytes )
def assert d . known divisions df = dd . data frame ( dsk , " x " , meta , divisions = [ none , none , none ] ) assert not df . known divisionassert d . known divisions df = dd . data frame ( dsk , " x " , meta , divisions = [ none , none , none ] ) assert not df . known divisions
def df = pd . data frame ( { " x " : range ( 100 ) } ) a = dd . from pandas ( df , npartitions = 15 ) assert a . npartitions == 15 b = a . repartition ( npartitions = 11 ) assert eq ( a , b )
def renamer = { " a " : " a " , " b " : " b " } assert eq ( d . rename ( columns = renamer ) , full . rename ( columns = renamer ) renamer = { " a " : " a " , " b " : " b " } assert eq ( d . rename ( columns = renamer ) , full . rename ( columns = renamer ) )
def renamer = lambda x : x . upper ( ) assert eq ( d . rename ( columns = renamer ) , full . rename ( columns = renamer ) renamer = lambda x : x . upper ( ) assert eq ( d . rename ( columns = renamer ) , full . rename ( columns = renamer ) )
def renamer = { 0 : 1 } pytest . raises ( value error , lambda : d . rename ( index = renamer ) renamer = { 0 : 1 } pytest . raises ( value error , lambda : d . rename ( index = renamer ) )
def s = pd . data frame ( { " x " : [ 1 , 2 , 3 , 4 ] } ) ds = dd . from pandas ( s , npartitions = 2 ) for ( a , b ) in zip ( s [ " x " ] , ds [ " x " ] ) : assert a == s = pd . data frame ( { " x " : [ 1 , 2 , 3 , 4 ] } ) ds = dd . from pandas ( s , npartitions = 2 ) for ( a , b ) in zip ( s [ " x " ] , ds [ " x " ] ) : assert a == b
def df = tm . make time data frame ( ) ddf = dd . from pandas ( df . reset index ( ) , npartitions = 2 ) df . index . name = " index " assert eq ( ddf . set index ( " index " , sorted = true , drop = true ) , df df = tm . make time data frame ( ) ddf = dd . from pandas ( df . reset index ( ) , npartitions = 2 ) df . index . name = " index " assert eq ( ddf . set index ( " index " , sorted = true , drop = true ) , df )
values s = pd . series ( values ) ds = dd . from pandas ( s , npartitions = 2 ) assert eq ( pd . isna ( s ) , dd . isna ( ds ) es s = pd . series ( values ) ds = dd . from pandas ( s , npartitions = 2 ) assert eq ( pd . isna ( s ) , dd . isna ( ds ) )
def df = pd . data frame ( ) result = methods . boundary slice ( df , 1 , 4 ) expected = pd . data frame ( ) tm . assert frame equal ( result , expected df = pd . data frame ( ) result = methods . boundary slice ( df , 1 , 4 ) expected = pd . data frame ( ) tm . assert frame equal ( result , expected )
index , left , right df = pd . data frame ( { " a " : range ( len ( index ) ) } , index = index ) result = methods . boundary slice ( df , left , right ) tm . assert frame equal ( result , df x , left , right df = pd . data frame ( { " a " : range ( len ( index ) ) } , index = index ) result = methods . boundary slice ( df , left , right ) tm . assert frame equal ( result , df )
def df = pd . data frame ( { " x " : [ 1 , 2 , 3 , 4 , 5 ] } ) ddf = dd . from pandas ( df , npartitions = 2 ) assert eq ( ddf ( ddf . sum ( ) + 1 ) , df ( df . sum ( ) + 1 ) df = pd . data frame ( { " x " : [ 1 , 2 , 3 , 4 , 5 ] } ) ddf = dd . from pandas ( df , npartitions = 2 ) assert eq ( ddf ( ddf . sum ( ) + 1 ) , df ( df . sum ( ) + 1 ) )
def assert has parallel type ( pd . data frame ( ) ) assert has parallel type ( pd . series ( ) ) assert not has parallel type ( 123 assert has parallel type ( pd . data frame ( ) ) assert has parallel type ( pd . series ( ) ) assert not has parallel type ( 123 )
npartitions , ncategories rows per category = 10 n rows = ncategories * rows per category categories = [ " cat " + str ( i ) for i in range ( ncategories ) ] pdf = pd . data frame ( { " id " : categories * rows per category , " value " : np . random . random ( n rows ) } ) ddf = dd . from pandas ( pdf , npartitions = npartitions ) ddf [ " id " ] = ddf [ " id " ] . astype ( " category " ) . cat . as ordered ( ) ddf = ddf . set index ( " id " )
x return x if isinstance ( x , pd . categorical index ) else x . caturn x if isinstance ( x , pd . categorical index ) else x . cat
left , right , check divisions = false assert eq ( left , pd . index ( right ) if isinstance ( right , np . ndarray ) else right , check divisions = check divisions , )
self , series , prop , compare s , ds = series expected = getattr ( get cat ( s ) , prop ) result = getattr ( get cat ( ds ) , prop ) compare ( result , expected , check divisions = false , series , prop , compare s , ds = series expected = getattr ( get cat ( s ) , prop ) result = getattr ( get cat ( ds ) , prop ) compare ( result , expected , check divisions = false )
self a = pd . series ( [ " a " , " a " , " b " ] , dtype = " category " ) da = dd . from pandas ( a , 2 ) result = da . str . upper ( ) expected = a . str . upper ( ) assert eq ( result , expected a = pd . series ( [ " a " , " a " , " b " ] , dtype = " category " ) da = dd . from pandas ( a , 2 ) result = da . str . upper ( ) expected = a . str . upper ( ) assert eq ( result , expected )
self a = pd . series ( [ 1 , 2 , 3 ] , dtype = " category " ) da = dd . from pandas ( a , 2 ) with pytest . raises ( attribute error ) : da . str . upper ( a = pd . series ( [ 1 , 2 , 3 ] , dtype = " category " ) da = dd . from pandas ( a , 2 ) with pytest . raises ( attribute error ) : da . str . upper ( )
obj a = hash pandas object ( obj ) b = hash pandas object ( obj ) if isinstance ( a , np . ndarray ) : np . testing . assert equal ( a , b ) else : assert eq ( a , b a = hash pandas object ( obj ) b = hash pandas object ( obj ) if isinstance ( a , np . ndarray ) : np . testing . assert equal ( a , b ) else : assert eq ( a , b )
def s = pd . series ( [ " a " , " b " , " c " , none ] ) h1 = hash pandas object ( s ) . iloc [ : 3 ] h2 = hash pandas object ( s . iloc [ : 3 ] ) tm . assert series equal ( h1 , h2 s = pd . series ( [ " a " , " b " , " c " , none ] ) h1 = hash pandas object ( s ) . iloc [ : 3 ] h2 = hash pandas object ( s . iloc [ : 3 ] ) tm . assert series equal ( h1 , h2 )
obj result = dd . utils . hash object dispatch ( obj ) expected = pd . util . hash pandas object ( obj ) assert eq ( result , expected result = dd . utils . hash object dispatch ( obj ) expected = pd . util . hash pandas object ( obj ) assert eq ( result , expected )
df , npartitions ddf = dd . from pandas ( df , npartitions = npartitions ) approx = ddf . nunique approx ( ) . compute ( scheduler = " sync " ) exact = len ( df . drop duplicates ( ) ) assert abs ( approx exact ) <= 2 or abs ( approx exact ) / exact < 0 . 0, npartitions ddf = dd . from pandas ( df , npartitions = npartitions ) approx = ddf . nunique approx ( ) . compute ( scheduler = " sync " ) exact = len ( df . drop duplicates ( ) ) assert abs ( approx exact ) <= 2 or abs ( approx exact ) / exact < 0 . 05
request return request . param
def df = tm . make time data frame ( ) ddf = dd . from pandas ( df , npartitions = 2 ) pytest . raises ( type error , lambda : ddf . groupby ( df . index . month , as index = false ) df = tm . make time data frame ( ) ddf = dd . from pandas ( df , npartitions = 2 ) pytest . raises ( type error , lambda : ddf . groupby ( df . index . month , as index = false ) )
def d = pd . data frame ( { " g " : [ 0 , 0 , 1 ] * 3 , " b " : [ 1 , 2 , 3 ] * 3 } ) a = dd . from pandas ( d , npartitions = 2 ) agg func = dd . aggregation ( " sum " , lambda s : s . sum ( ) , lambda s0 : s0 . sum ( ) ) with pytest . raises ( value error ) : a . groupby ( " g " ) . aggregate ( { " b " : [ agg func , " sum " ] } )
def df = dask . datasets . timeseries ( ) . partitions [ : 2 ] assert eq ( df . groupby ( " name " ) . std ( ) , df . groupby ( " name " ) . std ( ) df = dask . datasets . timeseries ( ) . partitions [ : 2 ] assert eq ( df . groupby ( " name " ) . std ( ) , df . groupby ( " name " ) . std ( ) )
self return self . ite return self . item
self return self . ite return self . item
df ddf df , ddf = df ddf with pytest . raises ( attribute error ) as exc : ddf . str col . dt assert " . dt accessor " in str ( exc . value df df , ddf = df ddf with pytest . raises ( attribute error ) as exc : ddf . str col . dt assert " . dt accessor " in str ( exc . value )
df ddf df , ddf = df ddf with pytest . raises ( attribute error ) as exc : ddf . int col . str assert " . str accessor " in str ( exc . value ) assert " str " not in dir ( ddf . int col df df , ddf = df ddf with pytest . raises ( attribute error ) as exc : ddf . int col . str assert " . str accessor " in str ( exc . value ) assert " str " not in dir ( ddf . int col )
df ddf df , ddf = df ddf assert eq ( ddf . str col . str [ : 2 ] , df . str col . str [ : 2 ] ) assert eq ( ddf . str col . str [ 1 ] , df . str col . str [ 1 ] df df , ddf = df ddf assert eq ( ddf . str col . str [ : 2 ] , df . str col . str [ : 2 ] ) assert eq ( ddf . str col . str [ 1 ] , df . str col . str [ 1 ] )
df ddf df , ddf = df ddf assert eq ( ddf . str col . str . extractall ( " ( . *)b( . *) " ) , df . str col . str . extractall ( " ( . *)b( . *) " ) df df , ddf = df ddf assert eq ( ddf . str col . str . extractall ( " ( . *)b( . *) " ) , df . str col . str . extractall ( " ( . *)b( . *) " ) )
df left return dd . repartition ( df left , [ 0 , 1 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 ] eft return dd . repartition ( df left , [ 0 , 1 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 ] )
ddf left return ddf left . clear divisions ( left return ddf left . clear divisions ( )
df left return dd . from pandas ( df left , npartitions = 1 , sort = false eft return dd . from pandas ( df left , npartitions = 1 , sort = false )
df right return dd . repartition ( df right , [ 0 , 1 , 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 ] ight return dd . repartition ( df right , [ 0 , 1 , 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 ] )
ddf right return ddf right . clear divisions ( right return ddf right . clear divisions ( )
df right return dd . from pandas ( df right , npartitions = 1 , sort = false ight return dd . from pandas ( df right , npartitions = 1 , sort = false )
request return request . paraest return request . param
request return request . paraest return request . param
self , key , dsk , state start = default timer ( ) self . results [ key ] = ( key , dsk [ key ] , start , key , dsk , state start = default timer ( ) self . results [ key ] = ( key , dsk [ key ] , start )
self , key , value , dsk , state , id end = default timer ( ) self . results [ key ] += ( end , id , key , value , dsk , state , id end = default timer ( ) self . results [ key ] += ( end , id )
self , dsk , state , failed results = dict ( ( k , v ) for k , v in self . results . items ( ) if len ( v ) == 5 ) self . results += list ( starmap ( task data , results . values ( ) ) ) self . results . clear ( , dsk , state , failed results = dict ( ( k , v ) for k , v in self . results . items ( ) if len ( v ) == 5 ) self . results += list ( starmap ( task data , results . values ( ) ) ) self . results . clear ( )
self , ** kwargs from . profile visualize import plot tasks return plot tasks ( self . results , self . dsk , ** kwargs , ** kwargs from . profile visualize import plot tasks return plot tasks ( self . results , self . dsk , ** kwargs )
self , ** kwargs from . profile visualize import visualize return visualize ( self , ** kwargs )
self self . results . clear ( ) del self . results [ : ] self . dsk = { }
self return self . tracker is not none and self . tracker . is alive ( return self . tracker is not none and self . tracker . is alive ( )
self if not self . is running ( ) : self . tracker = tracker ( self . dt ) self . tracker . start ( ) self . tracker . parent conn . send ( " collect " if not self . is running ( ) : self . tracker = tracker ( self . dt ) self . tracker . start ( ) self . tracker . parent conn . send ( " collect " )
self if self . is running ( ) : self . tracker . parent conn . send ( " send data " ) self . results . extend ( starmap ( resource data , self . tracker . parent conn . recv ( ) ) if self . is running ( ) : self . tracker . parent conn . send ( " send data " ) self . results . extend ( starmap ( resource data , self . tracker . parent conn . recv ( ) ) )
self , dsk self . start collect ( , dsk self . start collect ( )
self , dsk , state , failed if not self . entered : self . stop collect ( , dsk , state , failed if not self . entered : self . stop collect ( )
self if self . is running ( ) : self . tracker . shutdown ( ) self . tracker = none
self self . results = [ self . results = [ ]
self , ** kwargs from . profile visualize import plot resources return plot resources ( self . results , ** kwargs , ** kwargs from . profile visualize import plot resources return plot resources ( self . results , ** kwargs )
self if not self . parent conn . closed : self . parent conn . send ( " shutdown " ) self . parent conn . close ( ) self . join ( if not self . parent conn . closed : self . parent conn . send ( " shutdown " ) self . parent conn . close ( ) self . join ( )
self , pid return [ self . parent ] + [ p for p in self . parent . children ( ) if p . pid != pid and p . status ( ) != " zombie " , pid return [ self . parent ] + [ p for p in self . parent . children ( ) if p . pid != pid and p . status ( ) != " zombie " ]
self , dsk self . dsk . update ( dsk ) if not self . start time : self . start time = default timer ( , dsk self . dsk . update ( dsk ) if not self . start time : self . start time = default timer ( )
self , ** kwargs from . profile visualize import plot cache return plot cache ( self . results , self . dsk , self . start time , self . metric name , ** kwargs , ** kwargs from . profile visualize import plot cache return plot cache ( self . results , self . dsk , self . start time , self . metric name , ** kwargs )
self self . results = [ ] self . cache = { } self . dsk = { } self . start time = none
t m , s = divmod ( t , 60 ) h , m = divmod ( m , 60 ) if h : return " {0:2 . 0f}hr {1:2 . 0f}min {2:4 . 1f}s " . format ( h , m , s ) elif m : return " {0:2 . 0f}min {1:4 . 1f}s " . format ( m , s ) else : return " {0:4 . 1f}s " . format ( s )
self , dsk self . state = none self . start time = default timer ( ) self . running = true self . timer = threading . thread ( target = self . timer func ) self . timer . daemon = true self . timer . start ( , dsk self . state = none self . start time = default timer ( ) self . running = true self . timer = threading . thread ( target = self . timer func ) self . timer . daemon = true self . timer . start ( )
self , key , dsk , state self . state = state self . file . flush ( , key , dsk , state self . state = state self . file . flush ( )
self while self . running : elapsed = default timer ( ) self . start time if elapsed > self . minimum : self . update bar ( elapsed ) time . sleep ( self . dt )
start , end , min span return start , max ( end , start + min span )
profiler prof = profiler ( ) try : prof . register ( ) get ( dsk2 , " c " ) n = len ( prof . results ) assert n > 0 get ( dsk2 , " c " ) assert len ( prof . results ) > n finally : prof . unregister ( iler prof = profiler ( ) try : prof . register ( ) get ( dsk2 , " c " ) n = len ( prof . results ) assert n > 0 get ( dsk2 , " c " ) assert len ( prof . results ) > n finally : prof . unregister ( )
capsys from dask . array import ones data = ones ( ( 100 , 100 ) , dtype = " f4 " , chunks = ( 100 , 100 ) ) with progress bar ( ) : out = data . sum ( ) . compute ( ) assert out == 10000 check bar completed ( capsys ys from dask . array import ones data = ones ( ( 100 , 100 ) , dtype = " f4 " , chunks = ( 100 , 100 ) ) with progress bar ( ) : out = data . sum ( ) . compute ( ) assert out == 10000 check bar completed ( capsys )
capsys with progress bar ( ) : out = get threaded ( dsk , " e " ) assert out == 6 check bar completed ( capsys ) with progress bar ( width = 20 ) : out = get threaded ( dsk , " e " ) check bar completed ( capsys , 20 ys with progress bar ( ) : out = get threaded ( dsk , " e " ) assert out == 6 check bar completed ( capsys ) with progress bar ( width = 20 ) : out = get threaded ( dsk , " e " ) check bar completed ( capsys , 20 )
capsys with progress bar ( 1 . 0 ) : out = get threaded ( dsk , " e " ) out , err = capsys . readouterr ( ) assert out == " " and err == " "ys with progress bar ( 1 . 0 ) : out = get threaded ( dsk , " e " ) out , err = capsys . readouterr ( ) assert out == " " and err == " "
get dsk = { " a " : ( lambda : 1 / 0 , ) } try : with progress bar ( ) as pbar : get threaded ( dsk , " a " ) except zero division error : pass assert not pbar . running assert not pbar . timer . is alive ( dsk = { " a " : ( lambda : 1 / 0 , ) } try : with progress bar ( ) as pbar : get threaded ( dsk , " a " ) except zero division error : pass assert not pbar . running assert not pbar . timer . is alive ( )
capsys try : p = progress bar ( ) p . register ( ) assert callback . active get threaded ( dsk , " e " ) check bar completed ( capsys ) p . unregister ( ) assert not callback . active finally : callback . active . clear ( ys try : p = progress bar ( ) p . register ( ) assert callback . active get threaded ( dsk , " e " ) check bar completed ( capsys ) p . unregister ( ) assert not callback . active finally : callback . active . clear ( )
capsys with progress bar ( ) : get threaded ( { " x " : 1 } , " x " ) check bar completed ( capsys ys with progress bar ( ) : get threaded ( { " x " : 1 } , " x " ) check bar completed ( capsys )
def p = progress bar ( ) with p : get threaded ( { " x " : 1 } , " x " ) assert isinstance ( p . last duration , float p = progress bar ( ) with p : get threaded ( { " x " : 1 } , " x " ) assert isinstance ( p . last duration , float )
lazy file , off , bs , delimiter with copy . copy ( lazy file ) as f : if off == 0 and bs is none : return f . read ( ) return read block ( f , off , bs , delimiter file , off , bs , delimiter with copy . copy ( lazy file ) as f : if off == 0 and bs is none : return f . read ( ) return read block ( f , off , bs , delimiter )
request hdfs = pyarrow . hdfs . connect ( host = " localhost " , port = 8020 ) if hdfs . exists ( basedir ) : hdfs . rm ( basedir , recursive = true ) hdfs . mkdir ( basedir ) yield hdfs if hdfs . exists ( basedir ) : hdfs . rm ( basedir , recursive = true est hdfs = pyarrow . hdfs . connect ( host = " localhost " , port = 8020 ) if hdfs . exists ( basedir ) : hdfs . rm ( basedir , recursive = true ) hdfs . mkdir ( basedir ) yield hdfs if hdfs . exists ( basedir ) : hdfs . rm ( basedir , recursive = true )
@ saved environ = dict ( os . environ ) try : yield finally : os . environ . clear ( ) os . environ . update ( saved environ )
s3 with pytest . raises ( io error ) : read bytes ( " s3:// " + test bucket name + " /non existing/* " ith pytest . raises ( io error ) : read bytes ( " s3:// " + test bucket name + " /non existing/* " )
s3 , values = read bytes ( " s3:// " + test bucket name + " /test/accounts . * " , blocksize = none ) assert sum ( map ( len , values ) ) == len ( files , values = read bytes ( " s3:// " + test bucket name + " /test/accounts . * " , blocksize = none ) assert sum ( map ( len , values ) ) == len ( files )
s3 pa = pytest . importorskip ( " pyarrow " ) fs = dask s3 file system ( anon = true ) assert isinstance ( fs , pa . filesystem . file system a = pytest . importorskip ( " pyarrow " ) fs = dask s3 file system ( anon = true ) assert isinstance ( fs , pa . filesystem . file system )
path return pathlib . path ( os . path . abspath ( path ) ) . as uri ( return pathlib . path ( os . path . abspath ( path ) ) . as uri ( )
def with filetexts ( { " sub1/afile . csv " : b " " , " sub1/sub2/another . csv " : b " " , " sub1/twofile . csv " : b " " } , mode = " b " , ) : , , paths = get fs token paths ( os . path . abspath ( " **/* . csv " ) ) assert len ( paths ) == 3
def with filetexts ( files , mode = " b " ) : sample , values = read bytes ( " . test . accounts . * " , sample = " 40 b " ) assert len ( sample ) == 4with filetexts ( files , mode = " b " ) : sample , values = read bytes ( " . test . accounts . * " , sample = " 40 b " ) assert len ( sample ) == 40
def with filetexts ( files , mode = " b " ) : sample , = read bytes ( " . test . accounts . 1 . json " , sample = false ) assert sample is falswith filetexts ( files , mode = " b " ) : sample , = read bytes ( " . test . accounts . 1 . json " , sample = false ) assert sample is false
def with filetexts ( files , mode = " b " ) : sample , values = read bytes ( " . test . accounts . * " , blocksize = none ) assert sum ( map ( len , values ) ) == len ( files with filetexts ( files , mode = " b " ) : sample , values = read bytes ( " . test . accounts . * " , blocksize = none ) assert sum ( map ( len , values ) ) == len ( files )
def with filetexts ( files , mode = " b " ) : with pytest . raises ( type error ) : read bytes ( " . test . account* " , blocksize = 5 . 5 with filetexts ( files , mode = " b " ) : with pytest . raises ( type error ) : read bytes ( " . test . account* " , blocksize = 5 . 5 )
def with filetexts ( files , mode = " b " ) : , , paths = read bytes ( " . test . accounts . * " , include path = true ) assert { os . path . split ( path ) [ 1 ] for path in paths } == set ( files . keys ( ) with filetexts ( files , mode = " b " ) : , , paths = read bytes ( " . test . accounts . * " , include path = true ) assert { os . path . split ( path ) [ 1 ] for path in paths } == set ( files . keys ( ) )
def with filetexts ( files , mode = " b " ) : for func in [ read bytes , open files ] : with pytest . raises ( value error ) : sample , values = func ( " . test . accounts . * " , compression = " not found " with filetexts ( files , mode = " b " ) : for func in [ read bytes , open files ] : with pytest . raises ( value error ) : sample , values = func ( " . test . accounts . * " , compression = " not found " )
def fn = " not a file " with pytest . raises ( ( file not found error , os error ) , match = fn ) : read bytes ( fn fn = " not a file " with pytest . raises ( ( file not found error , os error ) , match = fn ) : read bytes ( fn )
def from fsspec . implementations . local import local file system pa = pytest . importorskip ( " pyarrow " ) fs = local file system ( ) assert isinstance ( fs , pa . filesystem . file system from fsspec . implementations . local import local file system pa = pytest . importorskip ( " pyarrow " ) fs = local file system ( ) assert isinstance ( fs , pa . filesystem . file system )
dir server root = " http://localhost:8999/ " fn = files [ 0 ] f = open files ( root + fn ) [ 0 ] with f as f : data = f . read ( ) assert data == open ( os . path . join ( dir server , fn ) , " rb " ) . read ( server root = " http://localhost:8999/ " fn = files [ 0 ] f = open files ( root + fn ) [ 0 ] with f as f : data = f . read ( ) assert data == open ( os . path . join ( dir server , fn ) , " rb " ) . read ( )
@ db = pytest . importorskip ( " dask . bag " ) urls = [ " https://raw . githubusercontent . com/weierophinney/pastebin/ " " master/public/js src/dojox/data/tests/stores/patterns . csv " , " https://en . wikipedia . org " , ] b = db . read text ( urls ) assert b . npartitions == 2 b . compute ( = pytest . importorskip ( " dask . bag " ) urls = [ " https://raw . githubusercontent . com/weierophinney/pastebin/ " " master/public/js src/dojox/data/tests/stores/patterns . csv " , " https://en . wikipedia . org " , ] b = db . read text ( urls ) assert b . npartitions == 2 b . compute ( )
@ dd = pytest . importorskip ( " dask . dataframe " ) url = ( " https://raw . githubusercontent . com/weierophinney/pastebin/ " " master/public/js src/dojox/data/tests/stores/patterns . csv " ) b = dd . read csv ( url ) b . compute ( = pytest . importorskip ( " dask . dataframe " ) url = ( " https://raw . githubusercontent . com/weierophinney/pastebin/ " " master/public/js src/dojox/data/tests/stores/patterns . csv " ) b = dd . read csv ( url ) b . compute ( )
urlpath , expected path so = infer storage options ( urlpath ) assert so [ " protocol " ] == " file " assert so [ " path " ] == expected patath , expected path so = infer storage options ( urlpath ) assert so [ " protocol " ] == " file " assert so [ " path " ] == expected path
task , start = true if type ( task ) is list and len ( task ) < 50 : return [ lazify task ( arg , false ) for arg in task ] if not istask ( task ) : return task head , tail = task [ 0 ] , task [ 1 : ] if not start and head in ( list , reify ) : task = task [ 1 ] return lazify task ( * tail , start = false ) else : return ( head , ) + tuple ( [ lazify task ( arg , false ) for arg in tail ] )
dsk return valmap ( lazify task , dsk )
dsk , keys , fuse keys = none , rename fused keys = true , ** kwargs dsk = ensure dict ( dsk ) dsk2 , dependencies = cull ( dsk , keys ) dsk3 , dependencies = fuse ( dsk2 , keys + ( fuse keys or [ ] ) , dependencies , rename keys = rename fused keys ) dsk4 = inline singleton lists ( dsk3 , keys , dependencies ) dsk5 = lazify ( dsk4 ) return dsk5
results return results [ 0 lts return results [ 0 ]
self , key , * args , ** kwargs return self . bag . map ( lambda s : getattr ( s , key ) ( * args , ** kwargs ) , key , * args , ** kwargs return self . bag . map ( lambda s : getattr ( s , key ) ( * args , ** kwargs ) )
self , pattern from fnmatch import fnmatch return self . bag . filter ( partial ( fnmatch , pat = pattern ) )
wrapper def ( wrapped ) : wrapped . doc = wrapper . doc return wrapped return
value from dask . delayed import delayed , delayed if not isinstance ( value , delayed ) and hasattr ( value , " key " ) : value = delayed ( value ) assert isinstance ( value , delayed ) return item ( ensure dict ( value . dask ) , value . key )
self return ( self . dask , self . key return ( self . dask , self . key )
self , func , * args , ** kwargs return bag map ( func , self , * args , ** kwargs )
self return ( self . dask , self . name , self . npartitions return ( self . dask , self . name , self . npartitions )
self , predicate name = " remove {0} {1} " . format ( funcname ( predicate ) , tokenize ( self , predicate ) ) dsk = dict ( ( ( name , i ) , ( reify , ( remove , predicate , ( self . name , i ) ) ) ) for i in range ( self . npartitions ) ) graph = high level graph . from collections ( name , dsk , dependencies = [ self ] ) return type ( self ) ( graph , name , self . npartitions )
self , func , * args , ** kwargs return map partitions ( func , self , * args , ** kwargs )
self , n return tuple ( self . pluck ( i ) for i in range ( n ) )
self , filename , schema , name function = none , storage options = none , codec = " null " , sync interval = 16000 , metadata = none , compute = true , ** kwargs return to avro ( self , filename , schema , name function , storage options , codec , sync interval , metadata , compute , ** kwargs , filename , schema , name function = none , storage options = none , codec = " null " , sync interval = 16000 , metadata = none , compute = true , ** kwargs return to avro ( self , filename , schema , name function , storage options , codec , sync interval , metadata , compute , ** kwargs )
self , binop , combine = none , initial = no default , split every = none , out type = item combine = combine or binop if initial is not no default : return self . reduction ( curry ( reduce , binop , initial = initial ) , curry ( reduce , combine ) , split every = split every , out type = out type , ) else : from toolz . curried import reduce return self . reduction ( reduce ( binop ) , reduce ( combine ) , split every = split every , out type = out type , )
self , split every = none , sort = false result = self . reduction ( frequencies , merge frequencies , out type = bag , split every = split every , name = " frequencies " , ) . map partitions ( dictitems ) if sort : result = result . map partitions ( sorted , key = second , reverse = true ) return result
self , k , key = none , split every = none if key : if callable ( key ) and takes multiple arguments ( key ) : key = partial ( apply , key ) func = partial ( topk , k , key = key ) else : func = partial ( topk , k ) return self . reduction ( func , compose ( func , toolz . concat ) , out type = bag , split every = split every , name = " topk " , )
self , key = none func = chunk distinct if key is none else partial ( chunk distinct , key = key ) agg = merge distinct if key is none else partial ( merge distinct , key = key ) return self . reduction ( func , agg , out type = bag , name = " distinct " )
self , split every = none return self . reduction ( sum , sum , split every = split every )
self , split every = none return self . reduction ( max , max , split every = split every )
self , split every = none return self . reduction ( min , min , split every = split every )
self , split every = none return self . reduction ( all , all , split every = split every )
self def mean chunk ( seq ) : total , n = 0 . 0 , 0 for x in seq : total += x n += 1 return total , n def mean aggregate ( x ) : totals , counts = list ( zip ( * x ) ) return 1 . 0 * sum ( totals ) / sum ( counts ) return self . reduction ( mean chunk , mean aggregate , split every = false )
self , ddof = 0 return self . var ( ddof = ddof ) . apply ( math . sqrt )
self name = " flatten " + tokenize ( self ) dsk = dict ( ( ( name , i ) , ( list , ( toolz . concat , ( self . name , i ) ) ) ) for i in range ( self . npartitions ) ) graph = high level graph . from collections ( name , dsk , dependencies = [ self ] ) return type ( self ) ( graph , name , self . npartitions )
self , optimize graph = true from dask . delayed import delayed keys = self . dask keys ( ) dsk = self . dask graph ( ) if optimize graph : dsk = self . dask optimize ( dsk , keys ) return [ delayed ( k , dsk ) for k in keys ]
grouper , sequence , npartitions , p , nelements = 2 ** 20 for block in partition all ( nelements , sequence ) : d = groupby ( grouper , block ) d2 = defaultdict ( list ) for k , v in d . items ( ) : d2 [ abs ( hash ( k ) ) % npartitions ] . extend ( v ) p . append ( d2 , fsync = true ) return p
grouper , group , p , barrier token d = groupby ( grouper , p . get ( group , lock = false ) ) return list ( d . items ( ) )
urls if isinstance ( urls , str ) : urls = [ urls ] name = " from url " + uuid . uuid4 ( ) . hex dsk = { } for i , u in enumerate ( urls ) : dsk [ ( name , i ) ] = ( list , ( urlopen , u ) ) return bag ( dsk , name , len ( urls ) )
d return list ( d . items ( ) )
bags name = " concat " + tokenize ( * bags ) counter = itertools . count ( 0 ) dsk = { ( name , next ( counter ) ) : key for bag in bags for key in bag . dask keys ( ) } graph = high level graph . from collections ( name , dsk , dependencies = bags ) return bag ( graph , name , len ( dsk ) )
seqs , key = none return chunk distinct ( toolz . concat ( seqs ) , key = key , key = none return chunk distinct ( toolz . concat ( seqs ) , key = key )
n , npartitions size = n // npartitions name = " range %d npartitions %d " % ( n , npartitions ) ijs = list ( enumerate ( take ( npartitions , range ( 0 , n , size ) ) ) ) dsk = dict ( ( ( name , i ) , ( reify , ( range , j , min ( j + size , n ) ) ) ) for i , j in ijs ) if n % npartitions != 0 : i , j = ijs [ 1 ] dsk [ ( name , i ) ] = ( reify , ( range , j , n ) ) return bag ( dsk , name , npartitions )
bags npartitions = bags [ 0 ] . npartitions assert all ( bag . npartitions == npartitions for bag in bags ) name = " zip " + tokenize ( * bags ) dsk = dict ( ( ( name , i ) , ( reify , ( zip , ) + tuple ( ( bag . name , i ) for bag in bags ) ) ) for i in range ( npartitions ) ) graph = high level graph . from collections ( name , dsk , dependencies = bags ) return bag ( graph , name , npartitions )
f , iters , iter kwarg keys = none , kwargs = none if kwargs : f = partial ( f , ** kwargs ) iters = [ iter ( a ) for a in iters ] return map chunk ( f , iters , kwarg keys = iter kwarg keys )
f , x , kwargs if kwargs : f = partial ( f , ** kwargs ) return itertools . starmap ( f , x x , kwargs if kwargs : f = partial ( f , ** kwargs ) return itertools . starmap ( f , x )
binop , sequence , initial = no default if initial is not no default : return reduce ( binop , sequence , initial ) else : return reduce ( binop , sequence p , sequence , initial = no default if initial is not no default : return reduce ( binop , sequence , initial ) else : return reduce ( binop , sequence )
k , stage def h ( x ) : return x [ 0 ] // k ** stage % k return stage def h ( x ) : return x [ 0 ] // k ** stage % k return h
func , part , is last if isinstance ( part , iterator ) : try : , part = peek ( part ) except stop iteration : if not is last : return no result return func ( part ) elif not is last and len ( part ) == 0 : return no result else : return func ( part , part , is last if isinstance ( part , iterator ) : try : , part = peek ( part ) except stop iteration : if not is last : return no result return func ( part ) elif not is last and len ( part ) == 0 : return no result else : return func ( part )
func , parts , is last parts2 = ( p for p in parts if p is not no result ) return empty safe apply ( func , parts2 , is last , parts , is last parts2 = ( p for p in parts if p is not no result ) return empty safe apply ( func , parts2 , is last )
x , state data , prob random state = random ( state data ) for i in x : if random state . random ( ) < prob : yield i
n , random state = none if not isinstance ( random state , random ) : random state = random ( random state ) maxuint32 = 1 << 32 return [ tuple ( random state . randint ( 0 , maxuint32 ) for i in range ( 624 ) ) for i in range ( n ) ]
seq , n if not isinstance ( seq , ( list , tuple ) ) : seq = list ( seq ) part = len ( seq ) / n l = [ seq [ int ( part * i ) : int ( part * ( i + 1 ) ) ] for i in range ( n 1 ) ] l . append ( seq [ int ( part * ( n 1 ) ) : ] ) return l
a , b if hasattr ( a , " compute " ) : a = a . compute ( scheduler = " sync " ) if hasattr ( b , " compute " ) : b = b . compute ( scheduler = " sync " ) assert a == b if hasattr ( a , " compute " ) : a = a . compute ( scheduler = " sync " ) if hasattr ( b , " compute " ) : b = b . compute ( scheduler = " sync " ) assert a == b
fo c = fo . read ( 1 ) b = ord ( c ) n = b & 0x7 f shift = 7 while ( b & 0x80 ) != 0 : b = ord ( fo . read ( 1 ) ) n |= ( b & 0x7 f ) << shift shift += 7 return ( n >> 1 ) ^ ( n & 1 )
fo size = read long ( fo ) return fo . read ( size )
fobj , off , l , head import fastavro from dask . bytes . core import read block with fobj as f : chunk = read block ( f , off , l , head [ " sync " ] ) head bytes = head [ " head bytes " ] if not chunk . startswith ( magic ) : chunk = head bytes + chunk i = io . bytes io ( chunk ) return list ( fastavro . iter avro ( i ) )
fo import fastavro with fo as f : return list ( fastavro . iter avro ( f ) )
part , f , schema , codec , sync interval , metadata import fastavro with f as f : fastavro . writer ( f , schema , part , codec , sync interval , metadata )
block , encoding , errors text = block . decode ( encoding , errors ) lines = io . string io ( text ) return list ( lines k , encoding , errors text = block . decode ( encoding , errors ) lines = io . string io ( text ) return list ( lines )
x return x % 2 == turn x % 2 == 0
x return x % 2 == turn x % 2 == 1
def assert b . name == " x " assert b . npartitions == assert b . name == " x " assert b . npartitions == 3
def f = lambda x : x % 2 == 0 c = b . remove ( f ) assert list ( c ) == [ 1 , 3 ] * 3 assert c . name == b . remove ( f ) . namf = lambda x : x % 2 == 0 c = b . remove ( f ) assert list ( c ) == [ 1 , 3 ] * 3 assert c . name == b . remove ( f ) . name
def assert sorted ( list ( b ) ) == sorted ( l ) assert sorted ( list ( b . map ( inc ) ) ) == sorted ( list ( range ( 1 , 6 ) ) * 3 assert sorted ( list ( b ) ) == sorted ( l ) assert sorted ( list ( b . map ( inc ) ) ) == sorted ( list ( range ( 1 , 6 ) ) * 3 )
func assert str ( b . npartitions ) in func ( b ) assert b . name [ : 5 ] in func ( b assert str ( b . npartitions ) in func ( b ) assert b . name [ : 5 ] in func ( b )
def def binop ( tot , x ) : tot . add ( x ) return tot c = b . fold ( binop , combine = set . union , initial = set ( ) , out type = bag ) assert isinstance ( c , bag ) assert eq ( c , list ( set ( range ( 5 ) ) ) def binop ( tot , x ) : tot . add ( x ) return tot c = b . fold ( binop , combine = set . union , initial = set ( ) , out type = bag ) assert isinstance ( c , bag ) assert eq ( c , list ( set ( range ( 5 ) ) ) )
def b = db . from sequence ( [ ( 1 , 10 ) , ( 2 , 9 ) , ( 3 , 8 ) ] , npartitions = 2 ) assert list ( b . topk ( 2 , key = lambda a , b : b ) ) == [ ( 1 , 10 ) , ( 2 , 9 ) b = db . from sequence ( [ ( 1 , 10 ) , ( 2 , 9 ) , ( 3 , 8 ) ] , npartitions = 2 ) assert list ( b . topk ( 2 , key = lambda a , b : b ) ) == [ ( 1 , 10 ) , ( 2 , 9 ) ]
def assert list ( b . map ( lambda x : x + 1 ) ) == list ( b . map ( inc ) assert list ( b . map ( lambda x : x + 1 ) ) == list ( b . map ( inc ) )
def assert eq ( b . std ( ) , math . sqrt ( 2 . 0 ) ) assert float ( b . std ( ) ) == math . sqrt ( 2 . 0 assert eq ( b . std ( ) , math . sqrt ( 2 . 0 ) ) assert float ( b . std ( ) ) == math . sqrt ( 2 . 0 )
def assert eq ( b . var ( ) , 2 . 0 ) assert float ( b . var ( ) ) == 2 . assert eq ( b . var ( ) , 2 . 0 ) assert float ( b . var ( ) ) == 2 . 0
def a = db . from sequence ( range ( 50 ) , npartitions = 5 ) assert list ( a . random sample ( 0 . 5 ) ) != list ( a . random sample ( 0 . 5 ) ) assert a . random sample ( 0 . 5 ) . name != a . random sample ( 0 . 5 ) . name
def a = db . from sequence ( range ( 50 ) , npartitions = 5 ) b = a . random sample ( 0 . 5 , 1234 ) c = a . random sample ( 0 . 5 , 1234 ) assert list ( b ) == list ( c )
def assert list ( b . take ( 2 ) ) == [ 0 , 1 ] assert b . take ( 2 ) == ( 0 , 1 ) assert isinstance ( b . take ( 2 , compute = false ) , bag assert list ( b . take ( 2 ) ) == [ 0 , 1 ] assert b . take ( 2 ) == ( 0 , 1 ) assert isinstance ( b . take ( 2 , compute = false ) , bag )
def from dask . bag . core import map assert isinstance ( map ( lambda x : x , [ 1 , 2 , 3 ] ) , iterator from dask . bag . core import map assert isinstance ( map ( lambda x : x , [ 1 , 2 , 3 ] ) , iterator )
def assert isinstance ( dict ( b . frequencies ( ) ) , dict assert isinstance ( dict ( b . frequencies ( ) ) , dict )
def b = db . from sequence ( [ 1 , 2 , 3 , 4 , 5 ] , npartitions = 3 ) assert len ( b . dask ) == 3 assert set ( b ) == set ( [ 1 , 2 , 3 , 4 , 5 ] b = db . from sequence ( [ 1 , 2 , 3 , 4 , 5 ] , npartitions = 3 ) assert len ( b . dask ) == 3 assert set ( b ) == set ( [ 1 , 2 , 3 , 4 , 5 ] )
def l = list ( range ( 1001 ) ) b = db . from sequence ( l ) assert set ( b ) == set ( l l = list ( range ( 1001 ) ) b = db . from sequence ( l ) assert set ( b ) == set ( l )
def b = db . from sequence ( [ ] ) assert b . npartitions == 1 df = b . to dataframe ( meta = { " a " : " int " } ) . compute ( ) assert df . empty , " data frame is not empty "b = db . from sequence ( [ ] ) assert b . npartitions == 1 df = b . to dataframe ( meta = { " a " : " int " } ) . compute ( ) assert df . empty , " data frame is not empty "
def b = db . from sequence ( [ [ 1 ] , [ 2 , 3 ] ] ) assert list ( b . flatten ( ) ) == [ 1 , 2 , 3 ] assert b . flatten ( ) . name == b . flatten ( ) . namb = db . from sequence ( [ [ 1 ] , [ 2 , 3 ] ] ) assert list ( b . flatten ( ) ) == [ 1 , 2 , 3 ] assert b . flatten ( ) . name == b . flatten ( ) . name
def a = db . from sequence ( [ 1 , 2 ] ) b = db . from sequence ( [ 4 , 5 ] ) result = db . concat ( [ a . map ( inc ) , b ] ) assert list ( result ) == [ 2 , 3 , 4 , 5 a = db . from sequence ( [ 1 , 2 ] ) b = db . from sequence ( [ 4 , 5 ] ) result = db . concat ( [ a . map ( inc ) , b ] ) assert list ( result ) == [ 2 , 3 , 4 , 5 ]
def c = b . map ( lambda x : x + 1 ) d = bag ( * c . args ) assert list ( c ) == list ( d ) assert c . npartitions == d . npartitionc = b . map ( lambda x : x + 1 ) d = bag ( * c . args ) assert list ( c ) == list ( d ) assert c . npartitions == d . npartitions
def b = db . from sequence ( [ u " alice smith " , u " bob jones " , " charlie smith " ] , npartitions = 2 ) assert list ( b . str . lower ( ) ) == [ " alice smith " , " bob jones " , " charlie smith " b = db . from sequence ( [ u " alice smith " , u " bob jones " , " charlie smith " ] , npartitions = 2 ) assert list ( b . str . lower ( ) ) == [ " alice smith " , " bob jones " , " charlie smith " ]
def b = db . from sequence ( [ 1 , 2 , 3 ] ) result = b . map ( lambda x : x + 1 ) . compute ( ) assert not isinstance ( result , iterator b = db . from sequence ( [ 1 , 2 , 3 ] ) result = b . map ( lambda x : x + 1 ) . compute ( ) assert not isinstance ( result , iterator )
self , key , default = none return self . map ( lambda d : d . get ( key , default ) , key , default = none return self . map ( lambda d : d . get ( key , default ) )
self , key , value def setter ( d ) : d [ key ] = value return d return self . map ( setter , key , value def setter ( d ) : d [ key ] = value return d return self . map ( setter )
def x = db . from sequence ( [ 1 , 2 , 3 ] ) . map ( lambda a : a + 1 ) x . compute ( bogus keyword = 10 x = db . from sequence ( [ 1 , 2 , 3 ] ) . map ( lambda a : a + 1 ) x . compute ( bogus keyword = 10 )
def for npartitions in [ 1 , 7 , 10 , 28 ] : b = db . range ( 100 , npartitions = npartitions ) assert len ( b . dask ) == npartitions assert b . npartitions == npartitions assert list ( b ) == list ( range ( 100 ) for npartitions in [ 1 , 7 , 10 , 28 ] : b = db . range ( 100 , npartitions = npartitions ) assert len ( b . dask ) == npartitions assert b . npartitions == npartitions assert list ( b ) == list ( range ( 100 ) )
size , npartitions , groups func = lambda x : x % groups b = db . range ( size , npartitions = npartitions ) . groupby ( func , shuffle = " tasks " ) result = b . compute ( scheduler = " sync " ) assert dict ( result ) == groupby ( func , range ( size ) , npartitions , groups func = lambda x : x % groups b = db . range ( size , npartitions = npartitions ) . groupby ( func , shuffle = " tasks " ) result = b . compute ( scheduler = " sync " ) assert dict ( result ) == groupby ( func , range ( size ) )
def func = lambda x : x % 10 b = db . range ( 20 , npartitions = 5 ) . groupby ( func , shuffle = " tasks " , max branch = 2 ) result = b . compute ( scheduler = " sync " ) assert dict ( result ) == groupby ( func , range ( 20 ) func = lambda x : x % 10 b = db . range ( 20 , npartitions = 5 ) . groupby ( func , shuffle = " tasks " , max branch = 2 ) result = b . compute ( scheduler = " sync " ) assert dict ( result ) == groupby ( func , range ( 20 ) )
def b = db . from sequence ( range ( 10 ) , npartitions = 100 ) assert eq ( b . filter ( lambda x : x % 2 == 0 ) . max ( ) , 8 ) assert eq ( b . filter ( lambda x : x % 2 == 0 ) . min ( ) , 0 b = db . from sequence ( range ( 10 ) , npartitions = 100 ) assert eq ( b . filter ( lambda x : x % 2 == 0 ) . max ( ) , 8 ) assert eq ( b . filter ( lambda x : x % 2 == 0 ) . min ( ) , 0 )
def b = db . from sequence ( [ strict real ( x ) for x in range ( 10 ) ] , partition size = 2 ) assert eq ( b . fold ( max , max ) , strict real ( 9 ) b = db . from sequence ( [ strict real ( x ) for x in range ( 10 ) ] , partition size = 2 ) assert eq ( b . fold ( max , max ) , strict real ( 9 ) )
def b = db . from sequence ( [ { " a " : 1 } ] ) . groupby ( " a " ) result = b . compute ( scheduler = " sync " ) assert dict ( result ) == { 1 : [ { " a " : 1 } ] b = db . from sequence ( [ { " a " : 1 } ] ) . groupby ( " a " ) result = b . compute ( scheduler = " sync " ) assert dict ( result ) == { 1 : [ { " a " : 1 } ] }
def b = db . range ( 10 , npartitions = 4 ) c = b . groupby ( lambda x : x % 3 ) assert valmap ( len , dict ( c ) ) == valmap ( len , dict ( c ) b = db . range ( 10 , npartitions = 4 ) c = b . groupby ( lambda x : x % 3 ) assert valmap ( len , dict ( c ) ) == valmap ( len , dict ( c ) )
def dsk = { " x " : 1 } assert get ( dsk , " x " ) == dsk = { " x " : 1 } assert get ( dsk , " x " ) == 1
x raise value error ( ise value error ( )
def dsk = { " x " : 1 , " y " : ( bad , " x " ) } pytest . raises ( value error , lambda : get ( dsk , " y " ) dsk = { " x " : 1 , " y " : ( bad , " x " ) } pytest . raises ( value error , lambda : get ( dsk , " y " ) )
def with thread pool ( ) as pool : with dask . config . set ( pool = pool ) : assert get ( { " x " : ( inc , 1 ) } , " x " ) == 2 assert get ( { " x " : ( inc , 1 ) } , " x " ) == with thread pool ( ) as pool : with dask . config . set ( pool = pool ) : assert get ( { " x " : ( inc , 1 ) } , " x " ) == 2 assert get ( { " x " : ( inc , 1 ) } , " x " ) == 2
def pytest . importorskip ( " mimesis " ) b = dask . datasets . make people ( ) assert b . take ( 5 ) assert b . take ( 3 ) == b . take ( 3 pytest . importorskip ( " mimesis " ) b = dask . datasets . make people ( ) assert b . take ( 5 ) assert b . take ( 3 ) == b . take ( 3 )
def pytest . importorskip ( " mimesis " ) b = dask . datasets . make people ( npartitions = 2 , records per partition = 10 ) assert b . count ( ) . compute ( ) == 2pytest . importorskip ( " mimesis " ) b = dask . datasets . make people ( npartitions = 2 , records per partition = 10 ) assert b . count ( ) . compute ( ) == 20
def try : import mimesis # noqa: f401 except import error : with pytest . raises ( exception ) as info : dask . datasets . make people ( ) assert " pip install mimesis " in str ( info . value try : import mimesis # noqa: f401 except import error : with pytest . raises ( exception ) as info : dask . datasets . make people ( ) assert " pip install mimesis " in str ( info . value )
def pytest . importorskip ( " mimesis " ) b = dask . datasets . make people ( seed = 123 ) assert b . take ( 1 ) [ 0 ] [ " name " ] == ( " leandro " , " orr " pytest . importorskip ( " mimesis " ) b = dask . datasets . make people ( seed = 123 ) assert b . take ( 1 ) [ 0 ] [ " name " ] == ( " leandro " , " orr " )
def from dask . distributed import clienfrom dask . distributed import client
loop from . . dataframe . io . tests . test hdf import test to hdf with cluster ( ) as ( s , [ a , b ] ) : with distributed . client ( s [ " address " ] , loop = loop ) : test to hdf ( from . . dataframe . io . tests . test hdf import test to hdf with cluster ( ) as ( s , [ a , b ] ) : with distributed . client ( s [ " address " ] , loop = loop ) : test to hdf ( )
npartitions , loop from . . dataframe . io . tests . test hdf import test to hdf schedulers with cluster ( ) as ( s , [ a , b ] ) : with distributed . client ( s [ " address " ] , loop = loop ) : test to hdf schedulers ( none , npartitions titions , loop from . . dataframe . io . tests . test hdf import test to hdf schedulers with cluster ( ) as ( s , [ a , b ] ) : with distributed . client ( s [ " address " ] , loop = loop ) : test to hdf schedulers ( none , npartitions )
abcde a , b , c , d , e = abcde dsk = { a : 1 , b : ( f , a ) , c : ( f , b ) , d : 1 , e : ( f , d ) } o = order ( dsk ) assert o [ a ] < o [ d ] assert o [ b ] < o [ d ]
abcde dsk = dict ( ( " x%s " % ( i + 1 ) , ( inc , " x%s " % i ) ) for i in range ( 10000 ) ) dependencies , dependents = get deps ( dsk ) ndependencies ( dependencies , dependents e dsk = dict ( ( " x%s " % ( i + 1 ) , ( inc , " x%s " % i ) ) for i in range ( 10000 ) ) dependencies , dependents = get deps ( dsk ) ndependencies ( dependencies , dependents )
abcde order ( { " x " : ( inc , 1 ) , ( " y " , 0 ) : ( inc , 2 ) , " z " : ( add , " x " , ( " y " , 0 ) ) } e order ( { " x " : ( inc , 1 ) , ( " y " , 0 ) : ( inc , 2 ) , " z " : ( add , " x " , ( " y " , 0 ) ) } )
abcde r a , b , c , d , e = abcde dsk = { c : ( f , ) , d : ( f , c ) , e : ( f , c ) , b : ( f , c ) , a : ( f , b ) } o = order ( dsk ) assert o [ d ] < o [ b ] assert o [ e ] < o [ b ]
def dsk = { ( " a " , 1 ) : ( f , ) , ( " a " , 2 ) : ( f , ) , ( " a " , 3 ) : ( f , ) } o = order ( dsk ) assert o == { ( " a " , 1 ) : 0 , ( " a " , 2 ) : 1 , ( " a " , 3 ) : 2 }
def dsk = { ( " a " , 1 ) : ( f , " b " ) , ( " a " , 2 ) : ( f , " b " ) , ( " a " , 3 ) : ( f , " b " ) , " b " : ( f , ) } o = order ( dsk ) assert o == { " b " : 0 , ( " a " , 1 ) : 1 , ( " a " , 2 ) : 2 , ( " a " , 3 ) : 3 }
line m = label re . match ( line ) if m : return m . group ( 1 m = label re . match ( line ) if m : return m . group ( 1 )
line m = label re . match ( line ) if m : return m . group ( 2 m = label re . match ( line ) if m : return m . group ( 2 )
def g = to graphviz ( { " x " : 1 , " y " : " x " } ) labels = list ( filter ( none , map ( get label , g . body ) ) ) assert len ( labels ) == 2 assert len ( g . body ) len ( labels ) == g = to graphviz ( { " x " : 1 , " y " : " x " } ) labels = list ( filter ( none , map ( get label , g . body ) ) ) assert len ( labels ) == 2 assert len ( g . body ) len ( labels ) == 1
tmpdir , format , typ before = tmpdir . listdir ( ) result = dot graph ( dsk , filename = none , format = format ) after = tmpdir . listdir ( ) assert before == after assert isinstance ( result , typ ir , format , typ before = tmpdir . listdir ( ) result = dot graph ( dsk , filename = none , format = format ) after = tmpdir . listdir ( ) assert before == after assert isinstance ( result , typ )
filename , format , target , expected result type result = dot graph ( dsk , filename = filename , format = format ) assert os . path . isfile ( target ) assert isinstance ( result , expected result type ) ensure not exists ( target name , format , target , expected result type result = dot graph ( dsk , filename = filename , format = format ) assert os . path . isfile ( target ) assert isinstance ( result , expected result type ) ensure not exists ( target )
def def f ( x , y = true ) : return x + y x = delayed ( f ) ( 1 , y = 2 ) label = task label ( x . dask [ x . key ] ) assert " f " in label assert " apply " not in labedef f ( x , y = true ) : return x + y x = delayed ( f ) ( 1 , y = 2 ) label = task label ( x . dask [ x . key ] ) assert " f " in label assert " apply " not in label
x return x * turn x * 2
args , ** kwargs rv1 = fuse linear ( * args , ** kwargs ) if kwargs . get ( " rename keys " ) is not false : return rv1 rv2 = fuse ( * args , ** kwargs ) assert rv1 == rv2 return rv1
dsk return dsk , { k : get dependencies ( dsk , k ) for k in dsk return dsk , { k : get dependencies ( dsk , k ) for k in dsk }
def dsk = { " x " : ( inc , " y " ) , " y " : 1 } result = inline functions ( dsk , [ ] , fast functions = set ( [ inc ] ) ) assert result == dsdsk = { " x " : ( inc , " y " ) , " y " : 1 } result = inline functions ( dsk , [ ] , fast functions = set ( [ inc ] ) ) assert result == dsk
a , b , c = 2 return a + b + b , c = 2 return a + b + c
def raise value error ( " 12345 " raise value error ( " 12345 " )
def dsk = { " x " : ( make bad result , ) } try : get ( dsk , " x " ) except exception as e : # can ' t use type because pickle / c pickle distinction assert type ( e ) . name in ( " pickling error " , " attribute error " dsk = { " x " : ( make bad result , ) } try : get ( dsk , " x " ) except exception as e : # can ' t use type because pickle / c pickle distinction assert type ( e ) . name in ( " pickling error " , " attribute error " )
def with multiprocessing . pool ( ) as pool : with dask . config . set ( pool = pool ) : assert get ( { " x " : ( inc , 1 ) } , " x " ) == 2 assert get ( { " x " : ( inc , 1 ) } , " x " ) == with multiprocessing . pool ( ) as pool : with dask . config . set ( pool = pool ) : assert get ( { " x " : ( inc , 1 ) } , " x " ) == 2 assert get ( { " x " : ( inc , 1 ) } , " x " ) == 2
def with dask . config . set ( func dumps = pickle . dumps , func loads = pickle . loads ) : assert get ( { " x " : 1 , " y " : ( add , " x " , 2 ) } , " y " ) == with dask . config . set ( func dumps = pickle . dumps , func loads = pickle . loads ) : assert get ( { " x " : 1 , " y " : ( add , " x " , 2 ) } , " y " ) == 3
def d = { " x " : 1 , " y " : ( inc , " x " ) , " z " : ( add , 10 , " y " ) } assert get ( d , [ " y " , " z " ] ) == ( 2 , 12 d = { " x " : 1 , " y " : ( inc , " x " ) , " z " : ( add , 10 , " y " ) } assert get ( d , [ " y " , " z " ] ) == ( 2 , 12 )
@ assert get ( { " x " : ( inc , 1 ) } , " x " ) == 2 with pytest . warns ( user warning ) : with dask . config . set ( { " multiprocessing . context " : " forkserver " } ) : assert get ( { " x " : ( inc , 1 ) } , " x " ) == 2
@ assert get context ( ) is multiprocessing with pytest . warns ( user warning ) : with dask . config . set ( { " multiprocessing . context " : " forkserver " } ) : assert get context ( ) is multiprocessing
a , b return all ( a . get ( k ) == v for k , v in b . items ( ) )
def assert istask ( ( inc , 1 ) ) assert not istask ( 1 ) assert not istask ( ( 1 , 2 ) ) f = namedtuple ( " f " , [ " x " , " y " ] ) assert not istask ( f ( sum , 2 ) assert istask ( ( inc , 1 ) ) assert not istask ( 1 ) assert not istask ( ( 1 , 2 ) ) f = namedtuple ( " f " , [ " x " , " y " ] ) assert not istask ( f ( sum , 2 ) )
def dsk = { " x " : ( inc , ) } assert get dependencies ( dsk , " x " ) == set ( ) assert get dependencies ( dsk , " x " , as list = true ) == [ dsk = { " x " : ( inc , ) } assert get dependencies ( dsk , " x " ) == set ( ) assert get dependencies ( dsk , " x " , as list = true ) == [ ]
def with pytest . raises ( value error ) : get dependencies ( { } with pytest . raises ( value error ) : get dependencies ( { } )
def assert list ( flatten ( ( ) ) ) == [ ] assert list ( flatten ( " foo " ) ) == [ " foo " assert list ( flatten ( ( ) ) ) == [ ] assert list ( flatten ( " foo " ) ) == [ " foo " ]
def a = mutate on eq ( ) subs ( a , " x " , 1 ) assert a . hit eq == 0 subs ( ( add , a , " x " ) , " x " , 1 ) assert a . hit eq == a = mutate on eq ( ) subs ( a , " x " , 1 ) assert a . hit eq == 0 subs ( ( add , a , " x " ) , " x " , 1 ) assert a . hit eq == 0
def l = literal ( ( add , 1 , 2 ) ) assert pickle . loads ( pickle . dumps ( l ) ) . data == ( add , 1 , 2 l = literal ( ( add , 1 , 2 ) ) assert pickle . loads ( pickle . dumps ( l ) ) . data == ( add , 1 , 2 )
def assert sizeof ( 1 ) == getsizeof ( 1 assert sizeof ( 1 ) == getsizeof ( 1 )
def assert funcname ( sizeof ) == " sizeof "assert funcname ( sizeof ) == " sizeof "
def assert sizeof ( [ 1 , 2 , [ 3 ] ] ) > ( getsizeof ( 3 ) * 3 + getsizeof ( [ ] ) assert sizeof ( [ 1 , 2 , [ 3 ] ] ) > ( getsizeof ( 3 ) * 3 + getsizeof ( [ ] ) )
def np = pytest . importorskip ( " numpy " ) assert 8000 <= sizeof ( np . empty ( 1000 , dtype = " f8 " ) ) <= 9000 dt = np . dtype ( " f8 " ) assert sizeof ( dt ) == sys . getsizeof ( dt np = pytest . importorskip ( " numpy " ) assert 8000 <= sizeof ( np . empty ( 1000 , dtype = " f8 " ) ) <= 9000 dt = np . dtype ( " f8 " ) assert sizeof ( dt ) == sys . getsizeof ( dt )
def return " foo "return " foo "
def return " bar "return " bar "
def a = delayed ( 2 + 1j ) assert a . real . key == a . real . key assert a . real . compute ( ) == 2 assert a . imag . compute ( ) == 1 assert ( a . real + a . imag ) . compute ( ) == a = delayed ( 2 + 1j ) assert a . real . key == a . real . key assert a . real . compute ( ) == 2 assert a . imag . compute ( ) == 1 assert ( a . real + a . imag ) . compute ( ) == 3
def a = delayed ( [ 1 , 2 , 3 ] ) o = a . index ( 1 ) assert getattr not in set ( v [ 0 ] for v in o . dask graph ( ) . values ( ) a = delayed ( [ 1 , 2 , 3 ] ) o = a . index ( 1 ) assert getattr not in set ( v [ 0 ] for v in o . dask graph ( ) . values ( ) )
def np = pytest . importorskip ( " numpy " ) x = delayed ( 1 ) with pytest . raises ( type error ) : np . dtype ( x ) assert delayed ( np . array ( [ 1 ] , dtype = " f8 " ) ) . dtype . compute ( ) == np . dtype ( " f8 " np = pytest . importorskip ( " numpy " ) x = delayed ( 1 ) with pytest . raises ( type error ) : np . dtype ( x ) assert delayed ( np . array ( [ 1 ] , dtype = " f8 " ) ) . dtype . compute ( ) == np . dtype ( " f8 " )
def a = delayed ( [ 1 , 2 , 3 ] ) res = a [ 0 ] + a [ 0 ] assert a [ 0 ] . key in res . dask assert a . key in res . dask assert len ( res . dask ) == a = delayed ( [ 1 , 2 , 3 ] ) res = a [ 0 ] + a [ 0 ] assert a [ 0 ] . key in res . dask assert a . key in res . dask assert len ( res . dask ) == 3
def a = delayed ( 1 ) b = a + 1 lit = ( a , b , 3 ) assert delayed ( lit ) . key != delayed ( lit ) . key assert delayed ( lit , pure = true ) . key == delayed ( lit , pure = true ) . kea = delayed ( 1 ) b = a + 1 lit = ( a , b , 3 ) assert delayed ( lit ) . key != delayed ( lit ) . key assert delayed ( lit , pure = true ) . key == delayed ( lit , pure = true ) . key
def a = delayed ( 1 ) b = delayed ( 2 ) c = delayed ( max ) ( [ [ a , 10 ] , [ b , 20 ] ] , key = lambda x : x [ 0 ] ) [ 1 ] assert c . compute ( ) == 2a = delayed ( 1 ) b = delayed ( 2 ) c = delayed ( max ) ( [ [ a , 10 ] , [ b , 20 ] ] , key = lambda x : x [ 0 ] ) [ 1 ] assert c . compute ( ) == 20
def x = delayed ( 1 ) + 2 x . compute ( bogus keyword = 10 x = delayed ( 1 ) + 2 x . compute ( bogus keyword = 10 )
def delayed ( bytes . decode ) ( b " " delayed ( bytes . decode ) ( b " " )
def f = delayed ( add , pure = true ) v = f ( 1 , 2 ) assert v . dask == { v . key : ( add , 1 , 2 ) } assert f . dask == { f . key : add } assert f . compute ( ) == adf = delayed ( add , pure = true ) v = f ( 1 , 2 ) assert v . dask == { v . key : ( add , 1 , 2 ) } assert f . dask == { f . key : add } assert f . compute ( ) == add
def f = delayed ( add , pure = true ) assert f ( 1 , 2 , dask key name = " foo " ) . key == " foo "f = delayed ( add , pure = true ) assert f ( 1 , 2 , dask key name = " foo " ) . key == " foo "
def assert ( delayed ( partial ( add , 10 ) , pure = true ) ( 2 ) . key != delayed ( partial ( add , 20 ) , pure = true ) ( 2 ) . key assert ( delayed ( partial ( add , 10 ) , pure = true ) ( 2 ) . key != delayed ( partial ( add , 20 ) , pure = true ) ( 2 ) . key )
def x = delayed ( 123 ) assert isinstance ( x . a , delayed ) assert isinstance ( x . a . b , delayed ) assert isinstance ( x . a . b . c , delayed x = delayed ( 123 ) assert isinstance ( x . a , delayed ) assert isinstance ( x . a . b , delayed ) assert isinstance ( x . a . b . c , delayed )
def os . environ [ " dask foo " ] = " bar " try : config = collect ( [ ] ) assert config == { " foo " : " bar " } finally : del os . environ [ " dask foo " os . environ [ " dask foo " ] = " bar " try : config = collect ( [ ] ) assert config == { " foo " : " bar " } finally : del os . environ [ " dask foo " ]
def import threading with set ( x = threading . lock ( ) ) : with set ( y = 1 ) : pasimport threading with set ( x = threading . lock ( ) ) : with set ( y = 1 ) : pass
def aliases = { " foo bar " : " foo . bar " } config = { " foo bar " : 123 } rename ( aliases , config = config ) assert config == { " foo " : { " bar " : 123 } aliases = { " foo bar " : " foo . bar " } config = { " foo bar " : 123 } rename ( aliases , config = config ) assert config == { " foo " : { " bar " : 123 } }
monkeypatch value = 3 monkeypatch . setenv ( " dask a b " , str ( value ) ) d = { } dask . config . refresh ( config = d ) assert get ( " a b " , config = d ) == value assert get ( " a b " , config = d ) == valueypatch value = 3 monkeypatch . setenv ( " dask a b " , str ( value ) ) d = { } dask . config . refresh ( config = d ) assert get ( " a b " , config = d ) == value assert get ( " a b " , config = d ) == value
key value = 123 with dask . config . set ( { key : value } ) : assert dask . config . get ( " custom key " ) == value assert dask . config . get ( " custom key " ) == valuvalue = 123 with dask . config . set ( { key : value } ) : assert dask . config . get ( " custom key " ) == value assert dask . config . get ( " custom key " ) == value
def assert dask . config . merge ( { " a " : none , " c " : 0 } , { " a " : { " b " : 1 } } ) == { " a " : { " b " : 1 } , " c " : 0 , assert dask . config . merge ( { " a " : none , " c " : 0 } , { " a " : { " b " : 1 } } ) == { " a " : { " b " : 1 } , " c " : 0 , }
x for hasher in [ none ] + hashers : h = hash buffer ( x , hasher = hasher ) assert isinstance ( h , bytes ) assert 8 <= len ( h ) < 32 assert h == hash buffer ( x , hasher = hasher r hasher in [ none ] + hashers : h = hash buffer ( x , hasher = hasher ) assert isinstance ( h , bytes ) assert 8 <= len ( h ) < 32 assert h == hash buffer ( x , hasher = hasher )
x for hasher in [ none ] + hashers : h = hash buffer hex ( x , hasher = hasher ) assert isinstance ( h , str ) assert 16 <= len ( h ) < 64 assert h == hash buffer hex ( x , hasher = hasher r hasher in [ none ] + hashers : h = hash buffer hex ( x , hasher = hasher ) assert isinstance ( h , str ) assert 16 <= len ( h ) < 64 assert h == hash buffer hex ( x , hasher = hasher )
hasher x = b " x " h = hasher ( x ) assert isinstance ( h , bytes ) assert 8 <= len ( h ) < 3er x = b " x " h = hasher ( x ) assert isinstance ( h , bytes ) assert 8 <= len ( h ) < 32
def foo = dispatch ( ) foo . register ( int , lambda a , b : a + b ) foo . register ( float , lambda a , b : a b ) assert foo ( 1 , 2 ) == 3 assert foo ( 1 . 0 , 2 . 0 ) == foo = dispatch ( ) foo . register ( int , lambda a , b : a + b ) foo . register ( float , lambda a , b : a b ) assert foo ( 1 , 2 ) == 3 assert foo ( 1 . 0 , 2 . 0 ) == 1
def example = expected = """ notes hello foo extra notes bar """ assert extra titles ( example ) == expected
def a = serializable lock ( " a " ) assert not a . locked ( ) with a : assert a . locked ( ) assert not a . locked ( a = serializable lock ( " a " ) assert not a . locked ( ) with a : assert a . locked ( ) assert not a . locked ( )
def a = serializable lock ( " a " ) assert a . acquire ( blocking = true ) assert not a . acquire ( blocking = false ) a . release ( a = serializable lock ( " a " ) assert a . acquire ( blocking = true ) assert not a . acquire ( blocking = false ) a . release ( )
def def a long function name 11111111111111111111111111111111111111111111111 ( ) : pass result = funcname ( a long function name 11111111111111111111111111111111111111111111111 ) assert " a long function name " in result assert len ( result ) < 6def a long function name 11111111111111111111111111111111111111111111111 ( ) : pass result = funcname ( a long function name 11111111111111111111111111111111111111111111111 ) assert " a long function name " in result assert len ( result ) < 60
def toolz = pytest . importorskip ( " toolz " ) @ toolz . curry def foo ( a , b , c ) : pass assert funcname ( foo ) == " foo " assert funcname ( foo ( 1 ) ) == " foo "toolz = pytest . importorskip ( " toolz " ) @ toolz . curry def foo ( a , b , c ) : pass assert funcname ( foo ) == " foo " assert funcname ( foo ( 1 ) ) == " foo "
def md = pytest . importorskip ( " multipledispatch " ) @ md . dispatch ( int , int , int ) def foo ( a , b , c ) : pass assert funcname ( foo ) == " foo " assert funcname ( functools . partial ( foo , a = 1 ) ) == " foo "md = pytest . importorskip ( " multipledispatch " ) @ md . dispatch ( int , int , int ) def foo ( a , b , c ) : pass assert funcname ( foo ) == " foo " assert funcname ( functools . partial ( foo , a = 1 ) ) == " foo "
def data = [ 1 , 2 , 3 ] g = itemgetter ( 1 ) assert g ( data ) == 2 g2 = pickle . loads ( pickle . dumps ( g ) ) assert g2 ( data ) == 2 assert g2 . index == data = [ 1 , 2 , 3 ] g = itemgetter ( 1 ) assert g ( data ) == 2 g2 = pickle . loads ( pickle . dumps ( g ) ) assert g2 ( data ) == 2 assert g2 . index == 1
def import builtins @ derived from ( builtins ) def sum ( ) : " extra docstring " pass assert " extra docstring\\ " in sum . doc assert " return the sum of " in sum . doc assert " this docstring was copied from builtins . sum " in sum . doc import builtins @ derived from ( builtins ) def sum ( ) : " extra docstring " pass assert " extra docstring\\ " in sum . doc assert " return the sum of " in sum . doc assert " this docstring was copied from builtins . sum " in sum . doc
def dsk = { " x " : 1 , " y " : " x " , " z " : ( inc , " y " ) } result = start state from dask ( dsk ) assert result [ " cache " ] == { " x " : 1 dsk = { " x " : 1 , " y " : " x " , " z " : ( inc , " y " ) } result = start state from dask ( dsk ) assert result [ " cache " ] == { " x " : 1 }
def assert start state from dask ( { " x " : ( inc , 1 ) } ) [ " ready " ] == [ " x " assert start state from dask ( { " x " : ( inc , 1 ) } ) [ " ready " ] == [ " x " ]
self self . get ( { " x " : ( inc , " y " ) , " y " : 1 } , " x " , num workers = 2 self . get ( { " x " : ( inc , " y " ) , " y " : 1 } , " x " , num workers = 2 )
def assert not callback . active with callback ( ) : assert callback . active assert not callback . activassert not callback . active with callback ( ) : assert callback . active assert not callback . active
path with ignoring ( base exception ) : return pytest . importorskip ( path ) return non with ignoring ( base exception ) : return pytest . importorskip ( path ) return none
a , b , c = 1 pas b , c = 1 pass
def a = ( 1 , 2 , 3 ) assert isinstance ( tokenize ( a ) , ( str , bytes ) a = ( 1 , 2 , 3 ) assert isinstance ( tokenize ( a ) , ( str , bytes ) )
@ assert tokenize ( np . random . random state ( 1234 ) . random sample ( 1000 ) ) == tokenize ( np . random . random state ( 1234 ) . random sample ( 1000 ) sert tokenize ( np . random . random state ( 1234 ) . random sample ( 1000 ) ) == tokenize ( np . random . random state ( 1234 ) . random sample ( 1000 ) )
@ tokenize ( np . random . random ( 7 ) . astype ( dtype = " i2 " ) kenize ( np . random . random ( 7 ) . astype ( dtype = " i2 " ) )
@ tokenize ( np . array ( [ " 2000 01 01 t12:00:00 " ] , dtype = " m8[ns] " ) kenize ( np . array ( [ " 2000 01 01 t12:00:00 " ] , dtype = " m8[ns] " ) )
@ df = pd . data frame ( { " x\\ud83d " : [ 1 , 2 , 3 ] , " y\\ud83d " : [ " 4 " , " asd\\ud83d " , none ] } , index = [ 1 , 2 , 3 ] ) tokenize ( df = pd . data frame ( { " x\\ud83d " : [ 1 , 2 , 3 ] , " y\\ud83d " : [ " 4 " , " asd\\ud83d " , none ] } , index = [ 1 , 2 , 3 ] ) tokenize ( df )
@ class no pickle ( object ) : # pickling not supported because it is a local class pass df = pd . data frame ( { " x " : [ " foo " , none , no pickle ( ) ] } ) tokenize ( df ass no pickle ( object ) : # pickling not supported because it is a local class pass df = pd . data frame ( { " x " : [ " foo " , none , no pickle ( ) ] } ) tokenize ( df )
def class foo ( object ) : def init ( self , x ) : self . x = x def repr ( self ) : return " a foo " assert tokenize ( foo ( 1 ) ) != tokenize ( foo ( 2 ) class foo ( object ) : def init ( self , x ) : self . x = x def repr ( self ) : return " a foo " assert tokenize ( foo ( 1 ) ) != tokenize ( foo ( 2 ) )
def assert tokenize ( { 1 , 2 , " x " , ( 1 , " x " ) } ) == tokenize ( { 1 , 2 , " x " , ( 1 , " x " ) } assert tokenize ( { 1 , 2 , " x " , ( 1 , " x " ) } ) == tokenize ( { 1 , 2 , " x " , ( 1 , " x " ) } )
@ a = np . array ( [ u " foo " , u " jos\\xe9 " , np . nan ] , dtype = " o " ) assert tokenize ( a ) == tokenize ( a = np . array ( [ u " foo " , u " jos\\xe9 " , np . nan ] , dtype = " o " ) assert tokenize ( a ) == tokenize ( a )
x assert tokenize ( x ) == tokenize ( x ) , sert tokenize ( x ) == tokenize ( x ) , x
@ rng = np . random . random state ( 1234 ) a = np . asmatrix ( rng . rand ( 100 ) ) b = a . copy ( ) assert tokenize ( a ) == tokenize ( b ) b [ : 10 ] = 1 assert tokenize ( a ) != tokenize ( b g = np . random . random state ( 1234 ) a = np . asmatrix ( rng . rand ( 100 ) ) b = a . copy ( ) assert tokenize ( a ) == tokenize ( b ) b [ : 10 ] = 1 assert tokenize ( a ) != tokenize ( b )
@ df = pd . data frame ( data = np . random . random ( ( 3 , 1 ) ) , columns = [ u " \u00f6 " . encode ( " utf8 " ) ] ) dd . from pandas ( df , npartitions = 4 = pd . data frame ( data = np . random . random ( ( 3 , 1 ) ) , columns = [ u " \u00f6 " . encode ( " utf8 " ) ] ) dd . from pandas ( df , npartitions = 4 )
@ df = pd . data frame ( data = np . random . random ( ( 3 , 1 ) ) , columns = [ " \\ud83d " ] ) dd . from pandas ( df , npartitions = 4 = pd . data frame ( data = np . random . random ( ( 3 , 1 ) ) , columns = [ " \\ud83d " ] ) dd . from pandas ( df , npartitions = 4 )
@ x = da . arange ( 5 , chunks = 2 ) y = 10 xx , yy = compute ( x , y ) assert ( xx == x . compute ( ) ) . all ( ) assert yy == y assert compute ( 5 ) == ( 5 , = da . arange ( 5 , chunks = 2 ) y = 10 xx , yy = compute ( x , y ) assert ( xx == x . compute ( ) ) . all ( ) assert yy == y assert compute ( 5 ) == ( 5 , )
dsk , keys dsk = dict ( dsk ) for key in dsk : if dsk [ key ] [ 0 ] == inc : dsk [ key ] = ( dec , ) + dsk [ key ] [ 1 : ] return ds , keys dsk = dict ( dsk ) for key in dsk : if dsk [ key ] [ 0 ] == inc : dsk [ key ] = ( dec , ) + dsk [ key ] [ 1 : ] return dsk
def x = dask . delayed ( inc ) ( 1 ) assert x . compute ( ) == 2 with dask . config . set ( optimizations = [ inc to dec ] ) : assert x . compute ( ) == 0 assert x . compute ( ) == x = dask . delayed ( inc ) ( 1 ) assert x . compute ( ) == 2 with dask . config . set ( optimizations = [ inc to dec ] ) : assert x . compute ( ) == 0 assert x . compute ( ) == 2
def code = """ if 1: import dask import sys print(sorted(sys . modules)) """ out = subprocess . check output ( [ sys . executable , " c " , code ] ) modules = set ( eval ( out . decode ( ) ) ) assert " dask " in modules blacklist = [ " dask . array " , " dask . dataframe " , " numpy " , " pandas " , " partd " , " s3fs " , " distributed " , ] for mod in blacklist : assert mod not in modules
def assert persist ( 1 , 2 , 3 ) == ( 1 , 2 , 3 assert persist ( 1 , 2 , 3 ) == ( 1 , 2 , 3 )
def for i in range ( 1000 ) : normalize function ( lambda x : x ) assert 50 < len ( function cache ) < 60for i in range ( 1000 ) : normalize function ( lambda x : x ) assert 50 < len ( function cache ) < 600
def x = delayed ( inc ) ( 1 ) with pytest . raises ( type error ) as info : x . compute ( get = dask . get ) assert " scheduler= " in str ( info . value x = delayed ( inc ) ( 1 ) with pytest . raises ( type error ) as info : x . compute ( get = dask . get ) assert " scheduler= " in str ( info . value )
def called = [ false ] def get ( dsk , keys , * args , ** kwargs ) : called [ 0 ] = true return dask . get ( dsk , keys ) assert delayed ( lambda : 1 ) ( ) . compute ( scheduler = get ) == 1 assert called [ 0 called = [ false ] def get ( dsk , keys , * args , ** kwargs ) : called [ 0 ] = true return dask . get ( dsk , keys ) assert delayed ( lambda : 1 ) ( ) . compute ( scheduler = get ) == 1 assert called [ 0 ]
x return x * turn x * 2
def assert args ( ( inc , 1 ) ) == ( 1 , ) assert args ( ( add , 1 , 2 ) ) == ( 1 , 2 ) assert args ( 1 ) == ( ) assert args ( [ 1 , 2 , 3 ] ) == [ 1 , 2 , 3 assert args ( ( inc , 1 ) ) == ( 1 , ) assert args ( ( add , 1 , 2 ) ) == ( 1 , 2 ) assert args ( 1 ) == ( ) assert args ( [ 1 , 2 , 3 ] ) == [ 1 , 2 , 3 ]
def assert rule1 . subs ( { " a " : 1 } ) == ( inc , 1 ) assert rule6 . subs ( { " x " : [ 1 , 2 , 3 ] } ) == [ 1 , 2 , 3 assert rule1 . subs ( { " a " : 1 } ) == ( inc , 1 ) assert rule6 . subs ( { " x " : [ 1 , 2 , 3 ] } ) == [ 1 , 2 , 3 ]
qs , digests from crick import t digest t = t digest ( ) t . merge ( * digests ) return np . array ( t . quantile ( qs / 100 . 0 ) , digests from crick import t digest t = t digest ( ) t . merge ( * digests ) return np . array ( t . quantile ( qs / 100 . 0 ) )
a , dtype = none , chunks = none a = asarray ( a , name = false ) return empty ( a . shape , dtype = ( dtype or a . dtype ) , chunks = ( chunks if chunks is not none else a . chunks ) , )
a , dtype = none , chunks = none a = asarray ( a , name = false ) return ones ( a . shape , dtype = ( dtype or a . dtype ) , chunks = ( chunks if chunks is not none else a . chunks ) , )
a , dtype = none , chunks = none a = asarray ( a , name = false ) return zeros ( a . shape , dtype = ( dtype or a . dtype ) , chunks = ( chunks if chunks is not none else a . chunks ) , )
a , fill value , dtype = none , chunks = none a = asarray ( a , name = false ) return full ( a . shape , fill value , dtype = ( dtype or a . dtype ) , chunks = ( chunks if chunks is not none else a . chunks ) , )
func , shape , dtype , offset , func kwargs def offset func ( * args , ** kwargs ) : args2 = list ( map ( add , args , offset ) ) return func ( * args2 , ** kwargs ) return np . fromfunction ( offset func , shape , dtype = dtype , ** func kwargs , shape , dtype , offset , func kwargs def offset func ( * args , ** kwargs ) : args2 = list ( map ( add , args , offset ) ) return func ( * args2 , ** kwargs ) return np . fromfunction ( offset func , shape , dtype = dtype , ** func kwargs )
array , pad width , axes pad shapes = [ list ( array . shape ) , list ( array . shape ) ] pad chunks = [ list ( array . chunks ) , list ( array . chunks ) ] for d in axes : for i in range ( 2 ) : pad shapes [ i ] [ d ] = pad width [ d ] [ i ] pad chunks [ i ] [ d ] = ( pad width [ d ] [ i ] , ) pad shapes = [ tuple ( s ) for s in pad shapes ] pad chunks = [ tuple ( c ) for c in pad chunks ] return pad shapes , pad chunks
start , stop , num , dim , step num1 = num + 1 shape = list ( start . shape ) shape [ dim ] = num shape = tuple ( shape ) dtype = np . dtype ( start . dtype ) result = np . empty ( shape , dtype = dtype ) for i in np . ndindex ( start . shape ) : j = list ( i ) j [ dim ] = slice ( none ) j = tuple ( j ) result [ j ] = np . linspace ( start [ i ] , stop , num1 , dtype = dtype ) [ 1 : ] [ : : step ] return result
s start , stop , step = s . start , s . stop , s . step if start is none : start = 0 if step is none : step = 1 if start < 0 or step < 0 or stop is not none and stop < 0 : raise not implemented error ( ) return slice ( start , stop , step )
@ import sparse concatenate lookup . register ( sparse . coo , sparse . concatenate ) tensordot lookup . register ( sparse . coo , sparse . tensordot port sparse concatenate lookup . register ( sparse . coo , sparse . concatenate ) tensordot lookup . register ( sparse . coo , sparse . tensordot )
a , b , asarray = true , lock = none return getter ( a , b , asarray = asarray , lock = lock )
a , b , asarray = true , lock = none return getter ( a , b , asarray = asarray , lock = lock )
numpy functions def decorator ( dask func ) : for numpy function in numpy functions : handled functions [ numpy function ] = dask func return dask func return decorator
chunks cumdims = [ list ( accumulate ( add , ( 0 , ) + bds [ : 1 ] ) ) for bds in chunks ] shapes = product ( * chunks ) starts = product ( * cumdims ) return [ tuple ( slice ( s , s + dim ) for s , dim in zip ( start , shape ) ) for start , shape in zip ( starts , shapes ) ]
a , b , leftfunc = none , rightfunc = none , ** kwargs if leftfunc : a = map ( leftfunc , a ) if rightfunc : b = map ( rightfunc , b ) return sum ( map ( partial ( np . dot , ** kwargs ) , a , b ) )
self return reduce ( mul , self . numblocks , 1 return reduce ( mul , self . numblocks , 1 )
self return tuple ( map ( sum , self . chunks ) return tuple ( map ( sum , self . chunks ) )
self return tuple ( max ( c ) for c in self . chunks return tuple ( max ( c ) for c in self . chunks )
self return self . meta . dtyp return self . meta . dtype
self return self . chunk return self . chunks
self , chunks msg = ( " can not set chunks directly\\ " " please use the rechunk method instead:\ " " x . rechunk({})\\ " " if trying to avoid unknown chunks , use\ " " x . compute chunk sizes() " ) raise type error ( msg . format ( chunks ) , chunks msg = ( " can not set chunks directly\\ " " please use the rechunk method instead:\ " " x . rechunk({})\\ " " if trying to avoid unknown chunks , use\ " " x . compute chunk sizes() " ) raise type error ( msg . format ( chunks ) )
self return len ( self . shape return len ( self . shape )
self return reduce ( mul , self . shape , 1 )
self return self . size * self . dtype . itemsize
self return self . dtype . itemsize
self return self . nam return self . name
self , val self . name = val self . cached keys = non , val self . name = val self . cached keys = none
self return elemwis return elemwise
self , target , ** kwargs r = store ( [ self ] , [ target ] , ** kwargs ) if kwargs . get ( " return stored " , false ) : r = r [ 0 ] return , target , ** kwargs r = store ( [ self ] , [ target ] , ** kwargs ) if kwargs . get ( " return stored " , false ) : r = r [ 0 ] return r
self , size = 500 from . svg import svg return svg ( self . chunks , size = size )
self , filename , datapath , ** kwargs return to hdf5 ( filename , datapath , self , ** kwargs )
self return index callable ( self . vindex )
self return index callable ( self . blocks )
self return self . blocks
self , other from . routines import tensordot return tensordot ( self , other , axes = ( ( self . ndim 1 , ) , ( other . ndim 2 , ) ) , other from . routines import tensordot return tensordot ( self , other , axes = ( ( self . ndim 1 , ) , ( other . ndim 2 , ) ) )
self return sel return self
self return self . transpose ( return self . transpose ( )
self , * axes from . routines import transpose if not axes : axes = none elif len ( axes ) == 1 and isinstance ( axes [ 0 ] , iterable ) : axes = axes [ 0 ] return transpose ( self , axes = axes , * axes from . routines import transpose if not axes : axes = none elif len ( axes ) == 1 and isinstance ( axes [ 0 ] , iterable ) : axes = axes [ 0 ] return transpose ( self , axes = axes )
self from . routines import ravel return ravel ( self from . routines import ravel return ravel ( self )
self , choices from . routines import choose return choose ( self , choices , choices from . routines import choose return choose ( self , choices )
self , k , axis = 1 , split every = none from . reductions import topk return topk ( self , k , axis = axis , split every = split every )
self , k , axis = 1 , split every = none from . reductions import argtopk return argtopk ( self , k , axis = axis , split every = split every )
self , axis = none , keepdims = false , split every = none , out = none from . reductions import any return any ( self , axis = axis , keepdims = keepdims , split every = split every , out = out , axis = none , keepdims = false , split every = none , out = none from . reductions import any return any ( self , axis = axis , keepdims = keepdims , split every = split every , out = out )
self , axis = none , keepdims = false , split every = none , out = none from . reductions import all return all ( self , axis = axis , keepdims = keepdims , split every = split every , out = out , axis = none , keepdims = false , split every = none , out = none from . reductions import all return all ( self , axis = axis , keepdims = keepdims , split every = split every , out = out )
self , axis = none , split every = none , out = none from . reductions import argmin return argmin ( self , axis = axis , split every = split every , out = out , axis = none , split every = none , out = none from . reductions import argmin return argmin ( self , axis = axis , split every = split every , out = out )
self , axis = none , split every = none , out = none from . reductions import argmax return argmax ( self , axis = axis , split every = split every , out = out , axis = none , split every = none , out = none from . reductions import argmax return argmax ( self , axis = axis , split every = split every , out = out )
self , axis = none , dtype = none , keepdims = false , split every = none , out = none from . reductions import sum return sum ( self , axis = axis , dtype = dtype , keepdims = keepdims , split every = split every , out = out , , axis = none , dtype = none , keepdims = false , split every = none , out = none from . reductions import sum return sum ( self , axis = axis , dtype = dtype , keepdims = keepdims , split every = split every , out = out , )
self , offset = 0 , axis1 = 0 , axis2 = 1 , dtype = none from . reductions import trace return trace ( self , offset = offset , axis1 = axis1 , axis2 = axis2 , dtype = dtype , offset = 0 , axis1 = 0 , axis2 = 1 , dtype = none from . reductions import trace return trace ( self , offset = offset , axis1 = axis1 , axis2 = axis2 , dtype = dtype )
self , axis = none , dtype = none , keepdims = false , split every = none , out = none from . reductions import prod return prod ( self , axis = axis , dtype = dtype , keepdims = keepdims , split every = split every , out = out , , axis = none , dtype = none , keepdims = false , split every = none , out = none from . reductions import prod return prod ( self , axis = axis , dtype = dtype , keepdims = keepdims , split every = split every , out = out , )
self , axis = none , dtype = none , keepdims = false , split every = none , out = none from . reductions import mean return mean ( self , axis = axis , dtype = dtype , keepdims = keepdims , split every = split every , out = out , , axis = none , dtype = none , keepdims = false , split every = none , out = none from . reductions import mean return mean ( self , axis = axis , dtype = dtype , keepdims = keepdims , split every = split every , out = out , )
self , axis = none , dtype = none , keepdims = false , ddof = 0 , split every = none , out = none from . reductions import std return std ( self , axis = axis , dtype = dtype , keepdims = keepdims , ddof = ddof , split every = split every , out = out , , axis = none , dtype = none , keepdims = false , ddof = 0 , split every = none , out = none from . reductions import std return std ( self , axis = axis , dtype = dtype , keepdims = keepdims , ddof = ddof , split every = split every , out = out , )
self , axis = none , dtype = none , keepdims = false , ddof = 0 , split every = none , out = none from . reductions import var return var ( self , axis = axis , dtype = dtype , keepdims = keepdims , ddof = ddof , split every = split every , out = out , , axis = none , dtype = none , keepdims = false , ddof = 0 , split every = none , out = none from . reductions import var return var ( self , axis = axis , dtype = dtype , keepdims = keepdims , ddof = ddof , split every = split every , out = out , )
self , order , axis = none , dtype = none , keepdims = false , ddof = 0 , split every = none , out = none from . reductions import moment return moment ( self , order , axis = axis , dtype = dtype , keepdims = keepdims , ddof = ddof , split every = split every , out = out , )
self , func , * args , ** kwargs return map blocks ( func , self , * args , ** kwargs , func , * args , ** kwargs return map blocks ( func , self , * args , ** kwargs )
self , func , depth , boundary = none , trim = true , ** kwargs from . overlap import map overlap return map overlap ( self , func , depth , boundary , trim , ** kwargs )
self , axis , dtype = none , out = none from . reductions import cumsum return cumsum ( self , axis , dtype , out = out )
self , axis , dtype = none , out = none from . reductions import cumprod return cumprod ( self , axis , dtype , out = out )
self , axis = none from . routines import squeeze return squeeze ( self , axis , axis = none from . routines import squeeze return squeeze ( self , axis )
self , chunks , threshold = none , block size limit = none from . import rechunk return rechunk ( self , chunks , threshold , block size limit )
self from . ufunc import real return real ( self from . ufunc import real return real ( self )
self from . ufunc import conj return conj ( self from . ufunc import conj return conj ( self )
self , axis1 , axis2 from . routines import swapaxes return swapaxes ( self , axis1 , axis2 , axis1 , axis2 from . routines import swapaxes return swapaxes ( self , axis1 , axis2 )
self if self . npartitions == 1 : return self . map blocks ( m . copy ) else : return array ( self . dask , self . name , self . chunks , meta = self )
self , optimize graph = true keys = self . dask keys ( ) graph = self . dask graph ( ) if optimize graph : graph = self . dask optimize ( graph , keys ) # todo , don ' t collape graph name = " delayed " + self . name graph = high level graph . from collections ( name , graph , dependencies = ( ) ) l = ndeepmap ( self . ndim , lambda k : delayed ( k , graph ) , keys ) return np . array ( l , dtype = object )
self , repeats , axis = none from . creation import repeat return repeat ( self , repeats , axis = axis , repeats , axis = none from . creation import repeat return repeat ( self , repeats , axis = axis )
self from . routines import nonzero return nonzero ( self from . routines import nonzero return nonzero ( self )
self , * args , ** kwargs return to zarr ( self , * args , ** kwargs )
self , uri , * args , ** kwargs from . tiledb io import to tiledb return to tiledb ( self , uri , * args , ** kwargs )
f i = int ( f ) if i != f : raise value error ( " could not coerce %f to integer " % f ) return = int ( f ) if i != f : raise value error ( " could not coerce %f to integer " % f ) return i
c , s if c <= s : try : return max ( f for f in factors ( s ) if c / 2 <= f <= c ) except value error : # no matching factors within factor of two return max ( 1 , int ( c ) ) else : return c // s * s
chunkset for chunks in chunkset : if len ( chunks ) == 1 : continue if len ( set ( chunks [ : 1 ] ) ) > 1 : return false if chunks [ 1 ] > chunks [ 0 ] : return false return true
x , out , index , lock , return stored , load stored result = none if return stored and not load stored : result = out if lock : lock . acquire ( ) try : if x is not none : out [ index ] = np . asanyarray ( x ) if return stored and load stored : result = out [ index ] finally : if lock : lock . release ( ) return result
x , out , index , lock , return stored return load store chunk ( x , out , index , lock , return stored , false out , index , lock , return stored return load store chunk ( x , out , index , lock , return stored , false )
out , index , lock return load store chunk ( none , out , index , lock , true , true , index , lock return load store chunk ( none , out , index , lock , true , true )
keys , dsk pre , dsk post = none if not dsk post : dsk post = { k : k for k in keys } load dsk = { ( " load " + k [ 0 ] , ) + k [ 1 : ] : ( load chunk , dsk post [ k ] ) + dsk pre [ k ] [ 3 : 1 ] for k in keys } return load dsk
arg maybe shape = getattr ( arg , " shape " , none ) shape condition = not isinstance ( maybe shape , iterable ) or any ( is dask collection ( x ) for x in maybe shape ) return ( np . isscalar ( arg ) or shape condition or isinstance ( arg , np . dtype ) or ( isinstance ( arg , np . ndarray ) and arg . ndim == 0 ) )
func , offset , * args def offset ( * args ) : args2 = list ( map ( add , args , offset ) ) return func ( * args2 ) with ignoring ( exception ) : offset . name = " offset " + func . name return offset
seq if not isinstance ( seq , ( list , tuple ) ) : return seq else : return deepfirst ( seq [ 0 ] )
a if type ( a ) is list : return tuple ( [ len ( a ) ] + list ( shapelist ( a [ 0 ] ) ) ) else : return ( )
arrays , axes if len ( axes ) != ndimlist ( arrays ) : raise value error ( " length of axes should equal depth of nested arrays " ) extradims = max ( 0 , deepfirst ( arrays ) . ndim ( max ( axes ) + 1 ) ) return concatenate3 ( transposelist ( arrays , axes , extradims = extradims ) )
a , b result = [ ] i = j = 0 n = len ( a ) + len ( b ) while i + j < n : if a [ i ] is not none : result . append ( a [ i ] ) i += 1 else : result . append ( b [ j ] ) i += 1 j += 1 return tuple ( result )
name , i , okey return ( name , i ) + tuple ( k for k in okey if k is not none )
indexes ndim = len ( indexes ) indexes = [ slice ( none , none ) if i is none else [ 0 ] for i in indexes ] x = np . empty ( ( 2 , ) * ndim ) x2 = x [ tuple ( indexes ) ] return x2 . shape . index ( 1 )
block , points points = [ p if isinstance ( p , slice ) else list ( p ) for p in points ] return block [ tuple ( points ) ]
block , axis axes = [ axis ] + list ( range ( axis ) ) + list ( range ( axis + 1 , block . ndim ) ) return block . transpose ( axes )
x1 , y1 , x2 , y2 n = len ( x1 ) lines = [ ' <line x1= " %d " y1= " %d " x2= " %d " y2= " %d " /> ' % ( x1 [ i ] , y1 [ i ] , x2 [ i ] , y2 [ i ] ) for i in range ( n ) ] lines [ 0 ] = lines [ 0 ] . replace ( " / " , ' style= " stroke width:2 " / ' ) lines [ 1 ] = lines [ 1 ] . replace ( " / " , ' style= " stroke width:2 " / ' ) return lines
chunks , sizes = none , ** kwargs return svg 2d ( ( ( 1 , ) , ) + chunks , ** kwargs ks , sizes = none , ** kwargs return svg 2d ( ( ( 1 , ) , ) + chunks , ** kwargs )
chunks , sizes cumchunks = [ np . cumsum ( ( 0 , ) + c ) for c in chunks ] points = [ x * size / x [ 1 ] for x , size in zip ( cumchunks , sizes ) ] return pointks , sizes cumchunks = [ np . cumsum ( ( 0 , ) + c ) for c in chunks ] points = [ x * size / x [ 1 ] for x , size in zip ( cumchunks , sizes ) ] return points
shape , size = 200 mx = max ( shape ) ratios = [ mx / max ( 0 . 1 , d ) for d in shape ] ratios = [ ratio response ( r ) for r in ratios ] return tuple ( size / r for r in ratios )
x if x < math . e : return x elif x <= 100 : return math . log ( x + 12 . 4 ) # f(e) == e else : return math . log ( 100 + 12 . 4 )
x , axis , depth , value chunks = list ( x . chunks ) chunks [ axis ] = ( depth , ) try : c = wrap . full like ( getattr ( x , " meta " , x ) , value , shape = tuple ( map ( sum , chunks ) ) , chunks = tuple ( chunks ) , dtype = x . dtype , ) except type error : c = wrap . full ( tuple ( map ( sum , chunks ) ) , value , chunks = tuple ( chunks ) , dtype = x . dtype ) return concatenate ( [ c , x , c ] , axis = axis )
x return x [ none , . . . turn x [ none , . . . ]
x1 , x2 , out = none , dtype = none x = np . divide ( x1 , x2 , out ) if dtype is not none : x = x . astype ( dtype ) return x
arr , indices , axis if axis is none : arr = arr . flat arr shape = ( len ( arr ) , ) # flatiter has no . shape axis = 0 else : if axis < 0 : axis = arr . ndim + axis arr shape = arr . shape return arr [ make along axis idx ( arr shape , indices , axis ) ]
self , x , f map = lambda x , ** kwargs : x , f reduce = lambda x , ** kwargs : x , f kwargs = lambda ** kwargs : kwargs , ** kwargs def f ( x , ** kwargs ) : if not self . recurse if ( x ) : return f map ( x , ** kwargs ) else : next kwargs = f kwargs ( ** kwargs ) return f reduce ( ( f ( xi , ** next kwargs ) for xi in x ) , ** kwargs ) return f ( x , ** kwargs )
self , x , index = ( ) do recurse = self . recurse if ( x ) yield index , x , do recurse if not do recurse : return for i , xi in enumerate ( x ) : # yield from . . . for v in self . walk ( xi , index + ( i , ) ) : yield v
a , fill value = none a = asanyarray ( a ) return a . map blocks ( np . ma . filled , fill value = fill value fill value = none a = asanyarray ( a ) return a . map blocks ( np . ma . filled , fill value = fill value )
a return asanyarray ( a ) . map blocks ( np . ma . masked invalid turn asanyarray ( a ) . map blocks ( np . ma . masked invalid )
x , v1 , v2 x = asanyarray ( x ) return x . map blocks ( np . ma . masked inside , v1 , v2 v1 , v2 x = asanyarray ( x ) return x . map blocks ( np . ma . masked inside , v1 , v2 )
x , v1 , v2 x = asanyarray ( x ) return x . map blocks ( np . ma . masked outside , v1 , v2 v1 , v2 x = asanyarray ( x ) return x . map blocks ( np . ma . masked outside , v1 , v2 )
a a = asanyarray ( a ) return a . map blocks ( np . ma . getdata = asanyarray ( a ) return a . map blocks ( np . ma . getdata )
a a = asanyarray ( a ) return a . map blocks ( np . ma . getmaskarray = asanyarray ( a ) return a . map blocks ( np . ma . getmaskarray )
data , mask = np . ma . nomask , ** kwargs dtype = kwargs . pop ( " masked dtype " , none ) return np . ma . masked array ( data , mask = mask , dtype = dtype , ** kwargs , mask = np . ma . nomask , ** kwargs dtype = kwargs . pop ( " masked dtype " , none ) return np . ma . masked array ( data , mask = mask , dtype = dtype , ** kwargs )
x , fill value if isinstance ( x , np . ma . masked array ) : x = x . copy ( ) np . ma . set fill value ( x , fill value = fill value ) return fill value if isinstance ( x , np . ma . masked array ) : x = x . copy ( ) np . ma . set fill value ( x , fill value = fill value ) return x
a , axis = none , weights = none , returned = false return average ( a , axis , weights , returned , is masked = true axis = none , weights = none , returned = false return average ( a , axis , weights , returned , is masked = true )
chunks , const return [ tuple ( zip ( ( const , ) * ( 1 + len ( bds ) ) , accumulate ( add , ( 0 , ) + bds ) ) ) for bds in chunks ]
cumold , cumnew return tuple ( sorted ( cumold + cumnew , key = itemgetter ( 1 ) ) )
old chunks , new chunks old to new = old to new ( old chunks , new chunks ) cross1 = product ( * old to new ) cross = chain ( tuple ( product ( * cr ) ) for cr in cross1 ) return cross
chunks return reduce ( mul , map ( len , chunks ) ks return reduce ( mul , map ( len , chunks ) )
old chunks , new chunks crossed size = reduce ( mul , ( len ( oc ) + len ( nc ) for oc , nc in zip ( old chunks , new chunks ) ) ) return crossed size
desired chunks , max width chunks = [ ] for c in desired chunks : nb divides = int ( np . ceil ( c / max width ) ) for i in range ( nb divides ) : n = c // ( nb divides i ) chunks . append ( n ) c = n assert c == 0 return tuple ( chunks )
blocks assert isinstance ( blocks , tuple ) and all ( isinstance ( x , int ) or math . isnan ( x ) for x in blocks ) return pretty blocks ( blocks )
chunks assert isinstance ( chunks , tuple ) return tuple ( format blocks ( c ) for c in chunks )
a , b def key ( k ) : if isinstance ( k , str ) : return ( k , 1 , 1 , 1 ) else : return k return sorted ( a . dask , key = key ) == sorted ( b . dask , key = key b def key ( k ) : if isinstance ( k , str ) : return ( k , 1 , 1 , 1 ) else : return k return sorted ( a . dask , key = key ) == sorted ( b . dask , key = key )
x return x . shape and 0 not in x . shapturn x . shape and 0 not in x . shape
a , b , check nan = true for aa , bb in zip ( a , b ) : if math . isnan ( aa ) or math . isnan ( bb ) : if check nan : assert math . isnan ( aa ) == math . isnan ( bb ) else : assert aa == b b , check nan = true for aa , bb in zip ( a , b ) : if math . isnan ( aa ) or math . isnan ( bb ) : if check nan : assert math . isnan ( aa ) == math . isnan ( bb ) else : assert aa == bb
wrapped , assigned = functools . wrapper assignments if all ( hasattr ( wrapped , attr ) for attr in assigned ) : return functools . wraps ( wrapped , assigned = assigned ) else : return lambda x : x
a , shape , ** kwargs try : return np . empty like ( a , shape = shape , ** kwargs ) except type error : return np . empty ( shape , ** kwargs )
a , fill value , shape , ** kwargs try : return np . full like ( a , fill value , shape = shape , ** kwargs ) except type error : return np . full ( shape , fill value , ** kwargs )
a , shape , ** kwargs try : return np . ones like ( a , shape = shape , ** kwargs ) except type error : return np . ones ( shape , ** kwargs )
a , shape , ** kwargs try : return np . zeros like ( a , shape = shape , ** kwargs ) except type error : return np . zeros ( shape , ** kwargs )
axis , ndim if isinstance ( axis , ( tuple , list ) ) : return tuple ( validate axis ( ax , ndim ) for ax in axis ) if not isinstance ( axis , numbers . integral ) : raise type error ( " axis value must be an integer , got %s " % axis ) if axis < ndim or axis >= ndim : raise axis error ( " axis %d is out of bounds for array of dimension %d " % ( axis , ndim ) ) if axis < 0 : axis += ndim return axis
it total = 0 for x in it : total previous = total total += x yield ( total previous , total otal = 0 for x in it : total previous = total total += x yield ( total previous , total )
last , new return ( last [ 1 ] , last [ 1 ] + new , new return ( last [ 1 ] , last [ 1 ] + new )
a if a . shape [ 0 ] == 0 : return np . zeros ( ( 0 , 0 ) ) , np . zeros ( ( 0 , a . shape [ 1 ] ) ) else : return np . linalg . qr ( a )
a return tsqr ( a , compute svd = true )
a , b import scipy . linalg return scipy . linalg . solve triangular ( a , b , lower = true b import scipy . linalg return scipy . linalg . solve triangular ( a , b , lower = true )
a , b , sym pos = false if sym pos : l , u = cholesky ( a ) else : p , l , u = lu ( a ) b = p . t . dot ( b ) uy = solve triangular ( l , b , lower = true ) return solve triangular ( u , uy )
a return solve ( a , eye ( a . shape [ 0 ] , chunks = a . chunks [ 0 ] [ 0 ] ) )
x x [ : : 1 ] . sort ( ) return [ : : 1 ] . sort ( ) return x
f obs , f exp = none , ddof = 0 , axis = 0 return power divergence ( f obs , f exp = f exp , ddof = ddof , axis = axis , lambda = " pearson " s , f exp = none , ddof = 0 , axis = 0 return power divergence ( f obs , f exp = f exp , ddof = ddof , axis = axis , lambda = " pearson " )
a , moment = 1 , axis = 0 , nan policy = " propagate " if nan policy != " propagate " : raise not implemented error ( " `nan policy` other than ' propagate ' have not been implemented . " ) return da . moment ( a , moment , axis = axis moment = 1 , axis = 0 , nan policy = " propagate " if nan policy != " propagate " : raise not implemented error ( " `nan policy` other than ' propagate ' have not been implemented . " ) return da . moment ( a , moment , axis = axis )
v1 , n1 , v2 , n2 df = n1 + n2 2 . 0 svar = ( ( n1 1 ) * v1 + ( n2 1 ) * v2 ) / df denom = da . sqrt ( svar * ( 1 . 0 / n1 + 1 . 0 / n2 ) ) return df , deno, n1 , v2 , n2 df = n1 + n2 2 . 0 svar = ( ( n1 1 ) * v1 + ( n2 1 ) * v2 ) / df denom = da . sqrt ( svar * ( 1 . 0 / n1 + 1 . 0 / n2 ) ) return df , denom
mean1 , mean2 , denom , df d = mean1 mean2 with np . errstate ( divide = " ignore " , invalid = " ignore " ) : t = da . divide ( d , denom ) t , prob = ttest finish ( df , t ) return ( t , prob 1 , mean2 , denom , df d = mean1 mean2 with np . errstate ( divide = " ignore " , invalid = " ignore " ) : t = da . divide ( d , denom ) t , prob = ttest finish ( df , t ) return ( t , prob )
x , axis = none if axis is none : return x . size else : return x . shape [ axis axis = none if axis is none : return x . size else : return x . shape [ axis ]
a , axis = 0 return da . sum ( a * a , axis )
a , axis = 0 s = da . sum ( a , axis ) return s * s
args , ** kwargs warnings . warn ( " the da . atop function has moved to da . blockwise " ) return blockwise ( * args , ** kwargs , ** kwargs warnings . warn ( " the da . atop function has moved to da . blockwise " ) return blockwise ( * args , ** kwargs )
func , func like , * args , ** kwargs try : return func like ( * args , ** kwargs ) except type error : return func ( * args , ** kwargs )
wrap func , func , ** kwargs func like = kwargs . pop ( " func like " , none ) if func like is none : f = partial ( wrap func , func , ** kwargs ) else : f = partial ( wrap func , func like , ** kwargs ) template = if func . doc is not none : f . doc = template % { " name " : func . name } + func . doc f . name = " blocked " + func . name return f
a , s , axes if s is none : return a . chunks chunks = list ( a . chunks ) for i , axis in enumerate ( axes ) : chunks [ axis ] = ( s [ i ] , ) return chunks
a , s , axes if s is none : s = [ a . chunks [ axis ] [ 0 ] for axis in axes ] s [ 1 ] = 2 * ( s [ 1 ] 1 ) chunks = list ( a . chunks ) for i , axis in enumerate ( axes ) : chunks [ axis ] = ( s [ i ] , ) return chunks
i , n , d r = i . copy ( ) r [ i >= ( n + 1 ) // 2 ] = n r /= n * d return n , d r = i . copy ( ) r [ i >= ( n + 1 ) // 2 ] = n r /= n * d return r
n , d = 1 . 0 , chunks = " auto " n = int ( n ) d = float ( d ) r = arange ( n , dtype = float , chunks = chunks ) return r . map blocks ( fftfreq block , dtype = float , n = n , d = d d = 1 . 0 , chunks = " auto " n = int ( n ) d = float ( d ) r = arange ( n , dtype = float , chunks = chunks ) return r . map blocks ( fftfreq block , dtype = float , n = n , d = d )
n , d = 1 . 0 , chunks = " auto " n = int ( n ) d = float ( d ) r = arange ( n // 2 + 1 , dtype = float , chunks = chunks ) r /= n * d return d = 1 . 0 , chunks = " auto " n = int ( n ) d = float ( d ) r = arange ( n // 2 + 1 , dtype = float , chunks = chunks ) r /= n * d return r
x , axes = none return fftshift helper ( x , axes = axes , inverse = false axes = none return fftshift helper ( x , axes = axes , inverse = false )
x , axes = none return fftshift helper ( x , axes = axes , inverse = true axes = none return fftshift helper ( x , axes = axes , inverse = true )
x , dtype = none , ndmin = none while ndmin is not none and x . ndim < ndmin : x = x [ none , : ] if dtype is not none and x . dtype != dtype : x = x . astype ( dtype ) return dtype = none , ndmin = none while ndmin is not none and x . ndim < ndmin : x = x [ none , : ] if dtype is not none and x . dtype != dtype : x = x . astype ( dtype ) return x
args args = [ a if is scalar for elemwise ( a ) else a . dtype for a in args ] return np . result type ( * args args = [ a if is scalar for elemwise ( a ) else a . dtype for a in args ] return np . result type ( * args )
arys new arys = [ ] for x in arys : x = asanyarray ( x ) if x . ndim == 0 : x = x [ none ] new arys . append ( x ) if len ( new arys ) == 1 : return new arys [ 0 ] else : return new ary new arys = [ ] for x in arys : x = asanyarray ( x ) if x . ndim == 0 : x = x [ none ] new arys . append ( x ) if len ( new arys ) == 1 : return new arys [ 0 ] else : return new arys
tup , allow unknown chunksizes = false tup = tuple ( atleast 2d ( x ) for x in tup ) return concatenate ( tup , axis = 0 , allow unknown chunksizes = allow unknown chunksizes , allow unknown chunksizes = false tup = tuple ( atleast 2d ( x ) for x in tup ) return concatenate ( tup , axis = 0 , allow unknown chunksizes = allow unknown chunksizes )
tup , allow unknown chunksizes = false if all ( x . ndim == 1 for x in tup ) : return concatenate ( tup , axis = 0 , allow unknown chunksizes = allow unknown chunksizes ) else : return concatenate ( tup , axis = 1 , allow unknown chunksizes = allow unknown chunksizes , allow unknown chunksizes = false if all ( x . ndim == 1 for x in tup ) : return concatenate ( tup , axis = 0 , allow unknown chunksizes = allow unknown chunksizes ) else : return concatenate ( tup , axis = 1 , allow unknown chunksizes = allow unknown chunksizes )
tup , allow unknown chunksizes = false tup = tuple ( atleast 3d ( x ) for x in tup ) return concatenate ( tup , axis = 2 , allow unknown chunksizes = allow unknown chunksizes , allow unknown chunksizes = false tup = tuple ( atleast 3d ( x ) for x in tup ) return concatenate ( tup , axis = 2 , allow unknown chunksizes = allow unknown chunksizes )
m return flip ( m , 0 turn flip ( m , 0 )
m return flip ( m , 1 turn flip ( m , 1 )
a , b return tensordot ( a , b , axes = ( ( a . ndim 1 , ) , ( b . ndim 2 , ) ) b return tensordot ( a , b , axes = ( ( a . ndim 1 , ) , ( b . ndim 2 , ) ) )
a , b return dot ( a . conj ( ) . ravel ( ) , b . ravel ( ) b return dot ( a . conj ( ) . ravel ( ) , b . ravel ( ) )
arr , func1d , func1d axis , func1d args , func1d kwargs return np . apply along axis ( func1d , func1d axis , arr , * func1d args , ** func1d kwargs , func1d , func1d axis , func1d args , func1d kwargs return np . apply along axis ( func1d , func1d axis , arr , * func1d args , ** func1d kwargs )
a , axis = none return a . max ( axis = axis ) a . min ( axis = axis axis = none return a . max ( axis = axis ) a . min ( axis = axis )
x , block id , coord , axis , array locs , grad kwargs block loc = block id [ axis ] if array locs is not none : coord = coord [ array locs [ 0 ] [ block loc ] : array locs [ 1 ] [ block loc ] ] grad = np . gradient ( x , coord , axis = axis , ** grad kwargs ) return grad
bincounts , dtype = int n = max ( map ( len , bincounts ) ) out = zeros like safe ( bincounts [ 0 ] , shape = n , dtype = dtype ) for b in bincounts : out [ : len ( b ) ] += b return ouounts , dtype = int n = max ( map ( len , bincounts ) ) out = zeros like safe ( bincounts [ 0 ] , shape = n , dtype = dtype ) for b in bincounts : out [ : len ( b ) ] += b return out
a , bins , right = false bins = np . asarray ( bins ) dtype = np . digitize ( [ 0 ] , bins , right = false ) . dtype return a . map blocks ( np . digitize , dtype = dtype , bins = bins , right = right bins , right = false bins = np . asarray ( bins ) dtype = np . digitize ( [ 0 ] , bins , right = false ) . dtype return a . map blocks ( np . digitize , dtype = dtype , bins = bins , right = right )
element , test elements , assume unique = false values = np . in1d ( element . ravel ( ) , test elements , assume unique = assume unique ) return values . reshape ( element . shape + ( 1 , ) * test elements . ndim ent , test elements , assume unique = false values = np . in1d ( element . ravel ( ) , test elements , assume unique = assume unique ) return values . reshape ( element . shape + ( 1 , ) * test elements . ndim )
array return array . shapy return array . shape
condition , arr condition = asarray ( condition ) . astype ( bool ) arr = asarray ( arr ) return compress ( condition . ravel ( ) , arr . ravel ( ) ition , arr condition = asarray ( condition ) . astype ( bool ) arr = asarray ( arr ) return compress ( condition . ravel ( ) , arr . ravel ( ) )
a , indices , axis assert isinstance ( a , np . ndarray ) assert isinstance ( indices , array ) return indices . map blocks ( lambda block : np . take ( a , block , axis ) , chunks = indices . chunks , dtype = a . dtype indices , axis assert isinstance ( a , np . ndarray ) assert isinstance ( indices , array ) return indices . map blocks ( lambda block : np . take ( a , block , axis ) , chunks = indices . chunks , dtype = a . dtype )
values import pandas as pd return elemwise ( asarray isnull , values , dtype = " bool " )
values return ~ isnull ( values )
arr1 , arr2 , rtol = 1e 5 , atol = 1e 8 , equal nan = false func = partial ( np . isclose , rtol = rtol , atol = atol , equal nan = equal nan ) return elemwise ( func , arr1 , arr2 , dtype = " bool " , arr2 , rtol = 1e 5 , atol = 1e 8 , equal nan = false func = partial ( np . isclose , rtol = rtol , atol = atol , equal nan = equal nan ) return elemwise ( func , arr1 , arr2 , dtype = " bool " )
arr1 , arr2 , rtol = 1e 5 , atol = 1e 8 , equal nan = false return isclose ( arr1 , arr2 , rtol = rtol , atol = atol , equal nan = equal nan ) . all ( , arr2 , rtol = 1e 5 , atol = 1e 8 , equal nan = false return isclose ( arr1 , arr2 , rtol = rtol , atol = atol , equal nan = equal nan ) . all ( )
a , * choices return np . choose ( a , choices * choices return np . choose ( a , choices )
a , choices return elemwise ( variadic choose , a , * choices choices return elemwise ( variadic choose , a , * choices )
v return bool ( np . count nonzero ( v ) turn bool ( np . count nonzero ( v ) )
a , axis = none return isnonzero ( asarray ( a ) ) . astype ( np . intp ) . sum ( axis = axis axis = none return isnonzero ( asarray ( a ) ) . astype ( np . intp ) . sum ( axis = axis )
a return argwhere ( asarray ( a ) . ravel ( ) ) [ : , 0 turn argwhere ( asarray ( a ) . ravel ( ) ) [ : , 0 ]
a ind = argwhere ( a ) if ind . ndim > 1 : return tuple ( ind [ : , i ] for i in range ( ind . shape [ 1 ] ) ) else : return ( ind , d = argwhere ( a ) if ind . ndim > 1 : return tuple ( ind [ : , i ] for i in range ( ind . shape [ 1 ] ) ) else : return ( ind , )
x , * condlist , ** kwargs return np . piecewise ( x , list ( condlist ) , kwargs [ " funclist " ] , * kwargs [ " func args " ] , ** kwargs [ " func kw " ] * condlist , ** kwargs return np . piecewise ( x , list ( condlist ) , kwargs [ " funclist " ] , * kwargs [ " func args " ] , ** kwargs [ " func kw " ] )
indices , func kwargs return np . stack ( np . unravel index ( indices , ** func kwargs ) ces , func kwargs return np . stack ( np . unravel index ( indices , ** func kwargs ) )
x , condlist , funclist , * args , ** kw return map blocks ( int piecewise , x , * condlist , dtype = x . dtype , name = " piecewise " , funclist = funclist , func args = args , func kw = kw condlist , funclist , * args , ** kw return map blocks ( int piecewise , x , * condlist , dtype = x . dtype , name = " piecewise " , funclist = funclist , func args = args , func kw = kw )
array , breaks , axis = 0 padded breaks = concat ( [ [ none ] , breaks , [ none ] ] ) slices = [ slice ( i , j ) for i , j in sliding window ( 2 , padded breaks ) ] preslice = ( slice ( none ) , ) * axis split array = [ array [ preslice + ( s , ) ] for s in slices ] return split array
func , nin , nout if nout > 1 : raise not implemented error ( " frompyfunc with more than one output " ) return ufunc ( da frompyfunc ( func , nin , nout ) , nin , nout if nout > 1 : raise not implemented error ( " frompyfunc with more than one output " ) return ufunc ( da frompyfunc ( func , nin , nout ) )
x , deg = 0 deg = bool ( deg ) if hasattr ( x , " elemwise " ) : return x . elemwise ( array wrap , np . angle , x , deg ) return np . angle ( x , deg = deg deg = 0 deg = bool ( deg ) if hasattr ( x , " elemwise " ) : return x . elemwise ( array wrap , np . angle , x , deg ) return np . angle ( x , deg = deg )
x , y res1 = x // y res2 = x % y return res1 , res y res1 = x // y res2 = x % y return res1 , res2
sizes , seq seq = np . asanyarray ( seq ) left = np . empty ( len ( sizes ) + 1 , dtype = int ) left [ 0 ] = 0 right = np . cumsum ( sizes , out = left [ 1 : ] ) locations = np . empty ( len ( sizes ) + 1 , dtype = int ) locations [ 0 ] = 0 locations [ 1 : ] = np . searchsorted ( seq , right ) return [ ( seq [ j : k ] l ) for j , k , l in zip ( locations [ : 1 ] , locations [ 1 : ] , left ) ]
shape , ind if isinstance ( ind , tuple ) : return tuple ( map ( posify index , shape , ind ) ) if isinstance ( ind , integral ) : if ind < 0 and not math . isnan ( shape ) : return ind + shape else : return ind if isinstance ( ind , ( np . ndarray , list ) ) and not math . isnan ( shape ) : ind = np . asanyarray ( ind ) return np . where ( ind < 0 , ind + shape , ind ) return ind
where if not where : def expand ( seq , val ) : return seq return expand else : decl = left = [ ] j = 0 for i in range ( max ( where ) + 1 ) : if i in where : left . append ( " val , " ) else : left . append ( " seq[%d] , " % j ) j += 1 right = " seq[%d:] " % j left = " " . join ( left ) decl = decl . format ( ** locals ( ) ) ns = { } exec ( compile ( decl , " <dynamic> " , " exec " ) , ns , ns ) return ns [ " expand " ]
where return expander ( tuple ( where ) )
n , index isellipsis = [ i for i , ind in enumerate ( index ) if ind is ellipsis ] if not isellipsis : return index else : loc = isellipsis [ 0 ] extra dimensions = n ( len ( index ) sum ( i is none for i in index ) 1 ) return ( index [ : loc ] + ( slice ( none , none , none ) , ) * extra dimensions + index [ loc + 1 : ] )
x , * index return x [ index * index return x [ index ]
x , index from . core import performance warning chunks1 = chunks2 = x . chunks if x . ndim > 1 : chunks1 = ( chunks1 [ 0 ] , ) index2 , index3 = make block sorted slices ( index , chunks1 ) with warnings . catch warnings ( ) : warnings . simplefilter ( " ignore " , performance warning ) return x [ index2 ] . rechunk ( chunks2 ) [ index3 ]
a , b , dtype = none key = lambda x : getattr ( x , " array priority " , float ( " inf " ) ) f = divide lookup . dispatch ( type ( builtins . max ( a , b , key = key ) ) ) return f ( a , b , dtype = dtype b , dtype = none key = lambda x : getattr ( x , " array priority " , float ( " inf " ) ) f = divide lookup . dispatch ( type ( builtins . max ( a , b , key = key ) ) ) return f ( a , b , dtype = dtype )
a , axis = none , keepdims = false , split every = none , out = none return reduction ( a , chunk . min , chunk . min , axis = axis , keepdims = keepdims , dtype = a . dtype , split every = split every , out = out , axis = none , keepdims = false , split every = none , out = none return reduction ( a , chunk . min , chunk . min , axis = axis , keepdims = keepdims , dtype = a . dtype , split every = split every , out = out , )
a , axis = none , keepdims = false , split every = none , out = none return reduction ( a , chunk . max , chunk . max , axis = axis , keepdims = keepdims , dtype = a . dtype , split every = split every , out = out , axis = none , keepdims = false , split every = none , out = none return reduction ( a , chunk . max , chunk . max , axis = axis , keepdims = keepdims , dtype = a . dtype , split every = split every , out = out , )
a , axis = none , keepdims = false , split every = none , out = none return reduction ( a , chunk . any , chunk . any , axis = axis , keepdims = keepdims , dtype = " bool " , split every = split every , out = out , axis = none , keepdims = false , split every = none , out = none return reduction ( a , chunk . any , chunk . any , axis = axis , keepdims = keepdims , dtype = " bool " , split every = split every , out = out , )
x , axis , dtype = none , out = none return cumreduction ( chunk . nancumsum , operator . add , 0 , x , axis , dtype , out = out axis , dtype = none , out = none return cumreduction ( chunk . nancumsum , operator . add , 0 , x , axis , dtype , out = out )
a , axis = none , keepdims = false , split every = none , out = none return reduction ( a , chunk . nanmin , chunk . nanmin , axis = axis , keepdims = keepdims , dtype = a . dtype , split every = split every , out = out , axis = none , keepdims = false , split every = none , out = none return reduction ( a , chunk . nanmin , chunk . nanmin , axis = axis , keepdims = keepdims , dtype = a . dtype , split every = split every , out = out , )
a , axis = none , keepdims = false , split every = none , out = none return reduction ( a , chunk . nanmax , chunk . nanmax , axis = axis , keepdims = keepdims , dtype = a . dtype , split every = split every , out = out , axis = none , keepdims = false , split every = none , out = none return reduction ( a , chunk . nanmax , chunk . nanmax , axis = axis , keepdims = keepdims , dtype = a . dtype , split every = split every , out = out , )
x , ** kwargs return chunk . sum ( ~ np . isnan ( x ) , ** kwargs )
func , argfunc , data , axis = none , ** kwargs return arg combine ( data , axis , argfunc , keepdims = false ) [ 0 , argfunc , data , axis = none , ** kwargs return arg combine ( data , axis , argfunc , keepdims = false ) [ 0 ]
func , argfunc , is nan func = false chunk = partial ( arg chunk , func , argfunc ) combine = partial ( arg combine , func , argfunc ) if is nan func : agg = partial ( nanarg agg , func , argfunc ) else : agg = partial ( arg agg , func , argfunc ) @ wraps ( argfunc ) def ( x , axis = none , split every = none , out = none ) : return arg reduction ( x , chunk , combine , agg , axis , split every = split every , out = out ) return
x , axis , ** kwargs try : return chunk . nanargmin ( x , axis , ** kwargs ) except value error : return chunk . nanargmin ( np . where ( np . isnan ( x ) , np . inf , x ) , axis , ** kwargs axis , ** kwargs try : return chunk . nanargmin ( x , axis , ** kwargs ) except value error : return chunk . nanargmin ( np . where ( np . isnan ( x ) , np . inf , x ) , axis , ** kwargs )
x , axis , ** kwargs try : return chunk . nanargmax ( x , axis , ** kwargs ) except value error : return chunk . nanargmax ( np . where ( np . isnan ( x ) , np . inf , x ) , axis , ** kwargs axis , ** kwargs try : return chunk . nanargmax ( x , axis , ** kwargs ) except value error : return chunk . nanargmax ( np . where ( np . isnan ( x ) , np . inf , x ) , axis , ** kwargs )
x , axis = none , dtype = none , out = none return cumreduction ( np . cumsum , cumsum merge , 0 , x , axis , dtype , out = out axis = none , dtype = none , out = none return cumreduction ( np . cumsum , cumsum merge , 0 , x , axis , dtype , out = out )
x , axis = none , dtype = none , out = none return cumreduction ( np . cumprod , cumprod merge , 1 , x , axis , dtype , out = out axis = none , dtype = none , out = none return cumreduction ( np . cumprod , cumprod merge , 1 , x , axis , dtype , out = out )
a , k , axis = 1 , split every = none axis = validate axis ( axis , a . ndim ) chunk combine = partial ( chunk . topk , k = k ) aggregate = partial ( chunk . topk aggregate , k = k ) return reduction ( a , chunk = chunk combine , combine = chunk combine , aggregate = aggregate , axis = axis , keepdims = true , dtype = a . dtype , split every = split every , output size = abs ( k ) , )
a , offset = 0 , axis1 = 0 , axis2 = 1 , dtype = none return diagonal ( a , offset = offset , axis1 = axis1 , axis2 = axis2 ) . sum ( 1 , dtype = dtype offset = 0 , axis1 = 0 , axis2 = 1 , dtype = none return diagonal ( a , offset = offset , axis1 = axis1 , axis2 = axis2 ) . sum ( 1 , dtype = dtype )
tiledb array schema = tiledb array . schema return list ( schema . domain . dim ( i ) . tile for i in range ( schema . ndim ) db array schema = tiledb array . schema return list ( schema . domain . dim ( i ) . tile for i in range ( schema . ndim ) )
x , axes = none if isinstance ( axes , integral ) : axes = [ axes ] * x . ndim if isinstance ( axes , dict ) : axes = [ axes . get ( i , 0 ) for i in range ( x . ndim ) ] return x [ tuple ( slice ( ax , ax if ax else none ) for ax in axes ) ]
start , stop , step , length , dtype res = np . arange ( start , stop , step , dtype ) return res [ : 1 ] if len ( res ) > length else ret , stop , step , length , dtype res = np . arange ( start , stop , step , dtype ) return res [ : 1 ] if len ( res ) > length else res
x , astype dtype = none , ** kwargs return x . astype ( astype dtype , ** kwargs astype dtype = none , ** kwargs return x . astype ( astype dtype , ** kwargs )
x , idx , offset , x size , axis idx = idx . astype ( np . int64 ) idx = np . where ( idx < 0 , idx + x size , idx ) idx = idx offset idx filter = ( idx >= 0 ) & ( idx < x . shape [ axis ] ) idx = idx [ idx filter ] return x [ tuple ( idx if i == axis else slice ( none ) for i in range ( x . ndim ) ) ]
func def ( func2 ) : if func . doc is not none : func2 . doc = skip doctest ( func . doc ) return func2 return
self , a , b , size = none , chunks = " auto " return self . wrap ( " beta " , a , b , size = size , chunks = chunks , a , b , size = none , chunks = " auto " return self . wrap ( " beta " , a , b , size = size , chunks = chunks )
self , n , p , size = none , chunks = " auto " return self . wrap ( " binomial " , n , p , size = size , chunks = chunks , n , p , size = none , chunks = " auto " return self . wrap ( " binomial " , n , p , size = size , chunks = chunks )
self , df , size = none , chunks = " auto " return self . wrap ( " chisquare " , df , size = size , chunks = chunks , df , size = none , chunks = " auto " return self . wrap ( " chisquare " , df , size = size , chunks = chunks )
self , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " exponential " , scale , size = size , chunks = chunks , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " exponential " , scale , size = size , chunks = chunks )
self , dfnum , dfden , size = none , chunks = " auto " return self . wrap ( " f " , dfnum , dfden , size = size , chunks = chunks , dfnum , dfden , size = none , chunks = " auto " return self . wrap ( " f " , dfnum , dfden , size = size , chunks = chunks )
self , shape , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " gamma " , shape , scale , size = size , chunks = chunks , shape , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " gamma " , shape , scale , size = size , chunks = chunks )
self , p , size = none , chunks = " auto " return self . wrap ( " geometric " , p , size = size , chunks = chunks , p , size = none , chunks = " auto " return self . wrap ( " geometric " , p , size = size , chunks = chunks )
self , loc = 0 . 0 , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " gumbel " , loc , scale , size = size , chunks = chunks , loc = 0 . 0 , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " gumbel " , loc , scale , size = size , chunks = chunks )
self , ngood , nbad , nsample , size = none , chunks = " auto " return self . wrap ( " hypergeometric " , ngood , nbad , nsample , size = size , chunks = chunks , ngood , nbad , nsample , size = none , chunks = " auto " return self . wrap ( " hypergeometric " , ngood , nbad , nsample , size = size , chunks = chunks )
self , loc = 0 . 0 , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " laplace " , loc , scale , size = size , chunks = chunks , loc = 0 . 0 , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " laplace " , loc , scale , size = size , chunks = chunks )
self , mean = 0 . 0 , sigma = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " lognormal " , mean , sigma , size = size , chunks = chunks , mean = 0 . 0 , sigma = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " lognormal " , mean , sigma , size = size , chunks = chunks )
self , p , size = none , chunks = " auto " return self . wrap ( " logseries " , p , size = size , chunks = chunks , p , size = none , chunks = " auto " return self . wrap ( " logseries " , p , size = size , chunks = chunks )
self , n , p , size = none , chunks = " auto " return self . wrap ( " negative binomial " , n , p , size = size , chunks = chunks , n , p , size = none , chunks = " auto " return self . wrap ( " negative binomial " , n , p , size = size , chunks = chunks )
self , df , nonc , size = none , chunks = " auto " return self . wrap ( " noncentral chisquare " , df , nonc , size = size , chunks = chunks , df , nonc , size = none , chunks = " auto " return self . wrap ( " noncentral chisquare " , df , nonc , size = size , chunks = chunks )
self , a , size = none , chunks = " auto " return self . wrap ( " pareto " , a , size = size , chunks = chunks , a , size = none , chunks = " auto " return self . wrap ( " pareto " , a , size = size , chunks = chunks )
self , x from . slicing import shuffle slice if isinstance ( x , numbers . number ) : x = arange ( x , chunks = " auto " ) index = np . arange ( len ( x ) ) self . numpy state . shuffle ( index ) return shuffle slice ( x , index , x from . slicing import shuffle slice if isinstance ( x , numbers . number ) : x = arange ( x , chunks = " auto " ) index = np . arange ( len ( x ) ) self . numpy state . shuffle ( index ) return shuffle slice ( x , index )
self , lam = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " poisson " , lam , size = size , chunks = chunks , lam = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " poisson " , lam , size = size , chunks = chunks )
self , a , size = none , chunks = " auto " return self . wrap ( " power " , a , size = size , chunks = chunks , a , size = none , chunks = " auto " return self . wrap ( " power " , a , size = size , chunks = chunks )
self , low , high = none , size = none , chunks = " auto " , dtype = " l " return self . wrap ( " randint " , low , high , size = size , chunks = chunks , dtype = dtype , low , high = none , size = none , chunks = " auto " , dtype = " l " return self . wrap ( " randint " , low , high , size = size , chunks = chunks , dtype = dtype )
self , low , high = none , size = none , chunks = " auto " return self . wrap ( " random integers " , low , high , size = size , chunks = chunks , low , high = none , size = none , chunks = " auto " return self . wrap ( " random integers " , low , high , size = size , chunks = chunks )
self , size = none , chunks = " auto " return self . wrap ( " random sample " , size = size , chunks = chunks , size = none , chunks = " auto " return self . wrap ( " random sample " , size = size , chunks = chunks )
self , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " rayleigh " , scale , size = size , chunks = chunks , scale = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " rayleigh " , scale , size = size , chunks = chunks )
self , size = none , chunks = " auto " return self . wrap ( " standard cauchy " , size = size , chunks = chunks , size = none , chunks = " auto " return self . wrap ( " standard cauchy " , size = size , chunks = chunks )
self , size = none , chunks = " auto " return self . wrap ( " standard exponential " , size = size , chunks = chunks , size = none , chunks = " auto " return self . wrap ( " standard exponential " , size = size , chunks = chunks )
self , shape , size = none , chunks = " auto " return self . wrap ( " standard gamma " , shape , size = size , chunks = chunks , shape , size = none , chunks = " auto " return self . wrap ( " standard gamma " , shape , size = size , chunks = chunks )
self , size = none , chunks = " auto " return self . wrap ( " standard normal " , size = size , chunks = chunks , size = none , chunks = " auto " return self . wrap ( " standard normal " , size = size , chunks = chunks )
self , df , size = none , chunks = " auto " return self . wrap ( " standard t " , df , size = size , chunks = chunks , df , size = none , chunks = " auto " return self . wrap ( " standard t " , df , size = size , chunks = chunks )
self , size = none , chunks = " auto " return self . wrap ( " tomaxint " , size = size , chunks = chunks , size = none , chunks = " auto " return self . wrap ( " tomaxint " , size = size , chunks = chunks )
self , left , mode , right , size = none , chunks = " auto " return self . wrap ( " triangular " , left , mode , right , size = size , chunks = chunks , left , mode , right , size = none , chunks = " auto " return self . wrap ( " triangular " , left , mode , right , size = size , chunks = chunks )
self , mu , kappa , size = none , chunks = " auto " return self . wrap ( " vonmises " , mu , kappa , size = size , chunks = chunks , mu , kappa , size = none , chunks = " auto " return self . wrap ( " vonmises " , mu , kappa , size = size , chunks = chunks )
self , mean , scale , size = none , chunks = " auto " return self . wrap ( " wald " , mean , scale , size = size , chunks = chunks , mean , scale , size = none , chunks = " auto " return self . wrap ( " wald " , mean , scale , size = size , chunks = chunks )
self , a , size = none , chunks = " auto " return self . wrap ( " weibull " , a , size = size , chunks = chunks , a , size = none , chunks = " auto " return self . wrap ( " weibull " , a , size = size , chunks = chunks )
self , a , size = none , chunks = " auto " return self . wrap ( " zipf " , a , size = size , chunks = chunks , a , size = none , chunks = " auto " return self . wrap ( " zipf " , a , size = size , chunks = chunks )
state data , a , size , replace , p state = np . random . random state ( state data ) return state . choice ( a , size = size , replace = replace , p = p e data , a , size , replace , p state = np . random . random state ( state data ) return state . choice ( a , size = size , replace = replace , p = p )
random state , funcname , state data , size , args , kwargs if random state is none : random state = np . random . random state state = random state ( state data ) func = getattr ( state , funcname ) return func ( * args , size = size , ** kwargs )
chunks , factor if factor == 1 : return chunks out = [ ] for c in chunks : x = c part = max ( x / factor , 1 ) while x >= 2 * part : out . append ( int ( part ) ) x = int ( part ) if x : out . append ( x ) assert sum ( chunks ) == sum ( out ) return tuple ( out )
chunks , factor assert sum ( chunks ) % factor == 0 out = [ ] residual = 0 for chunk in chunks : chunk += residual div = chunk // factor residual = chunk % factor good = factor * div if good : out . append ( good ) return tuple ( out )
func x = np . random . random ( ( 100 , 100 ) ) y = da . from array ( x , chunks = ( 50 , 50 ) ) res x = func ( x ) res y = func ( y ) assert isinstance ( res y , da . array ) assert eq ( res y , res x x = np . random . random ( ( 100 , 100 ) ) y = da . from array ( x , chunks = ( 50 , 50 ) ) res x = func ( x ) res y = func ( y ) assert isinstance ( res y , da . array ) assert eq ( res y , res x )
func x = np . random . random ( ( 100 , 100 ) ) y = da . from array ( x , chunks = ( 50 , 50 ) ) with pytest . warns ( future warning , match = " the ` . *` function is not implemented by dask " ) : func ( y x = np . random . random ( ( 100 , 100 ) ) y = da . from array ( x , chunks = ( 50 , 50 ) ) with pytest . warns ( future warning , match = " the ` . *` function is not implemented by dask " ) : func ( y )
def state = da . random . random state ( 5 ) x = state . normal ( 10 , 1 , size = 10 , chunks = 5 ) y = loads ( dumps ( x ) ) assert eq ( x , y state = da . random . random state ( 5 ) x = state . normal ( 10 , 1 , size = 10 , chunks = 5 ) y = loads ( dumps ( x ) ) assert eq ( x , y )
def a = random ( ( 10 , 10 ) , chunks = ( 5 , 5 ) ) b = random ( ( 10 , 10 ) , chunks = ( 5 , 5 ) ) assert a . name != b . nama = random ( ( 10 , 10 ) , chunks = ( 5 , 5 ) ) b = random ( ( 10 , 10 ) , chunks = ( 5 , 5 ) ) assert a . name != b . name
def assert " exponential " in exponential . doc assert " exponential " in exponential . name assert " # doctest: + skip " in normal . doc assert " exponential " in exponential . doc assert " exponential " in exponential . name assert " # doctest: + skip " in normal . doc
def normal ( 10 , 1 , ( 1000000 , 1000000 ) , chunks = ( 100000 , 100000 ) normal ( 10 , 1 , ( 1000000 , 1000000 ) , chunks = ( 100000 , 100000 ) )
def with dask . config . set ( { " array . chunk size " : " 50 mi b " } ) : x = da . random . random ( ( 10000 , 10000 ) ) assert 4 < x . npartitions < 3with dask . config . set ( { " array . chunk size " : " 50 mi b " } ) : x = da . random . random ( ( 10000 , 10000 ) ) assert 4 < x . npartitions < 32
def x = da . random . randint ( 0 , 255 , size = 10 , dtype = " uint8 " ) assert eq ( x , x ) assert x . dtype == " uint8 " assert x . compute ( ) . dtype == " uint8 "x = da . random . randint ( 0 , 255 , size = 10 , dtype = " uint8 " ) assert eq ( x , x ) assert x . dtype == " uint8 " assert x . compute ( ) . dtype == " uint8 "
a , b assert eq ( a , b , equal nan = true b assert eq ( a , b , equal nan = true )
def x = da . ones ( ( 5 , 5 ) , chunks = ( 3 , 3 ) ) with pytest . raises ( value error ) : x . sum ( axis = 2 ) with pytest . raises ( value error ) : x . sum ( axis = 3 x = da . ones ( ( 5 , 5 ) , chunks = ( 3 , 3 ) ) with pytest . raises ( value error ) : x . sum ( axis = 2 ) with pytest . raises ( value error ) : x . sum ( axis = 3 )
func x = da . arange ( 10 , chunks = 5 ) x = x [ x > 1 ] with pytest . raises ( value error ) as info : getattr ( da , func ) ( x ) assert " unknown chunksize " in str ( info . value x = da . arange ( 10 , chunks = 5 ) x = x [ x > 1 ] with pytest . raises ( value error ) as info : getattr ( da , func ) ( x ) assert " unknown chunksize " in str ( info . value )
def x = da . from array ( np . array ( 1 . 0 ) , chunks = ( ) ) assert ( x == x ) . all ( x = da . from array ( np . array ( 1 . 0 ) , chunks = ( ) ) assert ( x == x ) . all ( )
x , n , eq = true dependencies , dependents = get deps ( x . dask ) if eq : assert max ( map ( len , dependencies . values ( ) ) ) == n else : assert max ( map ( len , dependencies . values ( ) ) ) <= n , eq = true dependencies , dependents = get deps ( x . dask ) if eq : assert max ( map ( len , dependencies . values ( ) ) ) == n else : assert max ( map ( len , dependencies . values ( ) ) ) <= n
npfunc , daskfunc , split every , chunksize npa = np . random . random ( ( 10 , ) ) a = da . from array ( npa , chunks = chunksize ) k = 5 assert eq ( npfunc ( npa ) [ k : ] [ : : 1 ] , daskfunc ( a , k , split every = split every ) ) assert eq ( npfunc ( npa ) [ : k ] , daskfunc ( a , k , split every = split every ) )
p , l , u , a assert np . allclose ( p . dot ( l ) . dot ( u ) , a ) assert eq ( l , da . tril ( l ) , check graph = false ) assert eq ( u , da . triu ( u ) , check graph = false l , u , a assert np . allclose ( p . dot ( l ) . dot ( u ) , a ) assert eq ( l , da . tril ( l ) , check graph = false ) assert eq ( u , da . triu ( u ) , check graph = false )
text cleaned = text . replace ( " &rarr; " , " " ) assert xml . etree . element tree . fromstring ( cleaned ) is not non cleaned = text . replace ( " &rarr; " , " " ) assert xml . etree . element tree . fromstring ( cleaned ) is not none
def text = da . ones ( ( 10 , 10 , 10 , 10 , 10 ) ) . to svg ( ) assert text . count ( " <svg " ) == text = da . ones ( ( 10 , 10 , 10 , 10 , 10 ) ) . to svg ( ) assert text . count ( " <svg " ) == 1
def assert slice 1d ( 15 , [ 5 , 5 , 5 ] , 10 ) == { 2 : 0 } assert slice 1d ( 30 , ( 5 , 5 , 5 , 5 , 5 , 5 ) , 10 ) == { 2 : 0 assert slice 1d ( 15 , [ 5 , 5 , 5 ] , 10 ) == { 2 : 0 } assert slice 1d ( 30 , ( 5 , 5 , 5 , 5 , 5 , 5 ) , 10 ) == { 2 : 0 }
def a = da . ones ( 10 , chunks = ( 10 , ) ) [ : 0 ] . compute ( ) b = np . ones ( 10 ) [ : 0 ] assert eq ( a , b a = da . ones ( 10 , chunks = ( 10 , ) ) [ : 0 ] . compute ( ) b = np . ones ( 10 ) [ : 0 ] assert eq ( a , b )
def x = da . zeros ( shape = ( 5 , 5 ) , chunks = ( 3 , 3 ) ) y = x [ [ 2 , 1 ] ] [ none ] assert eq ( y , np . zeros ( ( 1 , 2 , 5 ) ) x = da . zeros ( shape = ( 5 , 5 ) , chunks = ( 3 , 3 ) ) y = x [ [ 2 , 1 ] ] [ none ] assert eq ( y , np . zeros ( ( 1 , 2 , 5 ) ) )
def x = da . ones ( ( 5 , 5 ) , chunks = ( 2 , 2 ) , dtype = " i4 " ) y = x [ : 0 ] assert eq ( y , np . ones ( ( 5 , 5 ) , dtype = " i4 " ) [ : 0 ] x = da . ones ( ( 5 , 5 ) , chunks = ( 2 , 2 ) , dtype = " i4 " ) y = x [ : 0 ] assert eq ( y , np . ones ( ( 5 , 5 ) , dtype = " i4 " ) [ : 0 ] )
def assert new blockdim ( 20 , [ 5 , 5 , 5 , 5 ] , slice ( 0 , none , 2 ) ) == [ 3 , 2 , 3 , 2 assert new blockdim ( 20 , [ 5 , 5 , 5 , 5 ] , slice ( 0 , none , 2 ) ) == [ 3 , 2 , 3 , 2 ]
def with pytest . raises ( type error ) : sanitize index element ( " hello! " with pytest . raises ( type error ) : sanitize index element ( " hello! " )
chunks a = da . arange ( 4 , chunks = chunks ) idx = da . from array ( [ 1 , 4 ] , chunks = 1 ) assert eq ( a [ idx ] , np . array ( [ 3 , 0 ] ) ks a = da . arange ( 4 , chunks = chunks ) idx = da . from array ( [ 1 , 4 ] , chunks = 1 ) assert eq ( a [ idx ] , np . array ( [ 3 , 0 ] ) )
@ x = da . ones ( 1000 , chunks = ( 10 , ) ) for slc in [ 1 , slice ( 0 , 30 ) , slice ( 0 , none , 100 ) ] : y = x [ slc ] assert len ( y . dask ) < len ( x . dask = da . ones ( 1000 , chunks = ( 10 , ) ) for slc in [ 1 , slice ( 0 , 30 ) , slice ( 0 , none , 100 ) ] : y = x [ slc ] assert len ( y . dask ) < len ( x . dask )
shape , index x = np . random . random ( shape ) d = da . from array ( x , chunks = shape ) assert eq ( x [ index ] , d [ index ] e , index x = np . random . random ( shape ) d = da . from array ( x , chunks = shape ) assert eq ( x [ index ] , d [ index ] )
def x = da . random . random ( ( 100 , 2 ) , ( 2 , 2 ) ) idx = np . array ( [ 0 , 0 , 1 , 1 ] ) with pytest . warns ( none ) as rec : x [ idx ] . compute ( ) assert len ( rec ) == x = da . random . random ( ( 100 , 2 ) , ( 2 , 2 ) ) idx = np . array ( [ 0 , 0 , 1 , 1 ] ) with pytest . warns ( none ) as rec : x [ idx ] . compute ( ) assert len ( rec ) == 0
def assert eq ( da . ones ( 2 , chunks = 2 ) [ 2 ] , np . ones ( 2 ) [ 2 ] assert eq ( da . ones ( 2 , chunks = 2 ) [ 2 ] , np . ones ( 2 ) [ 2 ] )
def x = np . arange ( 5 ) dx = da . from array ( x , chunks = 2 ) assert eq ( dx [ [ 0 , 5 ] ] , x [ [ 0 , 5 ] ] ) assert eq ( dx [ [ 4 , 1 ] ] , x [ [ 4 , 1 ] ] x = np . arange ( 5 ) dx = da . from array ( x , chunks = 2 ) assert eq ( dx [ [ 0 , 5 ] ] , x [ [ 0 , 5 ] ] ) assert eq ( dx [ [ 4 , 1 ] ] , x [ [ 4 , 1 ] ] )
def a = [ 1 , 2 , 3 ] np . testing . assert array equal ( cached cumsum ( a ) , [ 1 , 3 , 6 ] ) a [ 1 ] = 4 np . testing . assert array equal ( cached cumsum ( a ) , [ 1 , 5 , 8 ] a = [ 1 , 2 , 3 ] np . testing . assert array equal ( cached cumsum ( a ) , [ 1 , 3 , 6 ] ) a [ 1 ] = 4 np . testing . assert array equal ( cached cumsum ( a ) , [ 1 , 5 , 8 ] )
params array size , chunk size1 , chunk size2 = params x = da . zeros ( array size , chunks = chunk size1 ) mask = da . zeros ( array size , chunks = chunk size2 ) x [ mask ] = 1 result = x . compute ( ) assert x . shape == result . shape
def assert eq ( np . arange ( 10 ) [ 0 : : 1 ] , da . arange ( 10 , chunks = 3 ) [ 0 : : 1 ] ) assert eq ( np . arange ( 10 ) [ : : 1 ] , da . arange ( 10 , chunks = 3 ) [ : : 1 ] assert eq ( np . arange ( 10 ) [ 0 : : 1 ] , da . arange ( 10 , chunks = 3 ) [ 0 : : 1 ] ) assert eq ( np . arange ( 10 ) [ : : 1 ] , da . arange ( 10 , chunks = 3 ) [ : : 1 ] )
size , chunks x = da . random . randint ( 0 , 1000 , size = size , chunks = chunks ) index = np . arange ( len ( x ) ) np . random . shuffle ( index ) a = x [ index ] b = shuffle slice ( x , index ) assert eq ( a , b , chunks x = da . random . randint ( 0 , 1000 , size = size , chunks = chunks ) index = np . arange ( len ( x ) ) np . random . shuffle ( index ) a = x [ index ] b = shuffle slice ( x , index ) assert eq ( a , b )
def x = da . arange ( 10 , chunks = ( 5 , ) ) np . sin ( x , out = x ) np . add ( x , 10 , out = x ) assert eq ( x , np . sin ( np . arange ( 10 ) ) + 10 x = da . arange ( 10 , chunks = ( 5 , ) ) np . sin ( x , out = x ) np . add ( x , 10 , out = x ) assert eq ( x , np . sin ( np . arange ( 10 ) ) + 10 )
def x = da . arange ( 10 , chunks = ( 5 , ) ) with pytest . raises ( type error ) : assert np . add . reduce ( x x = da . arange ( 10 , chunks = ( 5 , ) ) with pytest . raises ( type error ) : assert np . add . reduce ( x )
def x = da . arange ( 10 , chunks = ( 5 , ) ) y = da . arange ( 15 , chunks = ( 5 , ) ) with pytest . raises ( value error ) : assert np . log ( x , out = y x = da . arange ( 10 , chunks = ( 5 , ) ) y = da . arange ( 15 , chunks = ( 5 , ) ) with pytest . raises ( value error ) : assert np . log ( x , out = y )
def a = ones ( [ 10 , 10 ] , dtype = " i4 " , chunks = ( 4 , 4 ) ) x = np . array ( a ) assert ( x == np . ones ( ( 10 , 10 ) , dtype = " i4 " ) ) . all ( a = ones ( [ 10 , 10 ] , dtype = " i4 " , chunks = ( 4 , 4 ) ) x = np . array ( a ) assert ( x == np . ones ( ( 10 , 10 ) , dtype = " i4 " ) ) . all ( )
def a = ones ( 10 , dtype = " i4 " , chunks = ( 4 , ) ) x = np . array ( a ) assert ( x == np . ones ( 10 , dtype = " i4 " ) ) . all ( a = ones ( 10 , dtype = " i4 " , chunks = ( 4 , ) ) x = np . array ( a ) assert ( x == np . ones ( 10 , dtype = " i4 " ) ) . all ( )
def a = ones ( 10 , dtype = " i4 " , chunks = ( 4 , ) ) x = np . array ( a ) assert ( x == np . ones ( 10 , dtype = " i4 " ) ) . all ( a = ones ( 10 , dtype = " i4 " , chunks = ( 4 , ) ) x = np . array ( a ) assert ( x == np . ones ( 10 , dtype = " i4 " ) ) . all ( )
funcname da fft = getattr ( da . fft , funcname ) bad darr = da . from array ( nparr , chunks = ( 5 , 5 ) ) for i in range ( bad darr . ndim ) : with pytest . raises ( value error ) : da fft ( bad darr , axis = i name da fft = getattr ( da . fft , funcname ) bad darr = da . from array ( nparr , chunks = ( 5 , 5 ) ) for i in range ( bad darr . ndim ) : with pytest . raises ( value error ) : da fft ( bad darr , axis = i )
funcname da fft = getattr ( da . fft , funcname ) np fft = getattr ( np . fft , funcname ) assert eq ( da fft ( darr ) , np fft ( nparr ) name da fft = getattr ( da . fft , funcname ) np fft = getattr ( np . fft , funcname ) assert eq ( da fft ( darr ) , np fft ( nparr ) )
def with pytest . raises ( value error ) : fft wrap ( np . ones with pytest . raises ( value error ) : fft wrap ( np . ones )
n , d , c c = c ( n ) r1 = np . fft . fftfreq ( n , d ) r2 = da . fft . fftfreq ( n , d , chunks = c ) assert normalize chunks ( c , r2 . shape ) == r2 . chunks assert eq ( r1 , r2 d , c c = c ( n ) r1 = np . fft . fftfreq ( n , d ) r2 = da . fft . fftfreq ( n , d , chunks = c ) assert normalize chunks ( c , r2 . shape ) == r2 . chunks assert eq ( r1 , r2 )
def def foo ( x , bar ) : assert bar == 2 return x ret = apply gufunc ( foo , " () >() " , 1 . 0 , output dtypes = " f " , bar = 2 ) assert eq ( ret , np . array ( 1 . 0 , dtype = " f " ) def foo ( x , bar ) : assert bar == 2 return x ret = apply gufunc ( foo , " () >() " , 1 . 0 , output dtypes = " f " , bar = 2 ) assert eq ( ret , np . array ( 1 . 0 , dtype = " f " ) )
def def foo ( ) : return 1 x = apply gufunc ( foo , " >() " , output dtypes = int ) assert x . compute ( ) == def foo ( ) : return 1 x = apply gufunc ( foo , " >() " , output dtypes = int ) assert x . compute ( ) == 1
def def foo ( ) : return 1 , 2 x , y = apply gufunc ( foo , " >() , () " , output dtypes = ( int , int ) ) assert x . compute ( ) == 1 assert y . compute ( ) == def foo ( ) : return 1 , 2 x , y = apply gufunc ( foo , " >() , () " , output dtypes = ( int , int ) ) assert x . compute ( ) == 1 assert y . compute ( ) == 2
def a = np . random . uniform ( 0 , 1 , 30 ) x = da . from array ( a , chunks = ( ( 10 , ) * 3 , ) ) new = ( ( 5 , ) * 6 , ) x2 = rechunk ( x , chunks = new ) assert x2 . chunks == new assert np . all ( x2 . compute ( ) == a )
def a = np . random . uniform ( 0 , 1 , 300 ) . reshape ( ( 10 , 30 ) ) x = da . from array ( a , chunks = ( ( 1 , 2 , 3 , 4 ) , ( 5 , ) * 6 ) ) new = ( ( 5 , 5 ) , ( 15 , ) * 2 ) x2 = rechunk ( x , chunks = new ) assert x2 . chunks == new assert np . all ( x2 . compute ( ) == a )
def old = ( ( 5 , 5 ) , ) * 4 a = np . random . uniform ( 0 , 1 , 10000 ) . reshape ( ( 10 , ) * 4 ) x = da . from array ( a , chunks = old ) new = ( ( 10 , ) , ) * 4 x2 = rechunk ( x , chunks = new ) assert x2 . chunks == new assert np . all ( x2 . compute ( ) == a )
def old = ( ( 5 , 2 , 3 ) , ) * 4 new = ( ( 3 , 3 , 3 , 1 ) , ) * 4 a = np . random . uniform ( 0 , 1 , 10000 ) . reshape ( ( 10 , ) * 4 ) x = da . from array ( a , chunks = old ) x2 = x . rechunk ( chunks = new ) assert x2 . chunks == new assert np . all ( x2 . compute ( ) == a )
def new shape , new chunks = ( 10 , 10 ) , ( 4 , 3 ) new blockdims = normalize chunks ( new chunks , new shape ) old chunks = ( ( 4 , 4 , 2 ) , ( 3 , 3 , 3 , 1 ) ) a = np . random . uniform ( 0 , 1 , 100 ) . reshape ( ( 10 , 10 ) ) x = da . from array ( a , chunks = old chunks ) check1 = rechunk ( x , chunks = new chunks ) assert check1 . chunks == new blockdims assert np . all ( check1 . compute ( ) == a )
def x = da . ones ( 5 , chunks = ( 2 , ) ) assert x . rechunk ( chunks = ( 1 , ) ) . dtype == x . dtypx = da . ones ( 5 , chunks = ( 2 , ) ) assert x . rechunk ( chunks = ( 1 , ) ) . dtype == x . dtype
def x = da . ones ( ( 24 , 24 ) , chunks = ( 4 , 8 ) ) assert x . rechunk ( chunks = { } ) . chunks == x . chunks pytest . raises ( value error , lambda : x . rechunk ( chunks = ( ) ) x = da . ones ( ( 24 , 24 ) , chunks = ( 4 , 8 ) ) assert x . rechunk ( chunks = { } ) . chunks == x . chunks pytest . raises ( value error , lambda : x . rechunk ( chunks = ( ) ) )
def x = da . from array ( np . ones ( ( 24 , 24 ) ) , chunks = ( 4 , 8 ) ) assert x . rechunk ( chunks = ( none , 4 ) ) . chunks == da . ones ( ( 24 , 24 ) , chunks = ( 4 , 4 ) ) . chunkx = da . from array ( np . ones ( ( 24 , 24 ) ) , chunks = ( 4 , 8 ) ) assert x . rechunk ( chunks = ( none , 4 ) ) . chunks == da . ones ( ( 24 , 24 ) , chunks = ( 4 , 4 ) ) . chunks
def x = da . from array ( np . arange ( 5 ) , chunks = 4 ) y = x . rechunk ( 3 ) assert y . chunks == ( ( 3 , 2 ) , ) assert ( x . compute ( ) == y . compute ( ) ) . all ( x = da . from array ( np . arange ( 5 ) , chunks = 4 ) y = x . rechunk ( 3 ) assert y . chunks == ( ( 3 , 2 ) , ) assert ( x . compute ( ) == y . compute ( ) ) . all ( )
def a = np . array ( 42 ) x = da . from array ( a , chunks = ( ) ) y = x . rechunk ( ( ) ) assert y . chunks == ( ) assert y . compute ( ) == a = np . array ( 42 ) x = da . from array ( a , chunks = ( ) ) y = x . rechunk ( ( ) ) assert y . chunks == ( ) assert y . compute ( ) == a
def x = da . ones ( ( 0 , 10 ) , chunks = ( 5 , 5 ) ) y = x . rechunk ( ( 2 , 2 ) ) assert y . chunks == ( ( 0 , ) , ( 2 , ) * 5 ) assert eq ( x , y x = da . ones ( ( 0 , 10 ) , chunks = ( 5 , 5 ) ) y = x . rechunk ( ( 2 , 2 ) ) assert y . chunks == ( ( 0 , ) , ( 2 , ) * 5 ) assert eq ( x , y )
def x = da . ones ( ( 24 , 24 ) , chunks = ( 4 , 8 ) ) y = x . rechunk ( ( 1 , 8 ) ) assert y . chunks == ( ( 24 , ) , ( 8 , 8 , 8 ) ) assert eq ( x , y x = da . ones ( ( 24 , 24 ) , chunks = ( 4 , 8 ) ) y = x . rechunk ( ( 1 , 8 ) ) assert y . chunks == ( ( 24 , ) , ( 8 , 8 , 8 ) ) assert eq ( x , y )
def x = da . random . normal ( 10 , 0 . 1 , ( 10 , 10 ) , chunks = ( 10 , 1 ) ) y = x . rechunk ( ( 1 , 10 ) ) assert len ( y . dask ) > 3x = da . random . normal ( 10 , 0 . 1 , ( 10 , 10 ) , chunks = ( 10 , 1 ) ) y = x . rechunk ( ( 1 , 10 ) ) assert len ( y . dask ) > 30
def n = 20 x = da . random . normal ( size = ( n , n , 100 ) , chunks = ( 1 , n , 100 ) ) with warnings . catch warnings ( record = true ) as w : x = x . rechunk ( ( n , 1 , 100 ) ) assert not n = 20 x = da . random . normal ( size = ( n , n , 100 ) , chunks = ( 1 , n , 100 ) ) with warnings . catch warnings ( record = true ) as w : x = x . rechunk ( ( n , 1 , 100 ) ) assert not w
left , right for x , y in zip ( left , right ) : if np . isnan ( x ) . any ( ) : assert np . isnan ( x ) . all ( ) else : assert x == , right for x , y in zip ( left , right ) : if np . isnan ( x ) . any ( ) : assert np . isnan ( x ) . all ( ) else : assert x == y
def da = pytest . importorskip ( " dask . array " ) x = da . ones ( ( 0 , 10 , 100 ) , chunks = ( 0 , 10 , 10 ) ) . rechunk ( ( 0 , 10 , 50 ) ) assert len ( x . compute ( ) ) == da = pytest . importorskip ( " dask . array " ) x = da . ones ( ( 0 , 10 , 100 ) , chunks = ( 0 , 10 , 10 ) ) . rechunk ( ( 0 , 10 , 50 ) ) assert len ( x . compute ( ) ) == 0
def x = da . zeros ( ( 7 , 24 ) , chunks = ( ( 7 , ) , ( 10 , 0 , 0 , 9 , 0 , 5 ) ) ) y = x . rechunk ( ( 2 , 3 ) ) assert eq ( x , y x = da . zeros ( ( 7 , 24 ) , chunks = ( ( 7 , ) , ( 10 , 0 , 0 , 9 , 0 , 5 ) ) ) y = x . rechunk ( ( 2 , 3 ) ) assert eq ( x , y )
shape , chunks , bs , expected x = da . ones ( shape , chunks = ( chunks , ) ) y = x . rechunk ( { 0 : " auto " } , block size limit = bs * x . dtype . itemsize ) assert y . chunks == ( expected , e , chunks , bs , expected x = da . ones ( shape , chunks = ( chunks , ) ) y = x . rechunk ( { 0 : " auto " } , block size limit = bs * x . dtype . itemsize ) assert y . chunks == ( expected , )
def with dask . config . set ( { " array . chunk size " : " 1 b " } ) : x = da . ones ( 10 , chunks = ( 5 , ) ) y = x . rechunk ( " auto " ) assert y . chunks == ( ( 1 , ) * 10 , with dask . config . set ( { " array . chunk size " : " 1 b " } ) : x = da . ones ( 10 , chunks = ( 5 , ) ) y = x . rechunk ( " auto " ) assert y . chunks == ( ( 1 , ) * 10 , )
method x = da . ones ( 10 , chunks = ( ( 5 , 0 , 5 ) , ) ) assert eq ( da . percentile ( x , [ 10 , 50 , 90 ] , method = method ) , np . array ( [ 1 , 1 , 1 ] , dtype = x . dtype ) , od x = da . ones ( 10 , chunks = ( ( 5 , 0 , 5 ) , ) ) assert eq ( da . percentile ( x , [ 10 , 50 , 90 ] , method = method ) , np . array ( [ 1 , 1 , 1 ] , dtype = x . dtype ) , )
method , q d = da . ones ( ( 16 , ) , chunks = ( 4 , ) ) assert eq ( da . percentile ( d , q , method = method ) , np . array ( [ 1 ] , dtype = d . dtype ) od , q d = da . ones ( ( 16 , ) , chunks = ( 4 , ) ) assert eq ( da . percentile ( d , q , method = method ) , np . array ( [ 1 ] , dtype = d . dtype ) )
def y = da . mean ( xr . data array ( [ 1 , 2 , 3 . 0 ] ) ) assert isinstance ( y , da . array ) assert eq ( y , y y = da . mean ( xr . data array ( [ 1 , 2 , 3 . 0 ] ) ) assert isinstance ( y , da . array ) assert eq ( y , y )
def y = da . asanyarray ( xr . data array ( [ 1 , 2 , 3 . 0 ] ) ) assert isinstance ( y , da . array ) assert eq ( y , y y = da . asanyarray ( xr . data array ( [ 1 , 2 , 3 . 0 ] ) ) assert isinstance ( y , da . array ) assert eq ( y , y )
def x = da . ones ( 10 , chunks = ( 5 , ) ) y = x [ : , none ] * x [ none , : ] d = y . dask . dicts [ y . name ] assert len ( d ) == x = da . ones ( 10 , chunks = ( 5 , ) ) y = x [ : , none ] * x [ none , : ] d = y . dask . dicts [ y . name ] assert len ( d ) == 4
def x = da . ones ( 5 , chunks = ( 2 , ) ) y = da . blockwise ( add , " i " , x , " i " , dtype = x . dtype ) assert y . name . startswith ( " add " x = da . ones ( 5 , chunks = ( 2 , ) ) y = da . blockwise ( add , " i " , x , " i " , dtype = x . dtype ) assert y . name . startswith ( " add " )
def x = da . ones ( ( 1 , 1 ) , chunks = ( 1 , 1 ) ) y = x * 2 u , s , v = da . linalg . svd ( y ) z = y + u assert eq ( z , z x = da . ones ( ( 1 , 1 ) , chunks = ( 1 , 1 ) ) y = x * 2 u , s , v = da . linalg . svd ( y ) z = y + u assert eq ( z , z )
boundary x = da . arange ( 10 , chunks = 5 ) y = x . map overlap ( lambda i : i , depth = 0 , boundary = boundary , dtype = x . dtype ) assert eq ( y , x dary x = da . arange ( 10 , chunks = 5 ) y = x . map overlap ( lambda i : i , depth = 0 , boundary = boundary , dtype = x . dtype ) assert eq ( y , x )
def expected = np . arange ( 144 ) . reshape ( 12 , 12 ) darr = da . from array ( expected , chunks = ( 5 , 5 ) ) depth = { 0 : 4 , 1 : 2 } pytest . raises ( value error , overlap , darr , depth = depth , boundary = 1 expected = np . arange ( 144 ) . reshape ( 12 , 12 ) darr = da . from array ( expected , chunks = ( 5 , 5 ) ) depth = { 0 : 4 , 1 : 2 } pytest . raises ( value error , overlap , darr , depth = depth , boundary = 1 )
dtype c = cupy . random . random ( ( 2 , 3 , 4 ) , dtype = dtype ) assert sizeof ( c ) == c . nbytee c = cupy . random . random ( ( 2 , 3 , 4 ) , dtype = dtype ) assert sizeof ( c ) == c . nbytes
def assert da . zeros ( ( 4 , 6 ) , chunks = 2 ) . rechunk ( 3 ) . chunks == ( ( 3 , 1 ) , ( 3 , 3 ) assert da . zeros ( ( 4 , 6 ) , chunks = 2 ) . rechunk ( 3 ) . chunks == ( ( 3 , 1 ) , ( 3 , 3 ) )
def assert eq ( concatenate3 ( [ 1 , 2 ] ) , np . array ( [ 1 , 2 ] ) assert eq ( concatenate3 ( [ 1 , 2 ] ) , np . array ( [ 1 , 2 ] ) )
def argpairs = [ ( " x " , " i " ) ] numblocks = { " x " : ( ( 1 , ) , ) } assert broadcast dimensions ( argpairs , numblocks ) == { " i " : ( 1 , ) argpairs = [ ( " x " , " i " ) ] numblocks = { " x " : ( ( 1 , ) , ) } assert broadcast dimensions ( argpairs , numblocks ) == { " i " : ( 1 , ) }
def x = np . empty ( ( 2 , 0 , 3 ) ) y = da . from array ( x , chunks = 1 ) result np = np . concatenate ( [ x , x ] ) result da = da . concatenate ( [ y , y ] ) assert eq ( result np , result da x = np . empty ( ( 2 , 0 , 3 ) ) y = da . from array ( x , chunks = 1 ) result np = np . concatenate ( [ x , x ] ) result da = da . concatenate ( [ y , y ] ) assert eq ( result np , result da )
dtypes dts in , dt out = dtypes arrs = [ np . zeros ( 4 , dtype = dt ) for dt in dts in ] darrs = [ from array ( arr , chunks = ( 2 , ) ) for arr in arrs ] x = concatenate ( darrs , axis = 0 ) assert x . dtype == dt oues dts in , dt out = dtypes arrs = [ np . zeros ( 4 , dtype = dt ) for dt in dts in ] darrs = [ from array ( arr , chunks = ( 2 , ) ) for arr in arrs ] x = concatenate ( darrs , axis = 0 ) assert x . dtype == dt out
def a = np . array ( [ 0 , 0 ] ) b = np . eye ( 2 ) for arrays in [ [ a , b ] , [ b , a ] ] : with pytest . raises ( value error ) : da . block ( arrays a = np . array ( [ 0 , 0 ] ) b = np . eye ( 2 ) for arrays in [ [ a , b ] , [ b , a ] ] : with pytest . raises ( value error ) : da . block ( arrays )
def assert eq ( da . block ( 1 ) , np . block ( 1 ) ) assert eq ( da . block ( np . eye ( 3 ) ) , np . block ( np . eye ( 3 ) ) assert eq ( da . block ( 1 ) , np . block ( 1 ) ) assert eq ( da . block ( np . eye ( 3 ) ) , np . block ( np . eye ( 3 ) ) )
def for arrays in [ [ ] , [ [ ] ] , [ [ 1 ] , [ ] ] ] : with pytest . raises ( value error ) as e : da . block ( arrays ) e . match ( r " empty " for arrays in [ [ ] , [ [ ] ] , [ [ 1 ] , [ ] ] ] : with pytest . raises ( value error ) as e : da . block ( arrays ) e . match ( r " empty " )
def for arrays in [ ( [ 1 , 2 ] , [ 3 , 4 ] ) , [ ( 1 , 2 ) , ( 3 , 4 ) ] ] : with pytest . raises ( type error ) as e : da . block ( arrays ) e . match ( r " tuple " for arrays in [ ( [ 1 , 2 ] , [ 3 , 4 ] ) , [ ( 1 , 2 ) , ( 3 , 4 ) ] ] : with pytest . raises ( type error ) as e : da . block ( arrays ) e . match ( r " tuple " )
def x = np . arange ( 400 ) . reshape ( ( 20 , 20 ) ) a = from array ( x , chunks = ( 5 , 5 ) ) assert eq ( x . t , a . t x = np . arange ( 400 ) . reshape ( ( 20 , 20 ) ) a = from array ( x , chunks = ( 5 , 5 ) ) assert eq ( x . t , a . t )
def x = np . random . randint ( 10 , size = ( 5 , ) ) a = from array ( x , chunks = ( 2 , ) ) with pytest . raises ( value error ) : da . reshape ( a , ( 100 , ) x = np . random . randint ( 10 , size = ( 5 , ) ) a = from array ( x , chunks = ( 2 , ) ) with pytest . raises ( value error ) : da . reshape ( a , ( 100 , ) )
def d = da . arange ( 10 , chunks = 5 ) result = d . map blocks ( np . max , axis = 0 , keepdims = true , dtype = d . dtype , chunks = ( 1 , ) ) assert eq ( result , np . array ( [ 4 , 9 ] ) d = da . arange ( 10 , chunks = 5 ) result = d . map blocks ( np . max , axis = 0 , keepdims = true , dtype = d . dtype , chunks = ( 1 , ) ) assert eq ( result , np . array ( [ 4 , 9 ] ) )
def d = da . ones ( ( 4 , 4 ) , chunks = ( 2 , 2 ) ) assert " chunktype=numpy . ndarray " in repr ( d ) sparse = pytest . importorskip ( " sparse " ) s = d . map blocks ( sparse . coo ) assert " chunktype=sparse . coo " in repr ( s d = da . ones ( ( 4 , 4 ) , chunks = ( 2 , 2 ) ) assert " chunktype=numpy . ndarray " in repr ( d ) sparse = pytest . importorskip ( " sparse " ) s = d . map blocks ( sparse . coo ) assert " chunktype=sparse . coo " in repr ( s )
def a = np . array ( [ [ " a " , " b " ] , [ " c " , " d " ] ] ) b = da . from array ( a , 2 ) assert eq ( a [ : , 0 ] , b [ : , 0 ] a = np . array ( [ [ " a " , " b " ] , [ " c " , " d " ] ] ) b = da . from array ( a , 2 ) assert eq ( a [ : , 0 ] , b [ : , 0 ] )
def arr = np . arange ( 100 ) . reshape ( ( 10 , 10 ) ) darr = da . from array ( arr , chunks = ( 10 , 10 ) ) with pytest . raises ( value error ) : bool ( darr ) bool ( darr == darr arr = np . arange ( 100 ) . reshape ( ( 10 , 10 ) ) darr = da . from array ( arr , chunks = ( 10 , 10 ) ) with pytest . raises ( value error ) : bool ( darr ) bool ( darr == darr )
self , * args , ** kwargs self . release count += 1 return self . lock . release ( * args , ** kwargs , * args , ** kwargs self . release count += 1 return self . lock . release ( * args , ** kwargs )
def d = da . ones ( ( 4 , 4 ) , chunks = ( 2 , 2 ) ) assert eq ( np . array ( d . sum ( ) ) , np . array ( d . compute ( ) . sum ( ) ) d = da . ones ( ( 4 , 4 ) , chunks = ( 2 , 2 ) ) assert eq ( np . array ( d . sum ( ) ) , np . array ( d . compute ( ) . sum ( ) ) )
def x = da . ones ( ( 10 , 2 ) , chunks = ( 3 , 1 ) ) assert x . size == np . array ( x ) . size assert isinstance ( x . size , int x = da . ones ( ( 10 , 2 ) , chunks = ( 3 , 1 ) ) assert x . size == np . array ( x ) . size assert isinstance ( x . size , int )
def x = da . ones ( ( 10 , 2 ) , chunks = ( 3 , 1 ) ) assert x . nbytes == np . array ( x ) . nbytex = da . ones ( ( 10 , 2 ) , chunks = ( 3 , 1 ) ) assert x . nbytes == np . array ( x ) . nbytes
def x = da . ones ( ( 10 , 2 ) , chunks = ( 3 , 1 ) ) assert x . itemsize == x = da . ones ( ( 10 , 2 ) , chunks = ( 3 , 1 ) ) assert x . itemsize == 8
def x = da . ones ( ( 3 , ) , chunks = ( 1 , ) , dtype = int ) assert isinstance ( x . dtype , np . dtype x = da . ones ( ( 3 , ) , chunks = ( 1 , ) , dtype = int ) assert isinstance ( x . dtype , np . dtype )
def x = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) dx = da . from array ( x , chunks = ( 1 , 2 ) ) assert eq ( x , dx ) assert dx . dask [ dx . name , 0 , 0 ] [ 0 ] == operator . getitem
def x = np . arange ( 10 ) y = da . from array ( x , 1 ) assert y . chunks == ( ( 10 , ) , ) assert eq ( x , y x = np . arange ( 10 ) y = da . from array ( x , 1 ) assert y . chunks == ( ( 10 , ) , ) assert eq ( x , y )
def x = np . arange ( 10 ) y = da . from array ( x , 1 ) assert y . npartitions == 1 y c = y . copy ( ) assert y is not y c assert y . compute ( ) is not y c . compute ( x = np . arange ( 10 ) y = da . from array ( x , 1 ) assert y . npartitions == 1 y c = y . copy ( ) assert y is not y c assert y . compute ( ) is not y c . compute ( )
def x = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) dx = da . from array ( x , chunks = ( 1 , 2 ) ) with pytest . raises ( value error ) : da . from array ( dx x = np . array ( [ [ 1 , 2 ] , [ 3 , 4 ] ] ) dx = da . from array ( x , chunks = ( 1 , 2 ) ) with pytest . raises ( value error ) : da . from array ( dx )
def assert eq ( da . asarray ( [ 1 , 2 , 3 ] ) , np . asarray ( [ 1 , 2 , 3 ] ) ) x = da . asarray ( [ 1 , 2 , 3 ] ) assert da . asarray ( x ) is assert eq ( da . asarray ( [ 1 , 2 , 3 ] ) , np . asarray ( [ 1 , 2 , 3 ] ) ) x = da . asarray ( [ 1 , 2 , 3 ] ) assert da . asarray ( x ) is x
def x = da . ones ( 6 , chunks = 3 ) try : x . chunks = 2 assert false except type error as e : assert " rechunk(2) " in str ( e x = da . ones ( 6 , chunks = 3 ) try : x . chunks = 2 assert false except type error as e : assert " rechunk(2) " in str ( e )
def x = da . ones ( 5 , chunks = 3 ) try : da . minimum ( x , foo = none ) except type error as e : assert " minimum " in str ( e ) assert " foo " in str ( e x = da . ones ( 5 , chunks = 3 ) try : da . minimum ( x , foo = none ) except type error as e : assert " minimum " in str ( e ) assert " foo " in str ( e )
def x = np . arange ( 10000 ) d = da . from array ( x , chunks = 1 ) assert eq ( d [ 8000 : 8200 ] , x [ 8000 : 8200 ] x = np . arange ( 10000 ) d = da . from array ( x , chunks = 1 ) assert eq ( d [ 8000 : 8200 ] , x [ 8000 : 8200 ] )
def assert eq ( da . ones ( 4 , chunks = 2 ) [ . . . ] , np . ones ( 4 ) assert eq ( da . ones ( 4 , chunks = 2 ) [ . . . ] , np . ones ( 4 ) )
def x = np . arange ( 10 ) dx = da . from array ( x , chunks = 5 ) inds = int ( 3 ) assert eq ( dx [ inds ] , x [ inds ] ) inds = np . int64 ( 3 ) assert eq ( dx [ inds ] , x [ inds ] x = np . arange ( 10 ) dx = da . from array ( x , chunks = 5 ) inds = int ( 3 ) assert eq ( dx [ inds ] , x [ inds ] ) inds = np . int64 ( 3 ) assert eq ( dx [ inds ] , x [ inds ] )
def x = np . arange ( 10 ) d = da . from array ( x , chunks = ( 5 , 5 ) ) result = d . vindex [ np . array ( [ 0 , 1 ] ) ] assert eq ( result , x [ np . array ( [ 0 , 1 ] ) ] x = np . arange ( 10 ) d = da . from array ( x , chunks = ( 5 , 5 ) ) result = d . vindex [ np . array ( [ 0 , 1 ] ) ] assert eq ( result , x [ np . array ( [ 0 , 1 ] ) ] )
def assert eq ( np . arange ( 0 ) , da . arange ( 0 , chunks = 5 ) assert eq ( np . arange ( 0 ) , da . arange ( 0 , chunks = 5 ) )
def x = np . ones ( ( 10 , 10 ) ) with pytest . raises ( value error ) : da . from array ( x , chunks = ( 5 , ) x = np . ones ( ( 10 , 10 ) ) with pytest . raises ( value error ) : da . from array ( x , chunks = ( 5 , ) )
def x = da . arange ( 10 , chunks = 2 ) . sum ( ) x . compute ( bogus keyword = 10 x = da . arange ( 10 , chunks = 2 ) . sum ( ) x . compute ( bogus keyword = 10 )
def x = np . array ( [ np . timedelta64 ( 10 , " h " ) ] ) y = np . timedelta64 ( 1 , " h " ) a = da . from array ( x , chunks = ( 1 , ) ) / y assert a . compute ( ) == x / x = np . array ( [ np . timedelta64 ( 10 , " h " ) ] ) y = np . timedelta64 ( 1 , " h " ) a = da . from array ( x , chunks = ( 1 , ) ) / y assert a . compute ( ) == x / y
def v = delayed ( np . ones ) ( ( 5 , 3 ) ) x = from delayed ( v , shape = ( 5 , 3 ) , dtype = np . ones ( 0 ) . dtype ) assert isinstance ( x , array ) assert eq ( x , np . ones ( ( 5 , 3 ) ) v = delayed ( np . ones ) ( ( 5 , 3 ) ) x = from delayed ( v , shape = ( 5 , 3 ) , dtype = np . ones ( 0 ) . dtype ) assert isinstance ( x , array ) assert eq ( x , np . ones ( ( 5 , 3 ) ) )
def v = delayed ( np . ones ) ( ( 5 , 3 ) ) x = from delayed ( v , shape = ( 5 , 3 ) , meta = np . ones ( 0 ) ) assert isinstance ( x , array ) assert isinstance ( x . meta , np . ndarray v = delayed ( np . ones ) ( ( 5 , 3 ) ) x = from delayed ( v , shape = ( 5 , 3 ) , meta = np . ones ( 0 ) ) assert isinstance ( x , array ) assert isinstance ( x . meta , np . ndarray )
def assert da . ones ( 5 , chunks = ( 2 , ) ) . npartitions == 3 assert da . ones ( ( 5 , 5 ) , chunks = ( 2 , 3 ) ) . npartitions == assert da . ones ( 5 , chunks = ( 2 , ) ) . npartitions == 3 assert da . ones ( ( 5 , 5 ) , chunks = ( 2 , 3 ) ) . npartitions == 6
def a = np . arange ( 5 ) . astype ( np . int32 ) b = da . from array ( a , ( 1 , ) ) assert eq ( a . astype ( np . int16 ) , b . astype ( np . int16 ) a = np . arange ( 5 ) . astype ( np . int32 ) b = da . from array ( a , ( 1 , ) ) assert eq ( a . astype ( np . int16 ) , b . astype ( np . int16 ) )
def assert da . ones ( 5 , chunks = 2 ) . map blocks ( inc ) . name . startswith ( " inc " assert da . ones ( 5 , chunks = 2 ) . map blocks ( inc ) . name . startswith ( " inc " )
def pytest . importorskip ( " distributed " ) x = np . ones ( 10 ) d = da . from array ( x , chunks = 2 ) names = countby ( key split , d . dask ) assert set ( names . values ( ) ) == set ( [ 1 , 5 ] pytest . importorskip ( " distributed " ) x = np . ones ( 10 ) d = da . from array ( x , chunks = 2 ) names = countby ( key split , d . dask ) assert set ( names . values ( ) ) == set ( [ 1 , 5 ] )
def x = np . ones ( 10 ) with pytest . raises ( value error ) : da . from array ( x , chunks = ( 5 , 5 , 5 ) ) with pytest . raises ( value error ) : da . from array ( x , chunks = ( ( 5 , 5 , 5 ) , ) x = np . ones ( 10 ) with pytest . raises ( value error ) : da . from array ( x , chunks = ( 5 , 5 , 5 ) ) with pytest . raises ( value error ) : da . from array ( x , chunks = ( ( 5 , 5 , 5 ) , ) )
def x = da . ones ( ( 20 , 20 ) , chunks = ( 20 , 1 ) ) y = da . ones ( ( 20 , 20 ) , chunks = ( 1 , 20 ) ) with pytest . warns ( da . core . performance warning , match = " factor of 20 " ) : x + x = da . ones ( ( 20 , 20 ) , chunks = ( 20 , 1 ) ) y = da . ones ( ( 20 , 20 ) , chunks = ( 1 , 20 ) ) with pytest . warns ( da . core . performance warning , match = " factor of 20 " ) : x + y
def x = da . ones ( ( 4 , 4 ) , chunks = ( 2 , 2 ) ) with pytest . raises ( value error ) : x [ x > 1 ] = x = da . ones ( ( 4 , 4 ) , chunks = ( 2 , 2 ) ) with pytest . raises ( value error ) : x [ x > 1 ] = x
def x = da . arange ( 5 , chunks = 1 ) y = x [ [ ] ] assert y . dtype == x . dtype assert y . shape == ( 0 , ) assert eq ( x [ [ ] ] , np . arange ( 5 ) [ [ ] ] x = da . arange ( 5 , chunks = 1 ) y = x [ [ ] ] assert y . dtype == x . dtype assert y . shape == ( 0 , ) assert eq ( x [ [ ] ] , np . arange ( 5 ) [ [ ] ] )
def x = np . ones ( 10 ) y = da . ones ( 10 , chunks = ( 5 , ) ) assert eq ( x + y , x + x ) s = da . sum ( x ) assert any ( x is v for v in s . dask . values ( ) x = np . ones ( 10 ) y = da . ones ( 10 , chunks = ( 5 , ) ) assert eq ( x + y , x + x ) s = da . sum ( x ) assert any ( x is v for v in s . dask . values ( ) )
def x = da . ones ( 5 , chunks = 3 ) with warnings . catch warnings ( record = true ) as record : da . arccos ( x ) assert not recorx = da . ones ( 5 , chunks = 3 ) with warnings . catch warnings ( record = true ) as record : da . arccos ( x ) assert not record
def a = da . zeros ( ( 1 , ) , chunks = ( 1 , ) ) d = delayed ( identity ) ( a ) b = da . from delayed ( d , shape = a . shape , dtype = a . dtype ) assert eq ( a , b a = da . zeros ( ( 1 , ) , chunks = ( 1 , ) ) d = delayed ( identity ) ( a ) b = da . from delayed ( d , shape = a . shape , dtype = a . dtype ) assert eq ( a , b )
def x = da . ones ( ( ) , chunks = ( ) ) with pytest . raises ( type error ) as exc info : len ( x ) err msg = " len() of unsized object " assert err msg in str ( exc info . value x = da . ones ( ( ) , chunks = ( ) ) with pytest . raises ( type error ) as exc info : len ( x ) err msg = " len() of unsized object " assert err msg in str ( exc info . value )
dtype a = da . zeros ( ( 1 , ) , chunks = ( 1 , ) ) assert a . meta . dtype == a . dtype assert isinstance ( a . meta , np . ndarray ) assert a . nbytes < 100e a = da . zeros ( ( 1 , ) , chunks = ( 1 , ) ) assert a . meta . dtype == a . dtype assert isinstance ( a . meta , np . ndarray ) assert a . nbytes < 1000
shape , limit , expected result = normalize chunks ( " auto " , ( shape , ) , limit = limit , dtype = np . uint8 ) assert result == ( expected , e , limit , expected result = normalize chunks ( " auto " , ( shape , ) , limit = limit , dtype = np . uint8 ) assert result == ( expected , )
shape , chunks , limit , expected result = normalize chunks ( chunks , shape , limit = limit , dtype = " uint8 " ) assert result == expectee , chunks , limit , expected result = normalize chunks ( chunks , shape , limit = limit , dtype = " uint8 " ) assert result == expected
dtype x = np . array ( [ " a " , " abc " ] , dtype = object ) with pytest . raises ( not implemented error ) : da . from array ( x , chunks = " auto " e x = np . array ( [ " a " , " abc " ] , dtype = object ) with pytest . raises ( not implemented error ) : da . from array ( x , chunks = " auto " )
def result = normalize chunks ( ( ( 2 , 3 , 5 ) , " auto " ) , ( 10 , 10 ) , limit = 10 , dtype = np . uint8 ) expected = ( ( 2 , 3 , 5 ) , ( 2 , 2 , 2 , 2 , 2 ) ) assert result == expecteresult = normalize chunks ( ( ( 2 , 3 , 5 ) , " auto " ) , ( 10 , 10 ) , limit = 10 , dtype = np . uint8 ) expected = ( ( 2 , 3 , 5 ) , ( 2 , 2 , 2 , 2 , 2 ) ) assert result == expected
def zarr = pytest . importorskip ( " zarr " ) a = zarr . array ( [ 1 , 2 , 3 ] ) b = zarr . array ( [ 4 , 5 , 6 ] ) assert da . from zarr ( a ) . name != da . from zarr ( b ) . namzarr = pytest . importorskip ( " zarr " ) a = zarr . array ( [ 1 , 2 , 3 ] ) b = zarr . array ( [ 4 , 5 , 6 ] ) assert da . from zarr ( a ) . name != da . from zarr ( b ) . name
def pytest . importorskip ( " zarr " ) a = da . random . random ( ( 10 , ) , chunks = ( 3 , ) ) a = a [ a > 0 . 5 ] with pytest . raises ( value error , match = " unknown chunk sizes " ) : a . to zarr ( { } pytest . importorskip ( " zarr " ) a = da . random . random ( ( 10 , ) , chunks = ( 3 , ) ) a = a [ a > 0 . 5 ] with pytest . raises ( value error , match = " unknown chunk sizes " ) : a . to zarr ( { } )
data chunkset , expected = data assert da . core . check regular chunks ( chunkset ) == expecte chunkset , expected = data assert da . core . check regular chunks ( chunkset ) == expected
def with warnings . catch warnings ( ) as record : y = da . random . random ( ( 10 , 10 ) , chunks = " auto " ) da . argmax ( y , axis = 0 ) . compute ( ) assert not recorwith warnings . catch warnings ( ) as record : y = da . random . random ( ( 10 , 10 ) , chunks = " auto " ) da . argmax ( y , axis = 0 ) . compute ( ) assert not record
def x = da . from array ( np . array ( [ " a " , " b " , " c " ] , dtype = object ) , chunks = 1 ) assert ( x [ 0 ] == x [ 0 ] ) . compute ( scheduler = " sync " x = da . from array ( np . array ( [ " a " , " b " , " c " ] , dtype = object ) , chunks = 1 ) assert ( x [ 0 ] == x [ 0 ] ) . compute ( scheduler = " sync " )
def x = da . ones ( 10 , chunks = 1 ) y = x [ 6 : 3 ] assert eq ( y , np . ones ( 0 ) x = da . ones ( 10 , chunks = 1 ) y = x [ 6 : 3 ] assert eq ( y , np . ones ( 0 ) )
def sparse = pytest . importorskip ( " sparse " ) x = np . ones ( 10 ) meta = sparse . coo . from numpy ( x ) y = da . from array ( x , meta = meta ) assert isinstance ( y . meta , sparse . coo sparse = pytest . importorskip ( " sparse " ) x = np . ones ( 10 ) meta = sparse . coo . from numpy ( x ) y = da . from array ( x , meta = meta ) assert isinstance ( y . meta , sparse . coo )
num = 50 return da . from array ( np . linspace ( 1 , 1 , num = num ) , chunks = 10 = 50 return da . from array ( np . linspace ( 1 , 1 , num = num ) , chunks = 10 )
@ x = known ( ) y = x [ x < 0 ] assert y . chunks == ( ( np . nan , ) * 5 , ) return = known ( ) y = x [ x < 0 ] assert y . chunks == ( ( np . nan , ) * 5 , ) return y
unknown y = unknown with pytest . raises ( value error , match = " compute chunk sizes " ) : y . rechunk ( " auto " ) y . compute chunk sizes ( ) y . rechunk ( " auto " own y = unknown with pytest . raises ( value error , match = " compute chunk sizes " ) : y . rechunk ( " auto " ) y . compute chunk sizes ( ) y . rechunk ( " auto " )
unknown y = unknown with pytest . raises ( not implemented error , match = " compute chunk sizes " ) : y . to svg ( ) y . compute chunk sizes ( ) y . to svg ( own y = unknown with pytest . raises ( not implemented error , match = " compute chunk sizes " ) : y . to svg ( ) y . compute chunk sizes ( ) y . to svg ( )
unknown y = unknown with pytest . raises ( value error , match = " compute chunk sizes " ) : da . argmin ( y ) y . compute chunk sizes ( ) da . argmin ( y own y = unknown with pytest . raises ( value error , match = " compute chunk sizes " ) : da . argmin ( y ) y . compute chunk sizes ( ) da . argmin ( y )
unknown y = unknown with pytest . raises ( value error , match = " compute chunk sizes " ) : da . reshape ( y , ( 5 , 5 ) ) y . compute chunk sizes ( ) da . reshape ( y , ( 5 , 5 ) own y = unknown with pytest . raises ( value error , match = " compute chunk sizes " ) : da . reshape ( y , ( 5 , 5 ) ) y . compute chunk sizes ( ) da . reshape ( y , ( 5 , 5 ) )
k x = np . random . random ( size = ( 30 , 2 ) ) y = da . from array ( x , 3 ) expected = scipy . stats . moment ( x , k ) result = dask . array . stats . moment ( y , k ) assert eq ( result , expected = np . random . random ( size = ( 30 , 2 ) ) y = da . from array ( x , 3 ) expected = scipy . stats . moment ( x , k ) result = dask . array . stats . moment ( y , k ) assert eq ( result , expected )
func , nargs , nan policy with pytest . raises ( not implemented error ) : func ( * ( none , ) * nargs , nan policy = nan policy , nargs , nan policy with pytest . raises ( not implemented error ) : func ( * ( none , ) * nargs , nan policy = nan policy )
def a = np . random . random ( size = 30 ) a = da . from array ( a , 3 ) with pytest . raises ( value error ) : dask . array . stats . power divergence ( a , lambda = " wrong " a = np . random . random ( size = 30 ) a = da . from array ( a , 3 ) with pytest . raises ( value error ) : dask . array . stats . power divergence ( a , lambda = " wrong " )
def a = da . ones ( ( 7 , ) , chunks = ( 7 , ) ) with pytest . raises ( value error , match = " 7 samples " ) : dask . array . stats . skewtest ( a a = da . ones ( ( 7 , ) , chunks = ( 7 , ) ) with pytest . raises ( value error , match = " 7 samples " ) : dask . array . stats . skewtest ( a )
request return np . dtype ( request . param est return np . dtype ( request . param )
dtype , index result = make sliced dtype ( dtype , index ) expected = np . ones ( ( 5 , len ( dtype ) ) , dtype = dtype ) [ index ] . dtype assert result == expectee , index result = make sliced dtype ( dtype , index ) expected = np . ones ( ( 5 , len ( dtype ) ) , dtype = dtype ) [ index ] . dtype assert result == expected
def x = sparse . coo . from numpy ( np . eye ( 10 ) ) d = da . from array ( x , chunks = ( 5 , 5 ) ) assert isinstance ( d . meta , sparse . coo ) assert eq ( d , d ) assert isinstance ( d . compute ( ) , sparse . coo x = sparse . coo . from numpy ( np . eye ( 10 ) ) d = da . from array ( x , chunks = ( 5 , 5 ) ) assert isinstance ( d . meta , sparse . coo ) assert eq ( d , d ) assert isinstance ( d . compute ( ) , sparse . coo )
def x = da . eye ( 10 , chunks = 5 ) y = x . map blocks ( sparse . coo . from numpy , meta = sparse . coo . from numpy ( np . eye ( 1 ) ) ) assert isinstance ( y . meta , sparse . coo ) assert eq ( y , y x = da . eye ( 10 , chunks = 5 ) y = x . map blocks ( sparse . coo . from numpy , meta = sparse . coo . from numpy ( np . eye ( 1 ) ) ) assert isinstance ( y . meta , sparse . coo ) assert eq ( y , y )
start , stop , step , dtype a np = np . arange ( start , stop , step , dtype = dtype ) a da = da . arange ( start , stop , step , dtype = dtype , chunks = 1 ) assert eq ( a np , a da t , stop , step , dtype a np = np . arange ( start , stop , step , dtype = dtype ) a da = da . arange ( start , stop , step , dtype = dtype , chunks = 1 ) assert eq ( a np , a da )
@ darr = da . arange ( 3 . 3 , 9 . 1 , 0 . 25 , chunks = 3 , dtype = " i8 " ) nparr = np . arange ( 3 . 3 , 9 . 1 , 0 . 25 , dtype = " i8 " ) assert eq ( darr , nparr rr = da . arange ( 3 . 3 , 9 . 1 , 0 . 25 , chunks = 3 , dtype = " i8 " ) nparr = np . arange ( 3 . 3 , 9 . 1 , 0 . 25 , dtype = " i8 " ) assert eq ( darr , nparr )
def with pytest . raises ( value error ) : da . indices ( ( 1 , ) , chunks = tuple ( ) with pytest . raises ( value error ) : da . indices ( ( 1 , ) , chunks = tuple ( ) )
def a = np . random . randint ( 0 , 11 , ( 10 , 10 , 10 ) ) d a = da . from array ( a , chunks = ( 5 , 5 , 5 ) ) pytest . raises ( value error , lambda : da . triu ( d a ) a = np . random . randint ( 0 , 11 , ( 10 , 10 , 10 ) ) d a = da . from array ( a , chunks = ( 5 , 5 , 5 ) ) pytest . raises ( value error , lambda : da . triu ( d a ) )
shape , chunks , reps x = np . random . random ( shape ) d = da . from array ( x , chunks = chunks ) with pytest . raises ( value error ) : da . tile ( d , reps e , chunks , reps x = np . random . random ( shape ) d = da . from array ( x , chunks = chunks ) with pytest . raises ( value error ) : da . tile ( d , reps )
shape , chunks , reps x = np . random . random ( shape ) d = da . from array ( x , chunks = chunks ) with pytest . raises ( not implemented error ) : da . tile ( d , reps e , chunks , reps x = np . random . random ( shape ) d = da . from array ( x , chunks = chunks ) with pytest . raises ( not implemented error ) : da . tile ( d , reps )
def assert " this docstring was copied from numpy . array " in da . routines . array . doc assert " create an array . " in da . routines . array . doc assert " this docstring was copied from numpy . array " in da . routines . array . doc assert " create an array . " in da . routines . array . doc
funcname np func = getattr ( np , funcname ) da func = getattr ( da , funcname ) np r n = np func ( ) da r n = da func ( ) assert np r n == da r name np func = getattr ( np , funcname ) da func = getattr ( da , funcname ) np r n = np func ( ) da r n = da func ( ) assert np r n == da r n
def ndim = 27 x = np . broadcast to ( 1 , [ 2 ] * ndim ) dx = da . from array ( x , chunks = 1 ) assert eq ( da . tensordot ( dx , dx , ndim ) , np . array ( 2 ** ndim ) ndim = 27 x = np . broadcast to ( 1 , [ 2 ] * ndim ) dx = da . from array ( x , chunks = 1 ) assert eq ( da . tensordot ( dx , dx , ndim ) , np . array ( 2 ** ndim ) )
shape , axis a = np . random . randint ( 0 , 10 , shape ) d = da . from array ( a , chunks = ( len ( shape ) * ( 5 , ) ) ) assert eq ( da . ptp ( d , axis ) , np . ptp ( a , axis ) e , axis a = np . random . randint ( 0 , 10 , shape ) d = da . from array ( a , chunks = ( len ( shape ) * ( 5 , ) ) ) assert eq ( da . ptp ( d , axis ) , np . ptp ( a , axis ) )
l try : return len ( l ) except type error : return y : return len ( l ) except type error : return 0
def arr = da . from array ( np . arange ( 3 , dtype = np . int64 ) , chunks = 1 ) with ignoring ( import error ) : result = da . isnull ( arr [ 0 ] ) . compute ( ) assert type ( result ) is np . ndarraarr = da . from array ( np . arange ( 3 , dtype = np . int64 ) , chunks = 1 ) with ignoring ( import error ) : result = da . isnull ( arr [ 0 ] ) . compute ( ) assert type ( result ) is np . ndarray
def x = np . array ( list ( " hello world " ) ) d = da . from array ( x , chunks = ( 4 , ) ) x nz = np . argwhere ( x ) d nz = da . argwhere ( d ) assert eq ( d nz , x nz x = np . array ( list ( " hello world " ) ) d = da . from array ( x , chunks = ( 4 , ) ) x nz = np . argwhere ( x ) d nz = da . argwhere ( d ) assert eq ( d nz , x nz )
split every np inputs , da inputs = numpy and dask inputs ( " a " ) assert eq ( np . einsum ( " a " , * np inputs ) , da . einsum ( " a " , * da inputs , split every = split every ) t every np inputs , da inputs = numpy and dask inputs ( " a " ) assert eq ( np . einsum ( " a " , * np inputs ) , da . einsum ( " a " , * da inputs , split every = split every ) )
app app . connect ( " build finished " , copy legacy redirects app . connect ( " build finished " , copy legacy redirects )
width , height d = { ( ' x ' , 0 , i ) : i for i in range ( width ) } for j in range ( 1 , height ) : d . update ( { ( ' x ' , j , i ) : ( noop , ( ' x ' , j 1 , i ) ) for i in range ( width ) } ) return d , [ ( ' x ' , height 1 , i ) for i in range ( width ) ]
loader , standard tests , unused pattern this dir = os . path . dirname ( file ) package tests = loader . discover ( start dir = this dir , pattern = " * test . py " ) standard tests . add tests ( package tests ) return standard tests
d return " {%s} " % " , " . join ( " %s: %s " % ( k , d [ k ] ) for k in sorted ( d , key = d . get , reverse = true ) turn " {%s} " % " , " . join ( " %s: %s " % ( k , d [ k ] ) for k in sorted ( d , key = d . get , reverse = true ) )
self , stage self . time = time . time ( ) self . stage = stag , stage self . time = time . time ( ) self . stage = stage
info , ping if ( info . has field ( " error " ) or info . base build != ping . base build or # different game version info . game duration loops < 1000 or len ( info . player info ) != 2 ) : # probably corrupt , or just not interesting . return false for p in info . player info : if p . player apm < 10 or p . player mmr < 1000 : # low apm = player just standing around . # low mmr = corrupt replay or player who is weak . return false return true
self , s for line in str ( s ) . strip ( ) . splitlines ( ) : print ( " [%s] %s " % ( self . stats . proc id , line ) , s for line in str ( s ) . strip ( ) . splitlines ( ) : print ( " [%s] %s " % ( self . stats . proc id , line ) )
replay queue , replay list for replay path in replay list : replay queue . put ( replay path )
ability return ( ability . friendly name or ability . button name or ability . link name ity return ( ability . friendly name or ability . button name or ability . link name )
data , ability name = generate name ( ability ) if ability . remaps to ability id : general = data . abilities [ ability . remaps to ability id ] name = " %s %s " % ( generate name ( general ) , name ) return nam , ability name = generate name ( ability ) if ability . remaps to ability id : general = data . abilities [ ability . remaps to ability id ] name = " %s %s " % ( generate name ( general ) , name ) return name
unused argv data = get data ( ) print ( " " * 60 ) if flags . command == " csv " : generate csv ( data ) elif flags . command == " python " : generate py abilities ( data ed argv data = get data ( ) print ( " " * 60 ) if flags . command == " csv " : generate csv ( data ) elif flags . command == " python " : generate py abilities ( data )
unused argv for , map class in sorted ( maps . get maps ( ) . items ( ) ) : mp = map class ( ) if mp . path : print ( mp , " \ " ed argv for , map class in sorted ( maps . get maps ( ) . items ( ) ) : mp = map class ( ) if mp . path : print ( mp , " \ " )
def app . run ( main app . run ( main )
args , ** kwargs try : return next ( iter ( get units ( * args , ** kwargs ) . values ( ) ) ) except stop iteration : return none
mask ys , xs = mask . nonzero ( ) return [ point . point ( x , y ) for x , y in zip ( xs , ys ) ]
self , count = 22 self . controller . step ( count ) return self . controller . observe ( , count = 22 self . controller . step ( count ) return self . controller . observe ( )
paths for path in paths : if path . lower ( ) . endswith ( " . sc2replay " ) : yield path else : for f in os . listdir ( path ) : if f . lower ( ) . endswith ( " . sc2replay " ) : yield os . path . join ( path , f )
data print ( " upgrades . py " . center ( 60 , " " ) ) print ( " class upgrades(enum . int enum): " ) print ( ' """ the list of upgrades , as returned from request data . """ ' ) for upgrade in sorted ( data . upgrades , key = lambda a : a . name ) : if upgrade . name and upgrade . upgrade id in static data . upgrades : print ( " %s = %s " % ( upgrade . name , upgrade . upgrade id ) ) print ( " \ " )
unused argv data = get data ( ) generate py units ( data ) generate py buffs ( data ) generate py upgrades ( data ed argv data = get data ( ) generate py units ( data ) generate py buffs ( data ) generate py upgrades ( data )
unused argv if flags . human : human ( ) else : agent ( ed argv if flags . human : human ( ) else : agent ( )
unused argv if flags . human : human ( ) else : agent ( ed argv if flags . human : human ( ) else : agent ( )
def app . run ( main app . run ( main )
def app . run ( main app . run ( main )
def app . run ( main app . run ( main )
self if self . filename : map path = os . path . join ( self . directory , self . filename ) if not map path . endswith ( " . sc2 map " ) : map path += " . sc2 map " return map path
self , run config try : return run config . map data ( self . path , self . players ) except ( io error , os error ) as e : # catch both for python 2/3 compatibility . if self . download and hasattr ( e , " filename " ) : logging . error ( " error reading map ' %s ' from: %s " , self . name , e . filename ) logging . error ( " download the map from: %s " , self . download ) raise
self return self . class . name return self . class . name
cls for s in cls . subclasses ( ) : yield s for c in s . all subclasses ( ) : yield c
def maps = { } for mp in map . all subclasses ( ) : if mp . filename or mp . battle net : map name = mp . name if map name in maps : raise duplicate map error ( " duplicate map found: " + map name ) maps [ map name ] = mp return maps
map name if isinstance ( map name , map ) : return map name maps = get maps ( ) map class = maps . get ( map name ) if map class : return map class ( ) raise no map error ( " map doesn ' t exist: %s " % map name )
self , obs spec , action spec self . obs spec = obs spec self . action spec = action spe , obs spec , action spec self . obs spec = obs spec self . action spec = action spec
self self . episodes += self . episodes += 1
self , obs self . steps += 1 self . reward += obs . reward return actions . function call ( actions . functions . no op . id , [ ] , obs self . steps += 1 self . reward += obs . reward return actions . function call ( actions . functions . no op . id , [ ] )
mask y , x = mask . nonzero ( ) return list ( zip ( x , y ) )
self , obs spec , action spec super ( collect mineral shards feature units , self ) . setup ( obs spec , action spec ) if " feature units " not in obs spec : raise exception ( " this agent requires the feature units observation . " , obs spec , action spec super ( collect mineral shards feature units , self ) . setup ( obs spec , action spec ) if " feature units " not in obs spec : raise exception ( " this agent requires the feature units observation . " )
self super ( collect mineral shards feature units , self ) . reset ( ) self . marine selected = false self . previous mineral xy = [ 1 , 1 super ( collect mineral shards feature units , self ) . reset ( ) self . marine selected = false self . previous mineral xy = [ 1 , 1 ]
self , obs spec , action spec super ( collect mineral shards raw , self ) . setup ( obs spec , action spec ) if " raw units " not in obs spec : raise exception ( " this agent requires the raw units observation . " , obs spec , action spec super ( collect mineral shards raw , self ) . setup ( obs spec , action spec ) if " raw units " not in obs spec : raise exception ( " this agent requires the raw units observation . " )
self super ( collect mineral shards raw , self ) . reset ( ) self . last marine = none self . previous mineral xy = [ 1 , 1 super ( collect mineral shards raw , self ) . reset ( ) self . last marine = none self . previous mineral xy = [ 1 , 1 ]
self , obs spec , action spec super ( defeat roaches raw , self ) . setup ( obs spec , action spec ) if " raw units " not in obs spec : raise exception ( " this agent requires the raw units observation . " , obs spec , action spec super ( defeat roaches raw , self ) . setup ( obs spec , action spec ) if " raw units " not in obs spec : raise exception ( " this agent requires the raw units observation . " )
versions return { ver . game version : ver for ver in versions ions return { ver . game version : ver for ver in versions }
self , map name , players = none map names = [ map name ] if players : map names . append ( os . path . join ( os . path . dirname ( map name ) , " (%s)%s " % ( players , os . path . basename ( map name ) ) ) ) for name in map names : path = os . path . join ( self . data dir , " maps " , name ) if gfile . exists ( path ) : with gfile . open ( path , " rb " ) as f : return f . read ( ) raise value error ( " map ' %s ' not found . " % map name )
self , replay path return os . path . join ( self . replay dir , replay path )
self , replay path with gfile . open ( self . abs replay path ( replay path ) , " rb " ) as f : return f . read ( )
self , replay dir replay dir = self . abs replay path ( replay dir ) if replay dir . lower ( ) . endswith ( " . sc2replay " ) : yield replay dir return for f in gfile . list dir ( replay dir ) : if f . lower ( ) . endswith ( " . sc2replay " ) : yield os . path . join ( replay dir , f )
cls for s in cls . subclasses ( ) : yield s for c in s . all subclasses ( ) : yield c
cls return cls . name return cls . name
self , containing = none if containing is not none and containing not in versions : raise value error ( " unknown game version: %s . known versions: %s . " % ( containing , sorted ( versions . keys ( ) ) ) ) return versions
self , game version if isinstance ( game version , version ) : if not game version . game version : raise value error ( " version ' %r ' supplied without a game version . " % ( game version , ) ) if ( game version . data version and game version . binary and game version . build version ) : return game version # some fields might be missing from serialized versions . look them up . game version = game version . game version if game version . count ( " . " ) == 1 : game version += " . 0 " versions = self . get versions ( containing = game version ) return versions [ game version ]
cls if platform . system ( ) == " windows " : return if platform . system ( ) == " windows " : return 1
cls if sys . platform == " cygwin " : return if sys . platform == " cygwin " : return 1
cls if platform . system ( ) == " linux " : return if platform . system ( ) == " linux " : return 1
addr family = socket . af inet6 if " : " in addr . ip else socket . af inet sock = socket . socket ( family , socket . sock dgram , socket . ipproto udp ) sock . bind ( addr ) return soc family = socket . af inet6 if " : " in addr . ip else socket . af inet sock = socket . socket ( family , socket . sock dgram , socket . ipproto udp ) sock . bind ( addr ) return sock
prefix , msg logging . debug ( " %s: len: %s , hash: %s , msg: 0x%s " , prefix , len ( msg ) , hashlib . md5 ( msg ) . hexdigest ( ) [ : 6 ] , binascii . hexlify ( msg [ : 25 ] ) ix , msg logging . debug ( " %s: len: %s , hash: %s , msg: 0x%s " , prefix , len ( msg ) , hashlib . md5 ( msg ) . hexdigest ( ) [ : 6 ] , binascii . hexlify ( msg [ : 25 ] ) )
udp sock , tcp conn while true : msg , = udp sock . recvfrom ( 2 ** 16 ) log msg ( " read udp " , msg ) if not msg : return write tcp ( tcp conn , msg sock , tcp conn while true : msg , = udp sock . recvfrom ( 2 ** 16 ) log msg ( " read udp " , msg ) if not msg : return write tcp ( tcp conn , msg )
tcp conn , udp sock , udp to addr while true : msg = read tcp ( tcp conn ) if not msg : return log msg ( " write udp " , msg ) udp sock . sendto ( msg , udp to addr conn , udp sock , udp to addr while true : msg = read tcp ( tcp conn ) if not msg : return log msg ( " write udp " , msg ) udp sock . sendto ( msg , udp to addr )
conn read size = read tcp size ( conn , 4 ) if not read size : return size = struct . unpack ( " @ i " , read size ) [ 0 ] msg = read tcp size ( conn , size ) log msg ( " read tcp " , msg ) return ms read size = read tcp size ( conn , 4 ) if not read size : return size = struct . unpack ( " @ i " , read size ) [ 0 ] msg = read tcp size ( conn , size ) log msg ( " read tcp " , msg ) return msg
conn , size chunks = [ ] bytes read = 0 while bytes read < size : chunk = conn . recv ( size bytes read ) if not chunk : if bytes read > 0 : logging . warning ( " incomplete read: %s of %s . " , bytes read , size ) return chunks . append ( chunk ) bytes read += len ( chunk ) return b " " . join ( chunks )
conn , msg log msg ( " write tcp " , msg ) conn . sendall ( struct . pack ( " @ i " , len ( msg ) ) ) conn . sendall ( msg , msg log msg ( " write tcp " , msg ) conn . sendall ( struct . pack ( " @ i " , len ( msg ) ) ) conn . sendall ( msg )
self raise restart error ( " can ' t restart " raise restart error ( " can ' t restart " )
self self . episode steps = 0 return self . step ( [ none ] * self . num agents )
self return self . action spec
self , obs spec , agent index observation = { } for key , spec in obs spec . items ( ) : observation [ key ] = np . zeros ( shape = spec , dtype = np . int32 ) return observation
self , * args , ** kwargs
self return self . step type is step type . firs return self . step type is step type . first
self return self . step type is step type . mi return self . step type is step type . mid
self , array , shape , dtype self . assert sequence equal ( array . shape , shape ) self . assert equal ( array . dtype , dtype , array , shape , dtype self . assert sequence equal ( array . shape , shape ) self . assert equal ( array . dtype , dtype )
self , actual , expected np . testing . assert equal ( actual , expected , actual , expected np . testing . assert equal ( actual , expected )
self , env expected = env . next timestep [ 0 ] . replace ( step type = environment . step type . first , reward = 0 , discount = 0 ) timestep = env . step ( [ mock . sentinel . action ] ) self . assert equal ( timestep , [ expected ] , env expected = env . next timestep [ 0 ] . replace ( step type = environment . step type . first , reward = 0 , discount = 0 ) timestep = env . step ( [ mock . sentinel . action ] ) self . assert equal ( timestep , [ expected ] )
self , env expected = env . next timestep [ 0 ] . replace ( step type = environment . step type . mid ) timestep = env . step ( [ mock . sentinel . action ] ) self . assert equal ( timestep , [ expected ] , env expected = env . next timestep [ 0 ] . replace ( step type = environment . step type . mid ) timestep = env . step ( [ mock . sentinel . action ] ) self . assert equal ( timestep , [ expected ] )
self , env expected = env . next timestep [ 0 ] . replace ( step type = environment . step type . last , discount = 0 . ) timestep = env . step ( [ mock . sentinel . action ] ) self . assert equal ( timestep , [ expected ] , env expected = env . next timestep [ 0 ] . replace ( step type = environment . step type . last , discount = 0 . ) timestep = env . step ( [ mock . sentinel . action ] ) self . assert equal ( timestep , [ expected ] )
self super ( test test environment , self ) . set up ( ) self . env = mock sc2 env . test environment ( num agents = 1 , observation spec = ( { ' mock ' : [ 10 , 1 ] } , ) , action spec = ( mock . sentinel . action spec , ) super ( test test environment , self ) . set up ( ) self . env = mock sc2 env . test environment ( num agents = 1 , observation spec = ( { ' mock ' : [ 10 , 1 ] } , ) , action spec = ( mock . sentinel . action spec , ) )
self self . assert equal ( self . env . observation spec ( ) , ( { ' mock ' : [ 10 , 1 ] } , ) self . assert equal ( self . env . observation spec ( ) , ( { ' mock ' : [ 10 , 1 ] } , ) )
self self . assert equal ( self . env . action spec ( ) , ( mock . sentinel . action spec , ) self . assert equal ( self . env . action spec ( ) , ( mock . sentinel . action spec , ) )
self observation = self . env . default observation ( self . env . observation spec ( ) [ 0 ] , 0 ) self . assert equal ( observation , { ' mock ' : np . zeros ( [ 10 , 1 ] , dtype = np . int32 ) } observation = self . env . default observation ( self . env . observation spec ( ) [ 0 ] , 0 ) self . assert equal ( observation , { ' mock ' : np . zeros ( [ 10 , 1 ] , dtype = np . int32 ) } )
self self . env . episode length = float ( ' inf ' ) self . test episode ( self . env ) self . test episode ( self . env self . env . episode length = float ( ' inf ' ) self . test episode ( self . env ) self . test episode ( self . env )
self self . env . episode length = 16 self . test episode length ( self . env , length = 16 self . env . episode length = 16 self . test episode length ( self . env , length = 16 )
self env = mock sc2 env . sc2 test env ( map name = ' nonexistant map ' , agent interface format = features . agent interface format ( feature dimensions = features . dimensions ( screen = 64 , minimap = 32 ) ) ) env . episode length = float ( ' inf ' ) self . test episode ( env env = mock sc2 env . sc2 test env ( map name = ' nonexistant map ' , agent interface format = features . agent interface format ( feature dimensions = features . dimensions ( screen = 64 , minimap = 32 ) ) ) env . episode length = float ( ' inf ' ) self . test episode ( env )
self , names , expected output self . assert equal ( sc2 env . crop and deduplicate names ( names ) , expected output , names , expected output self . assert equal ( sc2 env . crop and deduplicate names ( names ) , expected output )
self for c in self . controllers : c . close ( ) self . controllers = [ for c in self . controllers : c . close ( ) self . controllers = [ ]
self , ** kwargs if not self . controllers : self . controllers = [ remote controller . remote controller ( p . host , p . port , p , ** kwargs ) for p in self . processes , ** kwargs if not self . controllers : self . controllers = [ remote controller . remote controller ( p . host , p . port , p , ** kwargs ) for p in self . processes ]
self , replay dir , replay name self . reconnect ( ) return self . run config . save replay ( self . controllers [ 0 ] . save replay ( ) , replay dir , replay name , replay dir , replay name self . reconnect ( ) return self . run config . save replay ( self . controllers [ 0 ] . save replay ( ) , replay dir , replay name )
self return [ process . host for process in self . processes ]
self return [ process . port for process in self . processes ]
self return self . lan ports
self try : self . reconnect ( timeout seconds = 1 ) for controller in self . controllers : controller . quit ( ) except ( remote controller . connect error , protocol . connection error ) : pass self . controllers = [ ] for process in self . processes : process . close ( ) self . processes = [ ] portspicker . return ports ( self . lan ports ) self . lan ports = [ ]
self , ** kwargs if not self . controller : self . controller = remote controller . remote controller ( self . process . host , self . process . port , self . process , ** kwargs , ** kwargs if not self . controller : self . controller = remote controller . remote controller ( self . process . host , self . process . port , self . process , ** kwargs )
self , replay dir , replay name self . reconnect ( ) return self . run config . save replay ( self . controller . save replay ( ) , replay dir , replay name , replay dir , replay name self . reconnect ( ) return self . run config . save replay ( self . controller . save replay ( ) , replay dir , replay name )
self return self . process . host
self return self . process . port
self if hasattr ( self , " process " ) and self . process is not none : try : self . reconnect ( timeout seconds = 1 ) self . controller . quit ( ) except ( remote controller . connect error , protocol . connection error ) : pass self . controller = none self . process . close ( ) self . process = none
self , s print ( s , s print ( s )
a , b return b if a is none else b return b if a is none else a
self return self . game info
self return self . controllers [ 0 ] . data ( return self . controllers [ 0 ] . data ( )
self return tuple ( f . observation spec ( ) for f in self . features )
self return tuple ( f . action spec ( ) for f in self . features )
self if not self . realtime : raise value error ( " this method is only supported in realtime mode " ) return self . action delays
self , messages , broadcast = true self . parallel . run ( ( c . chat , message , sc pb . action chat . broadcast if broadcast else sc pb . action chat . team ) for c , message in zip ( self . controllers , messages ) )
cls super ( test compare environments , cls ) . tear down class ( ) cls . env . close ( ) cls . mock env . close ( super ( test compare environments , cls ) . tear down class ( ) cls . env . close ( ) cls . mock env . close ( )
self raise restart error ( " can ' t restart " raise restart error ( " can ' t restart " )
self , * args , ** kwargs return self . env . close ( * args , ** kwargs , * args , ** kwargs return self . env . close ( * args , ** kwargs )
self , * args , ** kwargs return self . env . reset ( * args , ** kwargs , * args , ** kwargs return self . env . reset ( * args , ** kwargs )
self , * args , ** kwargs return self . env . step ( * args , ** kwargs , * args , ** kwargs return self . env . step ( * args , ** kwargs )
self , * args , ** kwargs return self . env . save replay ( * args , ** kwargs , * args , ** kwargs return self . env . save replay ( * args , ** kwargs )
self return self . hos return self . host
self return self . versio return self . version
self , run config , args , ** kwargs del kwargs try : with sw ( " popen " ) : return subprocess . popen ( args , cwd = run config . cwd , env = run config . env ) except os error : logging . exception ( " failed to launch " ) raise sc2 launch error ( " failed to launch: %s " % args )
self if self . proc : ret = shutdown proc ( self . proc , 3 ) logging . info ( " shutdown with return code: %s " , ret ) self . proc = none
self if flags . sc2 port : return true return self . proc and ( self . proc . poll ( ) is none if flags . sc2 port : return true return self . proc and ( self . proc . poll ( ) is none )
self return self . proc . pid if self . running else non return self . proc . pid if self . running else none
p , timeout freq = 10 for in range ( 1 + timeout * freq ) : p . terminate ( ) ret = p . poll ( ) if ret is not none : logging . info ( " shutdown gracefully . " ) return ret time . sleep ( 1 / freq ) logging . warning ( " killing the process . " ) p . kill ( ) return p . wait ( )
self , wait = true if self . executor : self . executor . shutdown ( wait ) self . executor = none self . workers = , wait = true if self . executor : self . executor . shutdown ( wait ) self . executor = none self . workers = 0
self , indices if isinstance ( indices , tuple ) : out = [ ] dim = 0 for i , index in enumerate ( indices ) : if index is ellipsis : out . append ( index ) dim = len ( self . shape ) len ( indices ) + i + 1 elif index is np . newaxis : out . append ( none ) else : out . append ( self . get index ( dim , index ) ) dim += 1 return tuple ( out ) else : return self . get index ( 0 , indices )
self , dim , index if isinstance ( index , six . string types ) : try : return self . index names [ dim ] [ index ] except key error : raise key error ( " name ' %s ' is invalid for axis %s . " % ( index , dim ) ) except type error : raise type error ( " trying to access an unnamed axis %s by name: ' %s ' " % ( dim , index ) ) else : return index
self , frame self . write frame ( frame )
cls , obj return cls ( obj . x , obj . y )
self , obj obj . x = self . x obj . y = self . y
self , other dx = self . x other . x dy = self . y other . y return math . sqrt ( dx ** 2 + dy ** 2 )
self , other dx = self . x other . x dy = self . y other . y return dx ** 2 + dy ** 2
self return point ( int ( round ( self . x ) ) , int ( round ( self . y ) ) )
self return point ( int ( math . floor ( self . x ) ) , int ( math . floor ( self . y ) ) )
self return point ( abs ( self . x ) , abs ( self . y ) )
self , target len return self * ( target len / self . len ( ) )
self , max size return self * ( max size / self ) . min dim ( )
self return min ( self . x , self . y return min ( self . x , self . y )
self return max ( self . x , self . y return max ( self . x , self . y )
self , angle return self . rotate rad ( math . radians ( angle ) , angle return self . rotate rad ( math . radians ( angle ) )
self , angle = 180 return self . rotate deg ( random . uniform ( angle , angle ) , angle = 180 return self . rotate deg ( random . uniform ( angle , angle ) )
self , p1 , p2 = none r = rect ( p1 , p2 ) return point ( min ( max ( self . x , r . l ) , r . r ) , min ( max ( self . y , r . t ) , r . b ) )
self return point ( self . l + self . r , self . t + self . b ) / return point ( self . l + self . r , self . t + self . b ) / 2
self return self . return self . t
self return self . return self . l
self return self . return self . b
self return self . r self . return self . r self . l
self return self . b self . return self . b self . t
self return point ( self . l , self . t return point ( self . l , self . t )
self return point ( self . r , self . b return point ( self . r , self . b )
self return point ( self . r , self . t return point ( self . r , self . t )
self return point ( self . l , self . b return point ( self . l , self . b )
self return point ( self . width , self . height return point ( self . width , self . height )
self return self . br self . t return self . br self . tl
self return rect ( self . tl . round ( ) , self . br . round ( ) return rect ( self . tl . round ( ) , self . br . round ( ) )
self return rect ( self . tl . ceil ( ) , self . br . ceil ( ) return rect ( self . tl . ceil ( ) , self . br . ceil ( ) )
self , pt , radius rect corner = self . size / 2 circle center = ( pt self . center ) . abs ( ) if ( circle center . x > rect corner . x + radius or circle center . y > rect corner . y + radius ) : return false if ( circle center . x <= rect corner . x or circle center . y <= rect corner . y ) : return true return circle center . dist sq ( rect corner ) <= radius ** 2
self super ( available actions test , self ) . set up ( ) self . obs = text format . parse ( observation text proto , sc pb . observation ( ) ) self . hide specific actions ( true super ( available actions test , self ) . set up ( ) self . obs = text format . parse ( observation text proto , sc pb . observation ( ) ) self . hide specific actions ( true )
self , hide specific actions self . features = features . features ( features . agent interface format ( feature dimensions = rectangular dimensions , hide specific actions = hide specific actions ) , hide specific actions self . features = features . features ( features . agent interface format ( feature dimensions = rectangular dimensions , hide specific actions = hide specific actions ) )
self , expected actual = self . features . available actions ( self . obs ) actual names = { actions . functions [ i ] . name for i in actual } self . assert equal ( actual names , set ( expected ) | self . always expected , expected actual = self . features . available actions ( self . obs ) actual names = { actions . functions [ i ] . name for i in actual } self . assert equal ( actual names , set ( expected ) | self . always expected )
self self . assert avail ( [ ] self . assert avail ( [ ] )
self self . obs . player common . idle worker count = 1 self . assert avail ( [ " select idle worker " ] self . obs . player common . idle worker count = 1 self . assert avail ( [ " select idle worker " ] )
self self . obs . player common . army count = 3 self . assert avail ( [ " select army " ] self . obs . player common . army count = 3 self . assert avail ( [ " select army " ] )
self self . obs . player common . warp gate count = 1 self . assert avail ( [ " select warp gates " ] self . obs . player common . warp gate count = 1 self . assert avail ( [ " select warp gates " ] )
self self . obs . player common . larva count = 2 self . assert avail ( [ " select larva " ] self . obs . player common . larva count = 2 self . assert avail ( [ " select larva " ] )
self self . obs . abilities . add ( ability id = 32 ) self . assert avail ( [ " effect salvage quick " ] self . obs . abilities . add ( ability id = 32 ) self . assert avail ( [ " effect salvage quick " ] )
self self . obs . abilities . add ( ability id = 326 , requires point = true ) self . assert avail ( [ " build sensor tower screen " ] self . obs . abilities . add ( ability id = 326 , requires point = true ) self . assert avail ( [ " build sensor tower screen " ] )
self self . obs . abilities . add ( ability id = 17 , requires point = true ) self . assert avail ( [ " patrol screen " , " patrol minimap " ] self . obs . abilities . add ( ability id = 17 , requires point = true ) self . assert avail ( [ " patrol screen " , " patrol minimap " ] )
self self . obs . abilities . add ( ability id = 386 , requires point = true ) self . assert avail ( [ " effect heal screen " , " effect heal autocast " ] self . obs . abilities . add ( ability id = 386 , requires point = true ) self . assert avail ( [ " effect heal screen " , " effect heal autocast " ] )
self self . obs . abilities . add ( ability id = 1374 ) self . hide specific actions ( false ) self . assert avail ( [ " burrow down quick " , " burrow down baneling quick " ] ) self . hide specific actions ( true ) self . assert avail ( [ " burrow down quick " ] self . obs . abilities . add ( ability id = 1374 ) self . hide specific actions ( false ) self . assert avail ( [ " burrow down quick " , " burrow down baneling quick " ] ) self . hide specific actions ( true ) self . assert avail ( [ " burrow down quick " ] )
self value = features . to point ( " 32 " ) self . assert equal ( value , point . point ( 32 , 32 ) value = features . to point ( " 32 " ) self . assert equal ( value , point . point ( 32 , 32 ) )
self value = features . to point ( ( " 32 " , 64 ) ) self . assert equal ( value , point . point ( 32 , 64 ) value = features . to point ( ( " 32 " , 64 ) ) self . assert equal ( value , point . point ( 32 , 64 ) )
self with self . assert raises ( assertion error ) : features . to point ( none with self . assert raises ( assertion error ) : features . to point ( none )
self with self . assert raises ( type error ) : features . to point ( ( none , 32 ) with self . assert raises ( type error ) : features . to point ( ( none , 32 ) )
self with self . assert raises ( type error ) : features . to point ( ( 32 , none ) with self . assert raises ( type error ) : features . to point ( ( 32 , none ) )
self with self . assert raises ( value error ) : features . to point ( ( 32 , 32 , 32 ) with self . assert raises ( value error ) : features . to point ( ( 32 , 32 , 32 ) )
self with self . assert raises ( value error ) : features . dimensions ( screen = 84 with self . assert raises ( value error ) : features . dimensions ( screen = 84 )
self with self . assert raises ( value error ) : features . dimensions ( screen = ( 84 , 0 ) , minimap = 64 with self . assert raises ( value error ) : features . dimensions ( screen = ( 84 , 0 ) , minimap = 64 )
self with self . assert raises ( value error ) : features . dimensions ( screen = ( 84 , 80 ) with self . assert raises ( value error ) : features . dimensions ( screen = ( 84 , 80 ) )
self with self . assert raises ( value error ) : features . dimensions ( screen = none , minimap = none with self . assert raises ( value error ) : features . dimensions ( screen = none , minimap = none )
self with self . assert raises ( value error ) : features . dimensions ( screen = 0 , minimap = 0 with self . assert raises ( value error ) : features . dimensions ( screen = 0 , minimap = 0 )
self with self . assert raises ( value error ) : features . dimensions ( screen = ( 1 , 2 , 3 ) , minimap = 32 with self . assert raises ( value error ) : features . dimensions ( screen = ( 1 , 2 , 3 ) , minimap = 32 )
self with self . assert raises ( value error ) : features . dimensions ( screen = 64 , minimap = 32 with self . assert raises ( value error ) : features . dimensions ( screen = 64 , minimap = 32 )
self with self . assert raises ( value error ) : features . dimensions ( screen = 64 , minimap = 32 with self . assert raises ( value error ) : features . dimensions ( screen = 64 , minimap = 32 )
self with self . assert raises ( value error ) : features . dimensions ( screen = ( 64 , 64 ) , minimap = 32 with self . assert raises ( value error ) : features . dimensions ( screen = ( 64 , 64 ) , minimap = 32 )
self with self . assert raises ( value error ) : features . dimensions ( screen = 64 , minimap = ( 32 , 32 ) with self . assert raises ( value error ) : features . dimensions ( screen = 64 , minimap = ( 32 , 32 ) )
self with self . assert raises ( value error ) : features . parse agent interface format ( with self . assert raises ( value error ) : features . parse agent interface format ( )
self , screen , minimap with self . assert raises ( value error ) : features . parse agent interface format ( feature screen = screen , feature minimap = minimap , screen , minimap with self . assert raises ( value error ) : features . parse agent interface format ( feature screen = screen , feature minimap = minimap )
self , screen , minimap with self . assert raises ( value error ) : features . parse agent interface format ( rgb screen = screen , rgb minimap = minimap , screen , minimap with self . assert raises ( value error ) : features . parse agent interface format ( rgb screen = screen , rgb minimap = minimap )
self with self . assert raises ( key error ) : features . parse agent interface format ( feature screen = 64 , feature minimap = 64 , action space = " unknown action space " with self . assert raises ( key error ) : features . parse agent interface format ( feature screen = 64 , feature minimap = 64 , action space = " unknown action space " )
self agent interface format = features . parse agent interface format ( feature screen = 32 , feature minimap = ( 24 , 24 ) , use feature units = true ) self . assert equal ( agent interface format . use feature units , true agent interface format = features . parse agent interface format ( feature screen = 32 , feature minimap = ( 24 , 24 ) , use feature units = true ) self . assert equal ( agent interface format . use feature units , true )
self for i , f in enumerate ( actions . functions ) : self . assert equal ( i , f . id , " id doesn ' t match for %s " % f . id for i , f in enumerate ( actions . functions ) : self . assert equal ( i , f . id , " id doesn ' t match for %s " % f . id )
self func = actions . functions . select point ( " select " , [ 1 , 2 ] ) self . assert equal ( func , pickle . loads ( pickle . dumps ( func ) ) func = actions . functions . select point ( " select " , [ 1 , 2 ] ) self . assert equal ( func , pickle . loads ( pickle . dumps ( func ) ) )
self arguments = [ numpy . float32 ] * len ( actions . arguments . fields ) dtypes = actions . function call ( function = numpy . float32 , arguments = actions . arguments ( * arguments ) ) self . assert equal ( dtypes , copy . deepcopy ( dtypes ) arguments = [ numpy . float32 ] * len ( actions . arguments . fields ) dtypes = actions . function call ( function = numpy . float32 , arguments = actions . arguments ( * arguments ) ) self . assert equal ( dtypes , copy . deepcopy ( dtypes ) )
self self . assert equal ( str ( proto diff . proto path ( ( " observation " , " actions " ) ) ) , " observation . actions " self . assert equal ( str ( proto diff . proto path ( ( " observation " , " actions " ) ) ) , " observation . actions " )
self self . assert equal ( str ( proto diff . proto path ( [ " observation " , " actions " ] ) ) , " observation . actions " self . assert equal ( str ( proto diff . proto path ( [ " observation " , " actions " ] ) ) , " observation . actions " )
self self . assert equal ( str ( proto diff . proto path ( a for a in " abc " ) ) , " a . b . c " self . assert equal ( str ( proto diff . proto path ( a for a in " abc " ) ) , " a . b . c " )
self self . assert equal ( str ( proto diff . proto path ( ( " observation " , " actions " , 1 , " target " ) ) ) , " observation . actions[1] . target " self . assert equal ( str ( proto diff . proto path ( ( " observation " , " actions " , 1 , " target " ) ) ) , " observation . actions[1] . target " )
self a = proto diff . proto path ( ( " observation " , " actions " , 1 ) ) b = proto diff . proto path ( ( " observation " , " actions " , 1 ) ) self . assert equal ( a , b ) self . assert equal ( hash ( a ) , hash ( b ) a = proto diff . proto path ( ( " observation " , " actions " , 1 ) ) b = proto diff . proto path ( ( " observation " , " actions " , 1 ) ) self . assert equal ( a , b ) self . assert equal ( hash ( a ) , hash ( b ) )
self a = sc pb . response observation ( ) b = sc pb . response observation ( ) diff = proto diff . compute diff ( a , b ) self . assert is none ( diff a = sc pb . response observation ( ) b = sc pb . response observation ( ) diff = proto diff . compute diff ( a , b ) self . assert is none ( diff )
self , num steps = 1 del num steps return event timer ( )
self return event timer ( )
self , obs planes = getattr ( obs . feature layer data , self . layer set ) plane = getattr ( planes , self . name ) return self . unpack layer ( plane )
plane assert plane . bits per pixel == 24 , " {} != 24 " . format ( plane . bits per pixel ) size = point . point . build ( plane . size ) data = np . frombuffer ( plane . data , dtype = np . uint8 ) return data . reshape ( size . y , size . x , 3 )
self return self . scree return self . screen
self return self . minima return self . minimap
self return self . action spac return self . action space
self return self . camera width world unit return self . camera width world units
self return self . use feature unit return self . use feature units
self return self . use raw unit return self . use raw units
self return self . raw resolutio return self . raw resolution
self , value self . raw resolution = valu , value self . raw resolution = value
self return self . use raw action return self . use raw actions
self return self . max raw action return self . max raw actions
self return self . max selected unit return self . max selected units
self return self . use unit count return self . use unit counts
self return self . use camera positio return self . use camera position
self return self . show cloake return self . show cloaked
self return self . show burrowed shadow return self . show burrowed shadows
self return self . show placeholder return self . show placeholders
self return self . hide specific action return self . hide specific actions
self return self . action delay f return self . action delay fn
self return self . send observation prot return self . send observation proto
self return self . add cargo to unit return self . add cargo to units
self return self . crop to playable are return self . crop to playable area
self return self . raw crop to playable are return self . raw crop to playable area
self return self . allow cheating layer return self . allow cheating layers
self , camera center self . world tl to world camera rel . offset = ( self . world to world tl . fwd pt ( camera center ) * self . world tl to world camera rel . scale )
self return self . map siz return self . map size
self return self . requested race return self . requested races
res , error enum if res . has field ( " error " ) : enum name = error enum . descriptor . full name error name = error enum . name ( res . error ) details = getattr ( res , " error details " , " <none> " ) raise request error ( " %s . %s: ' %s ' " % ( enum name , error name , details ) , res ) return res
skipped def decorator ( func ) : @ functools . wraps ( func ) def skip status ( self , * args , ** kwargs ) : if self . status not in skipped : return func ( self , * args , ** kwargs ) return skip status return decorator
valid def decorator ( func ) : @ functools . wraps ( func ) def valid status ( self , * args , ** kwargs ) : if self . status not in valid : raise protocol . protocol error ( " `%s` called while in state: %s , valid: (%s) " % ( func . name , self . status , " , " . join ( map ( str , valid ) ) ) ) return func ( self , * args , ** kwargs ) return valid status return decorator
self self . client . close ( self . client . close ( )
self return self . status == protocol . status . ende return self . status == protocol . status . ended
self , req create game return self . client . send ( create game = req create game )
self , map path , map data return self . client . send ( save map = sc pb . request save map ( map path = map path , map data = map data ) )
self return self . client . send ( restart game = sc pb . request restart game ( ) )
self return self . client . send ( game info = sc pb . request game info ( ) )
self , ability id = true , unit type id = true , upgrade id = true , buff id = true , effect id = true return self . client . send ( data = sc pb . request data ( ability id = ability id , unit type id = unit type id , upgrade id = upgrade id , buff id = buff id , effect id = effect id ) )
self return static data . static data ( self . data raw ( ) )
self return self . client . send ( available maps = sc pb . request available maps ( ) return self . client . send ( available maps = sc pb . request available maps ( ) )
self , count = 1 return self . client . send ( step = sc pb . request step ( count = count ) )
self , req action if flags . sc2 log actions and req action . actions : sys . stderr . write ( " sending actions " . center ( 60 , " > " ) + " \ " ) for action in req action . actions : sys . stderr . write ( str ( action ) ) sys . stderr . flush ( ) return self . client . send ( action = req action )
self , action if action and action . list fields ( ) : # skip no ops . return self . actions ( sc pb . request action ( actions = [ action ] ) )
self , req observer action if flags . sc2 log actions and req observer action . actions : sys . stderr . write ( " sending observer actions " . center ( 60 , " > " ) + " \ " ) for action in req observer action . actions : sys . stderr . write ( str ( action ) ) sys . stderr . flush ( ) return self . client . send ( obs action = req observer action )
self , action if action and action . list fields ( ) : # skip no ops . return self . observer actions ( sc pb . request observer action ( actions = [ action ] ) )
self , message , channel = sc pb . action chat . broadcast if message : action chat = sc pb . action chat ( channel = channel , message = message ) action = sc pb . action ( action chat = action chat ) return self . act ( action )
self return self . client . send ( leave game = sc pb . request leave game ( ) )
self , query return self . client . send ( query = query )
self try : # don ' t expect a response . self . client . write ( sc pb . request ( quit = sc pb . request quit ( ) , id = 999999999 ) ) except protocol . connection error : pass # it ' s likely already (shutting) down , so continue as if it worked . finally : self . close ( )
self , replay data return self . client . send ( replay info = sc pb . request replay info ( replay data = replay data ) , replay data return self . client . send ( replay info = sc pb . request replay info ( replay data = replay data ) )
self return self . client . statu return self . client . status
self self . num = 0 self . min = 1000000000 self . max = 0 self . sum = 0 self . sum sq = self . num = 0 self . min = 1000000000 self . max = 0 self . sum = 0 self . sum sq = 0
self , val self . num += 1 if self . min > val : self . min = val if self . max < val : self . max = val self . sum += val self . sum sq += val ** , val self . num += 1 if self . min > val : self . min = val if self . max < val : self . max = val self . sum += val self . sum sq += val ** 2
self if self . num == 0 : return 0 return math . sqrt ( max ( 0 , self . sum sq / self . num ( self . sum / self . num ) ** 2 ) )
self , other self . num += other . num self . min = min ( self . min , other . min ) self . max = max ( self . max , other . max ) self . sum += other . sum self . sum sq += other . sum s , other self . num += other . num self . min = min ( self . min , other . min ) self . max = max ( self . max , other . max ) self . sum += other . sum self . sum sq += other . sum sq
summation , average , standard deviation , minimum , maximum , number stat = stat ( ) if number > 0 : stat . num = number stat . min = minimum stat . max = maximum stat . sum = summation stat . sum sq = number * ( standard deviation ** 2 + average ** 2 ) return staation , average , standard deviation , minimum , maximum , number stat = stat ( ) if number > 0 : stat . num = number stat . min = minimum stat . max = maximum stat . sum = summation stat . sum sq = number * ( standard deviation ** 2 + average ** 2 ) return stat
s if s == " num=0 " : return stat ( ) parts = ( float ( p . split ( " : " ) [ 1 ] ) for p in s . split ( " , " ) ) return stat . build ( * parts s == " num=0 " : return stat ( ) parts = ( float ( p . split ( " : " ) [ 1 ] ) for p in s . split ( " , " ) ) return stat . build ( * parts )
self , s print ( s , file = sys . stderr , s print ( s , file = sys . stderr )
self self . factory = lambda : fake contex self . factory = lambda : fake context
self self . factory = lambda name : stop watch context ( self , name self . factory = lambda name : stop watch context ( self , name )
self self . factory = lambda name : tracing stop watch context ( self , name self . factory = lambda name : tracing stop watch context ( self , name )
self , factory self . factory = factor , factory self . factory = factory
self , name or func if os . environ . get ( " sc2 no stopwatch " ) : return name or func if callable ( name or func ) else lambda func : func def decorator ( name , func ) : @ functools . wraps ( func ) def stopwatch ( * args , ** kwargs ) : with self ( name ) : return func ( * args , ** kwargs ) return stopwatch if callable ( name or func ) : return decorator ( name or func . name , name or func ) else : return lambda func : decorator ( name or func , func )
self , name try : self . local . stack . append ( name ) except attribute error : # using an exception is faster than using hasattr . self . local . stack = [ name , name try : self . local . stack . append ( name ) except attribute error : # using an exception is faster than using hasattr . self . local . stack = [ name ]
self stack = self . local . stack ret = " . " . join ( stack ) stack . pop ( ) return re stack = self . local . stack ret = " . " . join ( stack ) stack . pop ( ) return ret
self return " . " . join ( self . local . stack return " . " . join ( self . local . stack )
self self . times . clear ( self . times . clear ( )
self , name , duration self . times [ name ] . add ( duration , name , duration self . times [ name ] . add ( duration )
self return self . time return self . times
@ try : yield except websocket . web socket connection closed exception : raise connection error ( " connection already closed . sc2 probably crashed . " " check the error log . " ) except websocket . web socket timeout exception : raise connection error ( " websocket timed out . " ) except socket . error as e : raise connection error ( " socket error: %s " % e )
self return self . statu return self . status
self if self . sock : self . sock . close ( ) self . sock = none self . status = status . qui if self . sock : self . sock . close ( ) self . sock = none self . status = status . quit
self , request self . write ( request ) return self . read ( )
self , packet max lines = flags . sc2 verbose protocol packet str = str ( packet ) . strip ( ) if max lines <= 0 : return packet str lines = packet str . split ( " \ " ) line count = len ( lines ) lines = [ line [ : max width ] for line in lines [ : max lines + 1 ] ] if line count > max lines + 1 : # +1 to prefer the last line to skipped msg . lines [ 1 ] = " ***** %s lines skipped ***** " % ( line count max lines ) return " \ " . join ( lines )
self , s , * args r sys . stderr . write ( ( s + " \ " ) % args ) sys . stderr . flush ( )
self with sw ( " read response " ) : with catch websocket connection errors ( ) : response str = self . sock . recv ( ) if not response str : raise protocol error ( " got an empty response from sc2 . " ) with sw ( " parse response " ) : response = sc pb . response . from string ( response str ) return response
self , request with sw ( " serialize request " ) : request str = request . serialize to string ( ) with sw ( " write request " ) : with catch websocket connection errors ( ) : self . sock . send ( request str )
action , action space if action space == action space . features : return action . action feature layer elif action space == action space . rgb : return action . action render else : raise value error ( " unexpected value for action space: %s " % action space )
action , action space del action , action spacon , action space del action , action space
action , action space , minimap minimap . assign to ( spatial ( action , action space ) . camera move . center minimap )
action , action space , select point act , screen select = spatial ( action , action space ) . unit selection point screen . assign to ( select . selection screen coord ) select . type = select point act
action , action space , select worker del action space action . action ui . select idle worker . type = select worker
action , action space , select add del action space action . action ui . select army . selection add = select add
action , action space , select add del action space action . action ui . select warp gates . selection add = select add
action , action space del action space action . action ui . select larva . set in parent ( )
action , action space , select unit act , select unit id del action space select = action . action ui . multi panel select . type = select unit act select . unit index = select unit id
action , action space , control group act , control group id del action space select = action . action ui . control group select . action = control group act select . control group index = control group id
action , action space , unload id del action space action . action ui . cargo panel . unit index = unload id
action , action space , ability id , queued action cmd = spatial ( action , action space ) . unit command action cmd . ability id = ability id action cmd . queue command = queued
action , action space , ability id , queued , screen action cmd = spatial ( action , action space ) . unit command action cmd . ability id = ability id action cmd . queue command = queued screen . assign to ( action cmd . target screen coord )
action , action space , ability id del action space action . action ui . toggle autocast . ability id = ability id
action , world action cmd = action . action raw . camera move world . assign to ( action cmd . center world space )
action , ability id , queued , unit tags action cmd = action . action raw . unit command action cmd . ability id = ability id action cmd . queue command = queued if not isinstance ( unit tags , ( tuple , list ) ) : unit tags = [ unit tags ] action cmd . unit tags . extend ( unit tags )
action , ability id , queued , unit tags , world action cmd = action . action raw . unit command action cmd . ability id = ability id action cmd . queue command = queued if not isinstance ( unit tags , ( tuple , list ) ) : unit tags = [ unit tags ] action cmd . unit tags . extend ( unit tags ) world . assign to ( action cmd . target world space pos )
action , ability id , queued , unit tags , target unit tag action cmd = action . action raw . unit command action cmd . ability id = ability id action cmd . queue command = queued if not isinstance ( unit tags , ( tuple , list ) ) : unit tags = [ unit tags ] action cmd . unit tags . extend ( unit tags ) action cmd . target unit tag = target unit tag
action , ability id , unit tags action cmd = action . action raw . toggle autocast action cmd . ability id = ability id if not isinstance ( unit tags , ( tuple , list ) ) : unit tags = [ unit tags ] action cmd . unit tags . extend ( unit tags )
cls , options , values names , real = zip ( * options ) del names def factory ( i , name ) : return cls ( i , name , ( len ( real ) , ) , lambda a : real [ a [ 0 ] ] , values , none ) return factory
cls , value return lambda i , name : cls ( i , name , ( value , ) , lambda a : a [ 0 ] , none , none )
cls def factory ( i , name ) : return cls ( i , name , ( 0 , 0 ) , lambda a : point . point ( * a ) . floor ( ) , none , none ) return factory
cls , id , name , sizes return cls ( id , name , sizes , none , none , none )
cls , count , size def clean ( arg ) : arg = numpy to python ( arg ) if isinstance ( arg , list ) and len ( arg ) == 1 and isinstance ( arg [ 0 ] , list ) : arg = arg [ 0 ] # support [[list , of , tags]] . return arg [ : count ] return lambda i , name : cls ( i , name , ( size , ) , clean , none , count )
cls , ** kwargs named = { name : factory ( arguments . fields . index ( name ) , name ) for name , factory in six . iteritems ( kwargs ) } return cls ( ** named )
cls , ** kwargs named = { name : factory ( raw arguments . fields . index ( name ) , name ) for name , factory in six . iteritems ( kwargs ) } return cls ( ** named )
name , options return enum . int enum ( name , { opt name : i for i , ( opt name , ) in enumerate ( options ) } , options return enum . int enum ( name , { opt name : i for i , ( opt name , ) in enumerate ( options ) } )
cls , id , name , function type , avail fn = always return cls ( id , name , 0 , 0 , function type , function types [ function type ] , avail fn , false )
cls , id , name , function type , ability id , general id = 0 assert function type in ability functions return cls ( id , name , ability id , general id , function type , function types [ function type ] , none , false )
cls , id , name , function type , ability id , general id = 0 , avail fn = always assert function type in raw ability functions return cls ( id , name , ability id , general id , function type , function types [ function type ] , avail fn , true )
cls , id , name , function type , avail fn = always return cls ( id , name , 0 , 0 , function type , function types [ function type ] , avail fn , true )
cls , id , name , args return cls ( id , name , none , none , none , args , none , false )
self , space = false return " %s/%s (%s) " % ( str ( int ( self . id ) ) . rjust ( space and 4 ) , self . name . ljust ( space and 50 ) , " ; " . join ( str ( a ) for a in self . args ) )
lock def decorator ( func ) : @ functools . wraps ( func ) def with lock ( * args , ** kwargs ) : with lock : return func ( * args , ** kwargs ) return with lock return decorator
n , smallest , largest return max ( smallest , min ( n , largest ) smallest , largest return max ( smallest , min ( n , largest ) )
self , color , world loc , world radius , start angle , stop angle , thickness = 1 center = self . world to surf . fwd pt ( world loc ) . round ( ) radius = max ( 1 , int ( self . world to surf . fwd dist ( world radius ) ) ) rect = pygame . rect ( center radius , ( radius * 2 , radius * 2 ) ) pygame . draw . arc ( self . surf , color , rect , start angle , stop angle , thickness if thickness < radius else 0 )
self , font , color , world loc , text text surf = font . render ( text , true , color ) rect = text surf . get rect ( ) rect . center = self . world to surf . fwd pt ( world loc ) self . surf . blit ( text surf , rect , font , color , world loc , text text surf = font . render ( text , true , color ) rect = text surf . get rect ( ) rect . center = self . world to surf . fwd pt ( world loc ) self . surf . blit ( text surf , rect )
self , action if self . surf . surf type & surf type . feature : return action . action feature layer elif self . surf . surf type & surf type . rgb : return action . action render else : assert self . surf . surf type & ( surf type . rgb | surf type . feature )
shape , pt , radius y , x = np . ogrid [ pt . y : shape . y pt . y , pt . x : shape . x pt . x ] return x ** 2 + y ** 2 <= radius ** e , pt , radius y , x = np . ogrid [ pt . y : shape . y pt . y , pt . x : shape . x pt . x ] return x ** 2 + y ** 2 <= radius ** 2
self , factor self . window scale *= factor if time . time ( ) self . last zoom time < 1 : # avoid a deadlock in pygame if you zoom too quickly . time . sleep ( time . time ( ) self . last zoom time ) self . init window ( ) self . last zoom time = time . time ( )
self , window pos = none window pos = window pos or pygame . mouse . get pos ( ) window pt = point . point ( * window pos ) + 0 . 5 for surf in reversed ( self . surfaces ) : if ( surf . surf type != surf type . chrome and surf . surf rect . contains point ( window pt ) ) : surf rel pt = window pt surf . surf rect . tl world pt = surf . world to surf . back pt ( surf rel pt ) return mouse pos ( world pt , surf )
self , mouse pos action = sc pb . action ( ) action spatial = mouse pos . action spatial ( action ) mouse pos . obs pos . assign to ( action spatial . camera move . center minimap ) return action
self , world pos action = sc pb . action ( ) world pos . assign to ( action . action raw . camera move . center world space ) return action
self , world pos action = sc pb . observer action ( ) world pos . assign to ( action . camera move . world pos ) return action
self , player id action = sc pb . observer action ( ) action . camera follow player . player id = player id return action
self , ctrl , shift action = sc pb . action ( ) mod = sc ui . action select idle worker if ctrl : select worker = mod . add all if shift else mod . all else : select worker = mod . add if shift else mod . set action . action ui . select idle worker . type = select worker return action
self , shift action = sc pb . action ( ) action . action ui . select army . selection add = shift return action
self , rect player id = self . obs . observation . player common . player id return [ u for u , p in self . visible units ( ) if rect . intersects circle ( p , u . radius ) and u . owner == player id ]
self , surf , name , radius key = ( name , radius ) if key not in self . name lengths : max len = surf . world to surf . fwd dist ( radius * 1 . 6 ) for i in range ( len ( name ) ) : if self . font small . size ( name [ : i + 1 ] ) [ 0 ] > max len : self . name lengths [ key ] = name [ : i ] break else : self . name lengths [ key ] = name return self . name lengths [ key ]
self , surf if not self . help : return def write ( loc , text ) : surf . write screen ( self . font large , colors . black , loc , text ) surf . surf . fill ( colors . white * 0 . 8 ) write ( ( 1 , 1 ) , " shortcuts: " ) max len = max ( len ( s ) for s , in self . shortcuts ) for i , ( hotkey , description ) in enumerate ( self . shortcuts , start = 2 ) : write ( ( 2 , i ) , hotkey ) write ( ( 3 + max len * 0 . 7 , i ) , description )
self , surf if ( self . render rgb and self . obs . observation . has field ( " render data " ) and self . obs . observation . render data . has field ( " map " ) ) : self . draw rendered map ( surf ) else : self . draw base map ( surf ) self . draw effects ( surf ) self . draw units ( surf ) self . draw selection ( surf ) self . draw build target ( surf ) self . draw overlay ( surf ) self . draw commands ( surf ) self . draw panel ( surf )
self , surf , feature layer = feature . unpack ( self . obs . observation ) if layer is not none : surf . blit np array ( feature . color ( layer ) ) else : # ignore layers that aren ' t in this version of sc2 . surf . surf . fill ( colors . black )
self , fn , * args , ** kwargs for surf in self . surfaces : if surf . world to surf : fn ( surf , * args , ** kwargs , fn , * args , ** kwargs for surf in self . surfaces : if surf . world to surf : fn ( surf , * args , ** kwargs )
self , obs if not self . initialized : return now = time . time ( ) self . game times . append ( ( now self . last time , max ( 1 , obs . observation . game loop self . obs . observation . game loop ) ) ) self . last time = now self . last game loop = self . obs . observation . game loop self . obs queue . put ( obs ) if self . render sync : self . obs queue . join ( )
unit id for race in ( neutral , protoss , terran , zerg ) : try : return race ( unit id ) except value error : pas id for race in ( neutral , protoss , terran , zerg ) : try : return race ( unit id ) except value error : pass
self self . cond . acquire ( ) me = self . count self . count += 1 if self . count < self . n : self . cond . wait ( ) else : self . count = 0 self . cond . notify all ( ) self . cond . release ( ) return m self . cond . acquire ( ) me = self . count self . count += 1 if self . count < self . n : self . cond . wait ( ) else : self . count = 0 self . cond . notify all ( ) self . cond . release ( ) return me
self self . cond . acquire ( ) self . cond . notify all ( ) self . cond . release ( self . cond . acquire ( ) self . cond . notify all ( ) self . cond . release ( )
def raise value error ( raise value error ( )
self b = barrier ( 3 ) pool = run parallel . run parallel ( ) out = pool . run ( [ b . wait , b . wait , b . wait ] ) self . assert items equal ( out , [ 0 , 1 , 2 ] b = barrier ( 3 ) pool = run parallel . run parallel ( ) out = pool . run ( [ b . wait , b . wait , b . wait ] ) self . assert items equal ( out , [ 0 , 1 , 2 ] )
self b = barrier ( 2 ) pool = run parallel . run parallel ( timeout = 2 ) with self . assert raises ( value error ) : pool . run ( [ int , b . wait , bad ] ) b . clear ( b = barrier ( 2 ) pool = run parallel . run parallel ( timeout = 2 ) with self . assert raises ( value error ) : pool . run ( [ int , b . wait , bad ] ) b . clear ( )
self , r = none , g = none , b = none return color ( r or self . r , b or self . b , g or self . g , r = none , g = none , b = none return color ( r or self . r , b or self . b , g or self . g )
self return color ( int ( round ( self . r ) ) , int ( round ( self . g ) ) , int ( round ( self . b ) ) return color ( int ( round ( self . r ) ) , int ( round ( self . g ) ) , int ( round ( self . b ) ) )
self return color ( int ( math . ceil ( self . r ) ) , int ( math . ceil ( self . g ) ) , int ( math . ceil ( self . b ) ) return color ( int ( math . ceil ( self . r ) ) , int ( math . ceil ( self . g ) ) , int ( math . ceil ( self . b ) ) )
scale palette = list ( smooth hue palette ( scale ) ) random . shuffle ( palette , lambda : 0 . 5 ) return numpy . array ( palette e palette = list ( smooth hue palette ( scale ) ) random . shuffle ( palette , lambda : 0 . 5 ) return numpy . array ( palette )
scale = none return categorical ( static data . buffs , scale )
options , scale = none palette size = scale or max ( options ) + 1 palette = shuffled hue ( palette size ) assert len ( options ) <= len ( distinct colors ) for i , v in enumerate ( options ) : palette [ v ] = distinct colors [ i ] return palettons , scale = none palette size = scale or max ( options ) + 1 palette = shuffled hue ( palette size ) assert len ( options ) <= len ( distinct colors ) for i , v in enumerate ( options ) : palette [ v ] = distinct colors [ i ] return palette
self return self . upgrade return self . upgrades
self return self . unit return self . units
self return self . unit stat return self . unit stats
self return self . general abilitie return self . general abilities
self return " pysc2 . lib . point . point " return " pysc2 . lib . point . point "
self , value return str ( value , value return str ( value )
name , default , help string , flag values = flags . flags , ** args flags . define ( point parser ( ) , name , default , help string , flag values , point serializer ( ) , ** args )
self , num ports reserved = portspicker . pick unused ports ( num ports ) self . assert len ( reserved , num ports ) portspicker . return ports ( reserved , num ports reserved = portspicker . pick unused ports ( num ports ) self . assert len ( reserved , num ports ) portspicker . return ports ( reserved )
self with self . assert raises ( value error ) : portspicker . pick unused ports ( 0 with self . assert raises ( value error ) : portspicker . pick unused ports ( 0 )
self with self . assert raises ( value error ) : portspicker . pick contiguous unused ports ( 0 with self . assert raises ( value error ) : portspicker . pick contiguous unused ports ( 0 )
self self . assert equal ( point . point ( 5 , 8 ) , point . point . build ( fake point ( ) ) self . assert equal ( point . point ( 5 , 8 ) , point . point . build ( fake point ( ) ) )
self f = fake point ( ) self . assert equal ( 5 , f . x ) self . assert equal ( 8 , f . y ) point . point ( 1 , 2 ) . assign to ( f ) self . assert equal ( 1 , f . x ) self . assert equal ( 2 , f . y f = fake point ( ) self . assert equal ( 5 , f . x ) self . assert equal ( 8 , f . y ) point . point ( 1 , 2 ) . assign to ( f ) self . assert equal ( 1 , f . x ) self . assert equal ( 2 , f . y )
self a = point . point ( 1 , 1 ) b = point . point ( 4 , 5 ) self . assert equal ( 5 , a . dist ( b ) a = point . point ( 1 , 1 ) b = point . point ( 4 , 5 ) self . assert equal ( 5 , a . dist ( b ) )
self a = point . point ( 1 , 1 ) b = point . point ( 4 , 5 ) self . assert equal ( 25 , a . dist sq ( b ) a = point . point ( 1 , 1 ) b = point . point ( 4 , 5 ) self . assert equal ( 25 , a . dist sq ( b ) )
self p = point . point ( 3 , 4 ) self . assert equal ( 5 , p . len ( ) p = point . point ( 3 , 4 ) self . assert equal ( 5 , p . len ( ) )
self p = point . point ( 3 , 4 ) self . assert almost equal ( 2 , p . scale ( 2 ) . len ( ) p = point . point ( 3 , 4 ) self . assert almost equal ( 2 , p . scale ( 2 ) . len ( ) )
self self . assert equal ( 10 , point . point ( 5 , 10 ) . max dim ( ) self . assert equal ( 10 , point . point ( 5 , 10 ) . max dim ( ) )
self p = point . point ( 1 . 3 , 2 . 6 ) . round ( ) self . assert equal ( point . point ( 1 , 3 ) , p ) self . assert is instance ( p . x , int ) self . assert is instance ( p . y , int p = point . point ( 1 . 3 , 2 . 6 ) . round ( ) self . assert equal ( point . point ( 1 , 3 ) , p ) self . assert is instance ( p . x , int ) self . assert is instance ( p . y , int )
self p = point . point ( 1 . 3 , 2 . 6 ) . ceil ( ) self . assert equal ( point . point ( 2 , 3 ) , p ) self . assert is instance ( p . x , int ) self . assert is instance ( p . y , int p = point . point ( 1 . 3 , 2 . 6 ) . ceil ( ) self . assert equal ( point . point ( 2 , 3 ) , p ) self . assert is instance ( p . x , int ) self . assert is instance ( p . y , int )
self p = point . point ( 1 . 3 , 2 . 6 ) . floor ( ) self . assert equal ( point . point ( 1 , 2 ) , p ) self . assert is instance ( p . x , int ) self . assert is instance ( p . y , int p = point . point ( 1 . 3 , 2 . 6 ) . floor ( ) self . assert equal ( point . point ( 1 , 2 ) , p ) self . assert is instance ( p . x , int ) self . assert is instance ( p . y , int )
self self . assert true ( point . point ( 2 , 2 ) . contained circle ( point . point ( 1 , 1 ) , 2 ) ) self . assert false ( point . point ( 2 , 2 ) . contained circle ( point . point ( 1 , 1 ) , 0 . 5 ) self . assert true ( point . point ( 2 , 2 ) . contained circle ( point . point ( 1 , 1 ) , 2 ) ) self . assert false ( point . point ( 2 , 2 ) . contained circle ( point . point ( 1 , 1 ) , 0 . 5 ) )
self r = point . rect ( point . point ( 1 , 1 ) , point . point ( 3 , 4 ) ) self . assert equal ( r . area , 6 r = point . rect ( point . point ( 1 , 1 ) , point . point ( 3 , 4 ) ) self . assert equal ( r . area , 6 )
self result = image differencer . image differencer ( path = proto diff . proto path ( ( " observation " , " actions " , 1 ) ) , proto a = none , proto b = none ) self . assert is none ( result result = image differencer . image differencer ( path = proto diff . proto path ( ( " observation " , " actions " , 1 ) ) , proto a = none , proto b = none ) self . assert is none ( result )
func class memodict ( dict ) : """ a memoization decorator dict . """ slots = ( ) name = func . name doc = func . doc def call ( self , * args ) : return self [ args ] def missing ( self , args ) : ret = self [ args ] = func ( * args ) return ret return memodict ( )
self , pt raise not implemented error ( , pt raise not implemented error ( )
self , dist raise not implemented error ( , dist raise not implemented error ( )
self , pt raise not implemented error ( , pt raise not implemented error ( )
self , dist return dist * self . scale . , dist return dist * self . scale . x
self , pt return pt * self . scale + self . offse , pt return pt * self . scale + self . offset
self , dist return dist / self . scale . , dist return dist / self . scale . x
self , pt return ( pt self . offset ) / self . scal , pt return ( pt self . offset ) / self . scale
self , dist for transform in self . transforms : dist = transform . fwd dist ( dist ) return dis , dist for transform in self . transforms : dist = transform . fwd dist ( dist ) return dist
self , pt for transform in self . transforms : pt = transform . fwd pt ( pt ) return p , pt for transform in self . transforms : pt = transform . fwd pt ( pt ) return pt
self , dist for transform in reversed ( self . transforms ) : dist = transform . back dist ( dist ) return dis , dist for transform in reversed ( self . transforms ) : dist = transform . back dist ( dist ) return dist
self , dist return dis , dist return dist
self , pt return pt . floor ( , pt return pt . floor ( )
path , proto a , proto b if path [ 1 ] == " data " and len ( path ) >= 2 : image data path = proto diff . proto path ( path [ : 1 ] ) image data a = image data path . get field ( proto a ) if isinstance ( image data a , common pb2 . image data ) : image data b = image data path . get field ( proto b ) image a = features . feature . unpack layer ( image data a ) image b = features . feature . unpack layer ( image data b ) return np util . summarize array diffs ( image a , image b ) return none
self sw = stopwatch . stop watch ( ) with sw ( " zero " ) : pass self . assert in ( " zero " , str ( sw ) sw = stopwatch . stop watch ( ) with sw ( " zero " ) : pass self . assert in ( " zero " , str ( sw ) )
self sw = stopwatch . stop watch ( ) self . assert not equal ( round , sw . decorate ( round ) ) self . assert not equal ( round , sw . decorate ( " name " ) ( round ) sw = stopwatch . stop watch ( ) self . assert not equal ( round , sw . decorate ( round ) ) self . assert not equal ( round , sw . decorate ( " name " ) ( round ) )
self , lhs , rhs , expected a = np . array ( lhs ) b = np . array ( rhs ) result = np util . summarize array diffs ( a , b ) self . assert equal ( result , expected , lhs , rhs , expected a = np . array ( lhs ) b = np . array ( rhs ) result = np util . summarize array diffs ( a , b ) self . assert equal ( result , expected )
self return proto path ( tuple ( array placeholder if isinstance ( t , int ) else t for t in self . path ) )
self return self . pat return self . path
self return self . proto return self . proto b
self return self . change return self . changed
self return self . adde return self . added
self return self . changed + self . added + self . remove return self . changed + self . added + self . removed
val , truncate to string val = str ( val ) if truncate to and len ( string val ) > truncate to : return string val [ : max ( truncate to 3 , 0 ) ] + " . . . " else : return string va , truncate to string val = str ( val ) if truncate to and len ( string val ) > truncate to : return string val [ : max ( truncate to 3 , 0 ) ] + " . . . " else : return string val
dict path dict path = dict path [ 5 : 1 ] keys = dict path . split ( " ][ " ) return proto path ( ( k [ 1 : 1 ] if k [ 0 ] == " ' " else int ( k ) ) for k in keys path dict path = dict path [ 5 : 1 ] keys = dict path . split ( " ][ " ) return proto path ( ( k [ 1 : 1 ] if k [ 0 ] == " ' " else int ( k ) ) for k in keys )
self , unit proto unit proto . unit type = self . unit type unit proto . player relative = self . player relative unit proto . health = self . health unit proto . shields = self . shields unit proto . energy = self . energy unit proto . transport slots taken = self . transport slots taken unit proto . build progress = self . build progress
self return np . array ( [ self . unit type , self . player relative , self . health , self . shields , self . energy , self . transport slots taken , int ( self . build progress * 100 ) ] , dtype = np . int32 )
self return vars ( self return vars ( self )
self return vars ( self return vars ( self )
self , game loop self . game loop = game loop return sel , game loop self . game loop = game loop return self
self , player id = none , minerals = none , vespene = none , food cap = none , food used = none , food army = none , food workers = none , idle worker count = none , army count = none , warp gate count = none , larva count = none args = dict ( locals ( ) ) for key , value in six . iteritems ( args ) : if value is not none and key != ' self ' : setattr ( self . player common , key , value ) return self
self , score self . score = score return sel , score self . score = score return self
self , idle production time = none , idle worker time = none , total value units = none , total value structures = none , killed value units = none , killed value structures = none , collected minerals = none , collected vespene = none , collection rate minerals = none , collection rate vespene = none , spent minerals = none , spent vespene = none args = dict ( locals ( ) ) for key , value in six . iteritems ( args ) : if value is not none and key != ' self ' : setattr ( self . score details , key , value ) return self
self , entry name , none , army , economy , technology , upgrade field = getattr ( self . score details , entry name ) field . copy from ( score pb2 . category score details ( none = none , army = army , economy = economy , technology = technology , upgrade = upgrade ) , entry name , none , army , economy , technology , upgrade field = getattr ( self . score details , entry name ) field . copy from ( score pb2 . category score details ( none = none , army = army , economy = economy , technology = technology , upgrade = upgrade ) )
self , entry name , life , shields , energy field = getattr ( self . score details , entry name ) field . copy from ( score pb2 . vital score details ( life = life , shields = shields , energy = energy ) , entry name , life , shields , energy field = getattr ( self . score details , entry name ) field . copy from ( score pb2 . vital score details ( life = life , shields = shields , energy = energy ) )
self , units self . multi select = units return sel , units self . multi select = units return self
self , build queue , production = none self . build queue = build queue self . production = production return sel , build queue , production = none self . build queue = build queue self . production = production return self
self , feature units self . feature units = feature units return sel , feature units self . feature units = feature units return self
obs return list ( filter ( none , ( a . action raw . unit command . ability id for a in obs . actions ) ) return list ( filter ( none , ( a . action raw . unit command . ability id for a in obs . actions ) ) )
stage logging . info ( ( " %s " % stage ) . center ( 80 , " " ) e logging . info ( ( " %s " % stage ) . center ( 80 , " " ) )
self super ( test case , self ) . set up ( ) stopwatch . sw . clear ( ) stopwatch . sw . enable ( super ( test case , self ) . set up ( ) stopwatch . sw . clear ( ) stopwatch . sw . enable ( )
self super ( test case , self ) . tear down ( ) s = str ( stopwatch . sw ) if s : logging . info ( " stop watch profile:\%s " , s ) stopwatch . sw . disable ( super ( test case , self ) . tear down ( ) s = str ( stopwatch . sw ) if s : logging . info ( " stop watch profile:\%s " , s ) stopwatch . sw . disable ( )
obs , filter fn = none , owner = none , unit type = none , tag = none if unit type and not isinstance ( unit type , ( list , tuple ) ) : unit type = ( unit type , ) out = { } for u in obs . observation . raw data . units : if ( ( filter fn is none or filter fn ( u ) ) and ( owner is none or u . owner == owner ) and ( unit type is none or u . unit type in unit type ) and ( tag is none or u . tag == tag ) ) : out [ u . tag ] = u return out
mask ys , xs = mask . nonzero ( ) return [ point . point ( x , y ) for x , y in zip ( xs , ys ) ]
func @ functools . wraps ( func ) def decorator ( self , * args , ** kwargs ) : if self . in game : return func ( self , * args , ** kwargs ) return decorato @ functools . wraps ( func ) def decorator ( self , * args , ** kwargs ) : if self . in game : return func ( self , * args , ** kwargs ) return decorator
self self . step ( 300 ) replay data = self . controllers [ 0 ] . save replay ( ) self . parallel . run ( c . leave for c in self . controllers ) for player id , controller in enumerate ( self . controllers ) : controller . start replay ( sc pb . request start replay ( replay data = replay data , map data = self . map data , options = self . interface , disable fog = self . disable fog , observed player id = player id + 1 ) ) self . in game = false self . step ( )
self , disable fog = false return self . parallel . run ( ( c . observe , disable fog ) for c in self . controllers , disable fog = false return self . parallel . run ( ( c . observe , disable fog ) for c in self . controllers )
self , x , y action = sc pb . action ( ) action . action raw . camera move . center world space . x = x action . action raw . camera move . center world space . y = y return self . parallel . run ( ( c . act , action ) for c in self . controllers , x , y action = sc pb . action ( ) action . action raw . camera move . center world space . x = x action . action raw . camera move . center world space . y = y return self . parallel . run ( ( c . act , action ) for c in self . controllers )
self , player = 0 , ** kwargs self . controllers [ player ] . debug ( [ sc debug . debug command ( ** kwargs ) ] , player = 0 , ** kwargs self . controllers [ player ] . debug ( [ sc debug . debug command ( ** kwargs ) ] )
self , unit tags if not isinstance ( unit tags , ( list , tuple ) ) : unit tags = [ unit tags ] return self . debug ( kill unit = sc debug . debug kill unit ( tag = unit tags ) , unit tags if not isinstance ( unit tags , ( list , tuple ) ) : unit tags = [ unit tags ] return self . debug ( kill unit = sc debug . debug kill unit ( tag = unit tags ) )
self , tag , energy self . debug ( unit value = sc debug . debug set unit value ( unit value = sc debug . debug set unit value . energy , value = energy , unit tag = tag ) , tag , energy self . debug ( unit value = sc debug . debug set unit value ( unit value = sc debug . debug set unit value . energy , value = energy , unit tag = tag ) )
self , proto pos , pos self . assert almost equal ( proto pos . x , pos [ 0 ] ) self . assert almost equal ( proto pos . y , pos [ 1 ] , proto pos , pos self . assert almost equal ( proto pos . x , pos [ 0 ] ) self . assert almost equal ( proto pos . y , pos [ 1 ] )
count = none , filter fn = none all maps = { k : v for k , v in maps . get maps ( ) . items ( ) if filter fn is none or filter fn ( v ) } count = count or len ( all maps ) return sorted ( random . sample ( all maps . keys ( ) , min ( count , len ( all maps ) ) ) )
func @ functools . wraps ( func ) def cache sc2 proc ( self , * args , ** kwargs ) : global sc2 proc if not sc2 proc : sc2 proc = run configs . get ( ) . start ( want rgb = false ) try : func ( self , sc2 proc . controller , * args , ** kwargs ) except : # pylint: disable=bare except sc2 proc . close ( ) sc2 proc = none raise return cache sc2 proc
cls global sc2 proc if sc2 proc : sc2 proc . close ( ) sc2 proc = none super ( maps test , cls ) . tear down class ( global sc2 proc if sc2 proc : sc2 proc . close ( ) sc2 proc = none super ( maps test , cls ) . tear down class ( )
self , map name run config = run configs . get ( ) map inst = maps . get ( map name ) logging . info ( " map: %s " , map inst . name ) self . assert is not none ( map inst . players ) self . assert greater equal ( map inst . players , 1 ) self . assert less equal ( map inst . players , 8 ) self . assert true ( map inst . data ( run config ) , msg = " failed on %s " % map inst )
self obs = self . get obs ( ) for f in features . screen features : self . check layer ( getattr ( obs . feature layer data . renders , f . name ) , 64 , 60 , 8 obs = self . get obs ( ) for f in features . screen features : self . check layer ( getattr ( obs . feature layer data . renders , f . name ) , 64 , 60 , 8 )
self obs = self . get obs ( ) for f in features . minimap features : self . check layer ( getattr ( obs . feature layer data . minimap renders , f . name ) , 32 , 28 , 8 obs = self . get obs ( ) for f in features . minimap features : self . check layer ( getattr ( obs . feature layer data . minimap renders , f . name ) , 32 , 28 , 8 )
self obs = self . get obs ( ) self . check layer ( obs . render data . map , 128 , 124 , 24 obs = self . get obs ( ) self . check layer ( obs . render data . map , 128 , 124 , 24 )
self self . builder . game loop ( 1234 ) obs = self . get obs ( ) self . assert equal ( obs . game loop , 1234 self . builder . game loop ( 1234 ) obs = self . get obs ( ) self . assert equal ( obs . game loop , 1234 )
self self . builder . score ( 54321 ) obs = self . get obs ( ) self . assert equal ( obs . score . score , 54321 self . builder . score ( 54321 ) obs = self . get obs ( ) self . assert equal ( obs . score . score , 54321 )
self np . testing . assert array equal ( self . obs spec . score by category , np . array ( [ 11 , 5 ] , dtype = np . int32 ) np . testing . assert array equal ( self . obs spec . score by category , np . array ( [ 11 , 5 ] , dtype = np . int32 ) )
self np . testing . assert array equal ( self . obs spec . score by vital , np . array ( [ 3 , 3 ] , dtype = np . int32 ) np . testing . assert array equal ( self . obs spec . score by vital , np . array ( [ 3 , 3 ] , dtype = np . int32 ) )
self obs = self . get obs ( ) self . check layer ( obs . render data . minimap , 64 , 60 , 24 obs = self . get obs ( ) self . check layer ( obs . render data . minimap , 64 , 60 , 24 )
self obs = self . get obs ( ) self . assert false ( obs . ui data . has field ( " single " ) obs = self . get obs ( ) self . assert false ( obs . ui data . has field ( " single " ) )
self self . builder . single select ( probe ) obs = self . get obs ( ) self . check unit ( obs . ui data . single . unit , probe self . builder . single select ( probe ) obs = self . get obs ( ) self . check unit ( obs . ui data . single . unit , probe )
self obs = self . get obs ( ) self . assert false ( obs . ui data . has field ( " multi " ) obs = self . get obs ( ) self . assert false ( obs . ui data . has field ( " multi " ) )
self , a , b , attributes for attribute in attributes : self . assert equal ( getattr ( a , attribute ) , getattr ( b , attribute ) , a , b , attributes for attribute in attributes : self . assert equal ( getattr ( a , attribute ) , getattr ( b , attribute ) )
self , proto , builder return self . check attributes match ( proto , builder , vars ( builder ) . keys ( ) , proto , builder return self . check attributes match ( proto , builder , vars ( builder ) . keys ( ) )
self , proto , builder return self . check attributes match ( proto , builder , [ " unit type " , " alliance " , " owner " , " pos " , " radius " , " health " , " health max " , " is on screen " , " shield " , " shield max " ] , proto , builder return self . check attributes match ( proto , builder , [ " unit type " , " alliance " , " owner " , " pos " , " radius " , " health " , " health max " , " is on screen " , " shield " , " shield max " ] )
name , args return lambda : actions . functions [ name ] ( * args , args return lambda : actions . functions [ name ] ( * args )
unit type , obs unit layer = obs . feature screen . unit type y , x = ( unit layer == unit type ) . nonzero ( ) if not y . any ( ) : return none , none return [ x [ 1 ] , y [ 1 ] type , obs unit layer = obs . feature screen . unit type y , x = ( unit layer == unit type ) . nonzero ( ) if not y . any ( ) : return none , none return [ x [ 1 ] , y [ 1 ] ]
func , unit type return lambda o : actions . functions . select point ( ' select ' , func ( unit type , o ) , unit type return lambda o : actions . functions . select point ( ' select ' , func ( unit type , o ) )
self run config = run configs . get ( ) self . map inst = maps . get ( self . config . map name ) self . map data = self . map inst . data ( run config ) self . sc2 proc = run config . start ( want rgb = self . config . interface . has field ( ' render ' ) ) self . controller = self . sc2 proc . controller
self return self . controlle return self . controller
self config = config ( ) with game controller ( config ) as game controller : game controller . create game ( ) replay data , observations = self . get replay data ( game controller . controller , config ) game controller . start replay ( replay data ) self . process replay ( game controller . controller , observations , config config = config ( ) with game controller ( config ) as game controller : game controller . create game ( ) replay data , observations = self . get replay data ( game controller . controller , config ) game controller . start replay ( replay data ) self . process replay ( game controller . controller , observations , config )
v return " . " . join ( v . split ( " . " ) [ : 2 ] turn " . " . join ( v . split ( " . " ) [ : 2 ] )
s , * args logging . info ( ( ( " " + s + " " ) % args ) . center ( 80 , " " ) * args logging . info ( ( ( " " + s + " " ) % args ) . center ( 80 , " " ) )
path norm path = os . path . normpath ( path ) return norm path . replace ( ' \\\\ ' , ' \\\\\\\\ ' norm path = os . path . normpath ( path ) return norm path . replace ( ' \\\\ ' , ' \\\\\\\\ ' )
fb fb . cmdqueue . append ( " retarget " ) while 1 : try : fb . cmdloop ( ) except exception . interpreter : do interactive ( fb ) else : breab . cmdqueue . append ( " retarget " ) while 1 : try : fb . cmdloop ( ) except exception . interpreter : do interactive ( fb ) else : break
config , fbdir , logdir global fb fb = fuzzbunch ( config , fbdir , logdir ) fb . printbanner ( ) load plugins ( fb ) main ( fb ig , fbdir , logdir global fb fb = fuzzbunch ( config , fbdir , logdir ) fb . printbanner ( ) load plugins ( fb ) main ( fb )
location , ext return [ file for file in os . listdir ( location ) if file . endswith ( ext ) tion , ext return [ file for file in os . listdir ( location ) if file . endswith ( ext ) ]
configlist , item for file in configlist : if file . startswith ( item ) : return configlist . index ( file ) return noniglist , item for file in configlist : if file . startswith ( item ) : return configlist . index ( file ) return none
xml doc , tag try : elements = xml doc . get elements by tag name ( tag ) if len ( elements ) == 0 : elements = xml doc . get elements by tag name ( " t: " + tag ) return elements except : return [ oc , tag try : elements = xml doc . get elements by tag name ( tag ) if len ( elements ) == 0 : elements = xml doc . get elements by tag name ( " t: " + tag ) return elements except : return [ ]
xml file try : xml document = xml . dom . minidom . parse ( xml file ) elem = get elements ( xml document , " consolemode " ) [ 0 ] # fix to bug #574 #elem = xml document . get elements by tag name( " t:consolemode " )[0] return str ( elem . get attribute ( " value " ) ) except index error : return " " return " "
xml file xml document = xml . dom . minidom . parse ( xml file ) try : #iparams = xml document . get elements by tag name( " t:inputparameters " )[0] iparams = get elements ( xml document , " inputparameters " ) [ 0 ] # fix to bug #574 except index error : return [ ] order = [ ] for param in ( get elements ( iparams , " parameter " ) + get elements ( iparams , " paramchoice " ) ) : order . append ( str ( param . get attribute ( " name " ) ) ) return order
xml file xmldoc = element tree . parse ( xml file ) arches = { } for arch in xmldoc . findall ( " package/arch " ) : proxy = getattr ( arch . find ( ' base ' ) , ' text ' , none ) core = getattr ( arch . find ( ' core ' ) , ' text ' , none ) arches [ arch . get ( ' name ' ) ] = ( proxy , core ) return arches
val if val in ( " 1 " , 1 , " true " , " true " ) : return " yes " else : return " no "if val in ( " 1 " , 1 , " true " , " true " ) : return " yes " else : return " no "
self , l if l [ 0 ] != ' [ ' or l [ 1 ] != ' ] ' : return none l = l [ 1 : 1 ] return [ x . strip ( ) for x in l . split ( ' , ' ) , l if l [ 0 ] != ' [ ' or l [ 1 ] != ' ] ' : return none l = l [ 1 : 1 ] return [ x . strip ( ) for x in l . split ( ' , ' ) ]
self return trch . parameter get description ( self . param return trch . parameter get description ( self . param )
self return trch . parameter get format ( self . param return trch . parameter get format ( self . param )
self return trch . parameter get name ( self . param return trch . parameter get name ( self . param )
self return trch . parameter get type ( self . param return trch . parameter get type ( self . param )
self return trch . parameter get marshalled default ( self . param return trch . parameter get marshalled default ( self . param )
self return trch . parameter has value ( self . param return trch . parameter has value ( self . param )
self return [ return [ ]
self return [ o param ( self . get name ( ) , self . get value ( ) , self . get type ( ) , self . get format ( ) ) return [ o param ( self . get name ( ) , self . get value ( ) , self . get type ( ) , self . get format ( ) ) ]
self return trch . parameter is hidden ( self . param return trch . parameter is hidden ( self . param )
self return trch . parameter is required ( self . param return trch . parameter is required ( self . param )
self return trch . parameter is valid ( self . param return trch . parameter is valid ( self . param )
self trch . parameter mark invalid ( self . param trch . parameter mark invalid ( self . param )
self , name return trch . parameter match name ( self . param , name , name return trch . parameter match name ( self . param , name )
self trch . parameter reset value ( self . param trch . parameter reset value ( self . param )
self b = trch . parameter boolean get value ( self . param ) if b : return " true " else : return " false " b = trch . parameter boolean get value ( self . param ) if b : return " true " else : return " false "
self return trch . parameter i pv4 get value ( self . param return trch . parameter i pv4 get value ( self . param )
self , value trch . parameter i pv4 set value ( self . param , value , value trch . parameter i pv4 set value ( self . param , value )
self , value trch . parameter i pv6 set value ( self . param , value , value trch . parameter i pv6 set value ( self . param , value )
self , value trch . parameter local file set value ( self . param , os . path . normpath ( value ) , value trch . parameter local file set value ( self . param , os . path . normpath ( value ) )
self return str ( trch . parameter port get value ( self . param ) return str ( trch . parameter port get value ( self . param ) )
self , value trch . parameter port set value ( self . param , int ( value ) , value trch . parameter port set value ( self . param , int ( value ) )
self , value trch . parameter port set value ( self . param , int ( value ) , value trch . parameter port set value ( self . param , int ( value ) )
self return str ( trch . parameter s16 get value ( self . param ) return str ( trch . parameter s16 get value ( self . param ) )
self , value trch . parameter s16 set value ( self . param , int ( value ) , value trch . parameter s16 set value ( self . param , int ( value ) )
self return str ( trch . parameter s32 get value ( self . param ) return str ( trch . parameter s32 get value ( self . param ) )
self , value trch . parameter s32 set value ( self . param , int ( value ) , value trch . parameter s32 set value ( self . param , int ( value ) )
self , value trch . parameter s64 set value ( self . param , long ( value ) , value trch . parameter s64 set value ( self . param , long ( value ) )
self return str ( trch . parameter s8 get value ( self . param ) return str ( trch . parameter s8 get value ( self . param ) )
self , value trch . parameter s8 set value ( self . param , int ( value ) , value trch . parameter s8 set value ( self . param , int ( value ) )
self , value trch . parameter socket set value ( self . param , int ( value ) , value trch . parameter socket set value ( self . param , int ( value ) )
self return trch . parameter string get value ( self . param return trch . parameter string get value ( self . param )
self , value trch . parameter string set value ( self . param , value , value trch . parameter string set value ( self . param , value )
self , value trch . parameter u16 set value ( self . param , int ( value ) , value trch . parameter u16 set value ( self . param , int ( value ) )
self return str ( trch . parameter u32 get value ( self . param ) return str ( trch . parameter u32 get value ( self . param ) )
self return str ( trch . parameter u64 get value ( self . param ) return str ( trch . parameter u64 get value ( self . param ) )
self , value trch . parameter u64 set value ( self . param , long ( value ) , value trch . parameter u64 set value ( self . param , long ( value ) )
self return str ( trch . parameter u8 get value ( self . param ) return str ( trch . parameter u8 get value ( self . param ) )
self , value trch . parameter u8 set value ( self . param , int ( value ) , value trch . parameter u8 set value ( self . param , int ( value ) )
self bytes = trch . parameter u string get value ( self . param ) if bytes : return binascii . hexlify ( bytes ) else : return " " bytes = trch . parameter u string get value ( self . param ) if bytes : return binascii . hexlify ( bytes ) else : return " "
self , value if value . startswith ( " \\\\x " ) : decoded val = value . decode ( ' string escape ' ) else : decoded val = binascii . unhexlify ( value ) trch . parameter u string set value ( self . param , decoded val , value if value . startswith ( " \\\\x " ) : decoded val = value . decode ( ' string escape ' ) else : decoded val = binascii . unhexlify ( value ) trch . parameter u string set value ( self . param , decoded val )
self bytes = trch . parameter buffer get value ( self . param ) if bytes : return binascii . hexlify ( bytes ) else : return " " bytes = trch . parameter buffer get value ( self . param ) if bytes : return binascii . hexlify ( bytes ) else : return " "
self , value if value . startswith ( " \\\\x " ) : decoded val = value . decode ( ' string escape ' ) else : decoded val = binascii . unhexlify ( value ) trch . parameter buffer set value ( self . param , decoded val , value if value . startswith ( " \\\\x " ) : decoded val = value . decode ( ' string escape ' ) else : decoded val = binascii . unhexlify ( value ) trch . parameter buffer set value ( self . param , decoded val )
self token = trch . parameter boolean list get value ( self . param ) values = [ ] for tok in token : if tok : values . append ( " true " ) else : values . append ( " false " ) return ' [ ' + ' , ' . join ( values ) + ' ] ' token = trch . parameter boolean list get value ( self . param ) values = [ ] for tok in token : if tok : values . append ( " true " ) else : values . append ( " false " ) return ' [ ' + ' , ' . join ( values ) + ' ] '
self , value arg = self . tokenize list ( value ) trch . parameter i pv4 list set value ( self . param , arg , value arg = self . tokenize list ( value ) trch . parameter i pv4 list set value ( self . param , arg )
self tokens = trch . parameter i pv6 list get value ( self . param ) twrapped = [ " ' " + x + " ' " for x in tokens ] return ' [ ' + ' , ' . join ( twrapped ) + ' ] ' tokens = trch . parameter i pv6 list get value ( self . param ) twrapped = [ " ' " + x + " ' " for x in tokens ] return ' [ ' + ' , ' . join ( twrapped ) + ' ] '
self , value arg = self . tokenize list ( value ) trch . parameter local file list set value ( self . param , arg , value arg = self . tokenize list ( value ) trch . parameter local file list set value ( self . param , arg )
self , value self . tcp port list set value ( value , value self . tcp port list set value ( value )
self , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter s16 list set value ( self . param , tokens , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter s16 list set value ( self . param , tokens )
self tokens = trch . parameter s16 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] ' tokens = trch . parameter s16 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] '
self tokens = trch . parameter s32 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] ' tokens = trch . parameter s32 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] '
self , value tokens = [ long ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter s64 list set value ( self . param , tokens , value tokens = [ long ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter s64 list set value ( self . param , tokens )
self tokens = trch . parameter s64 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] ' tokens = trch . parameter s64 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] '
self , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter s8 list set value ( self . param , tokens , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter s8 list set value ( self . param , tokens )
self tokens = trch . parameter s8 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] ' tokens = trch . parameter s8 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] '
self tokens = trch . parameter socket list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] ' tokens = trch . parameter socket list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] '
self tokens = trch . parameter string list get value ( self . param ) twrapped = [ " ' " + x + " ' " for x in tokens ] return ' [ ' + ' , ' . join ( twrapped ) + ' ] ' tokens = trch . parameter string list get value ( self . param ) twrapped = [ " ' " + x + " ' " for x in tokens ] return ' [ ' + ' , ' . join ( twrapped ) + ' ] '
self , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter u16 list set value ( self . param , tokens , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter u16 list set value ( self . param , tokens )
self , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter u32 list set value ( self . param , tokens , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter u32 list set value ( self . param , tokens )
self tokens = trch . parameter u32 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] ' tokens = trch . parameter u32 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] '
self , value tokens = [ long ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter u64 list set value ( self . param , tokens , value tokens = [ long ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter u64 list set value ( self . param , tokens )
self tokens = trch . parameter u64 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] ' tokens = trch . parameter u64 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] '
self tokens = trch . parameter u8 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] ' tokens = trch . parameter u8 list get value ( self . param ) return ' [ ' + ' , ' . join ( str ( x ) for x in tokens ) + ' ] '
self tokens = trch . parameter u string list get value ( self . param ) strlist = ( " ' " + binascii . hexlify ( l ) + " ' " for l in tokens ) return ' [ ' + ' , ' . join ( strlist ) + ' ] ' tokens = trch . parameter u string list get value ( self . param ) strlist = ( " ' " + binascii . hexlify ( l ) + " ' " for l in tokens ) return ' [ ' + ' , ' . join ( strlist ) + ' ] '
self tokens = trch . parameter buffer list get value ( self . param ) strlist = ( " ' " + binascii . hexlify ( l ) + " ' " for l in tokens ) return ' [ ' + ' , ' . join ( strlist ) + ' ] ' tokens = trch . parameter buffer list get value ( self . param ) strlist = ( " ' " + binascii . hexlify ( l ) + " ' " for l in tokens ) return ' [ ' + ' , ' . join ( strlist ) + ' ] '
self return trch . paramgroup get description ( self . group return trch . paramgroup get description ( self . group )
self return trch . paramgroup get num paramchoices ( self . group return trch . paramgroup get num paramchoices ( self . group )
self , name return self . param list [ name . lower ( ) , name return self . param list [ name . lower ( ) ]
self , name return self . choice list [ name . lower ( ) , name return self . choice list [ name . lower ( ) ]
self alist = [ param ( self . get name ( ) , self . get description ( ) ) ] return alis alist = [ param ( self . get name ( ) , self . get description ( ) ) ] return alist
self plist = [ ] for key in self . param list : plist . extend ( self . param list [ key ] . get parameter list ( ) ) for key in self . choice list : plist . extend ( self . choice list [ key ] . get parameter list ( ) ) return plis plist = [ ] for key in self . param list : plist . extend ( self . param list [ key ] . get parameter list ( ) ) for key in self . choice list : plist . extend ( self . choice list [ key ] . get parameter list ( ) ) return plist
self plist = [ ] for key in self . param list : plist . extend ( self . param list [ key ] . get parameter list ext ( ) ) for key in self . choice list : plist . extend ( self . choice list [ key ] . get parameter list ext ( ) ) return plis plist = [ ] for key in self . param list : plist . extend ( self . param list [ key ] . get parameter list ext ( ) ) for key in self . choice list : plist . extend ( self . choice list [ key ] . get parameter list ext ( ) ) return plist
self return trch . paramgroup is valid ( self . group return trch . paramgroup is valid ( self . group )
self , name return trch . paramgroup match name ( self . group , str ( name ) , name return trch . paramgroup match name ( self . group , str ( name ) )
self return trch . paramchoice get default value ( self . choice return trch . paramchoice get default value ( self . choice )
self return trch . paramchoice get description ( self . choice return trch . paramchoice get description ( self . choice )
self return trch . paramchoice get name ( self . choice return trch . paramchoice get name ( self . choice )
self return trch . paramchoice get num paramgroups ( self . choice return trch . paramchoice get num paramgroups ( self . choice )
self , name return self . group list [ name . lower ( ) , name return self . group list [ name . lower ( ) ]
self if self . has value ( ) : return trch . paramchoice get value ( self . choice ) else : return " " if self . has value ( ) : return trch . paramchoice get value ( self . choice ) else : return " "
self alist = [ ] for group in self . group names : alist . extend ( self . group list [ group ] . get attribute value list ( ) ) return alis alist = [ ] for group in self . group names : alist . extend ( self . group list [ group ] . get attribute value list ( ) ) return alist
self item = param ( self . get name ( ) , self . get value ( ) ) plist = [ item ] if self . has valid value ( ) : plist . extend ( self . group list [ self . get value ( ) . lower ( ) ] . get parameter list ( ) ) return plis item = param ( self . get name ( ) , self . get value ( ) ) plist = [ item ] if self . has valid value ( ) : plist . extend ( self . group list [ self . get value ( ) . lower ( ) ] . get parameter list ( ) ) return plist
self return trch . paramchoice is valid ( self . choice return trch . paramchoice is valid ( self . choice )
self v = self . get default value ( ) if not v : v = ' ' self . set value ( v v = self . get default value ( ) if not v : v = ' ' self . set value ( v )
self return trch . paramchoice has value ( self . choice return trch . paramchoice has value ( self . choice )
self return ' choice ' return ' choice '
self return ' scalar ' return ' scalar '
self c = trch . config marshal ( self . config , " t " , none ) return c = trch . config marshal ( self . config , " t " , none ) return c
self , filename c = trch . config marshal ( self . config , " t " , none ) if isinstance ( filename , str ) : with open ( filename , " wb " ) as fh : fh . write ( c ) elif isinstance ( filename , file ) : filename . write ( c , filename c = trch . config marshal ( self . config , " t " , none ) if isinstance ( filename , str ) : with open ( filename , " wb " ) as fh : fh . write ( c ) elif isinstance ( filename , file ) : filename . write ( c )
self return self . versio return self . version
self return self . config versio return self . config version
self return " %s %s %s " % ( hashlib . sha1 ( open ( self . executable , ' rb ' ) . read ( ) ) . hexdigest ( ) , os . lstat ( self . executable ) . st size , os . path . basename ( self . executable ) return " %s %s %s " % ( hashlib . sha1 ( open ( self . executable , ' rb ' ) . read ( ) ) . hexdigest ( ) , os . lstat ( self . executable ) . st size , os . path . basename ( self . executable ) )
self return " %s %s %s " % ( hashlib . sha1 ( open ( self . xml in config , ' rb ' ) . read ( ) ) . hexdigest ( ) , os . lstat ( self . xml in config ) . st size , os . path . basename ( self . xml in config ) return " %s %s %s " % ( hashlib . sha1 ( open ( self . xml in config , ' rb ' ) . read ( ) ) . hexdigest ( ) , os . lstat ( self . xml in config ) . st size , os . path . basename ( self . xml in config ) )
self , name param = trch . params find paramchoice ( self . parameters , str ( name ) ) if param : return paramchoice ( param ) else : return non , name param = trch . params find paramchoice ( self . parameters , str ( name ) ) if param : return paramchoice ( param ) else : return none
self , name param = trch . params find parameter ( self . parameters , str ( name ) ) if param : return parameter ( param ) else : return non , name param = trch . params find parameter ( self . parameters , str ( name ) ) if param : return parameter ( param ) else : return none
self return trch . params get num paramchoices ( self . parameters return trch . params get num paramchoices ( self . parameters )
self return trch . params get num parameters ( self . parameters return trch . params get num parameters ( self . parameters )
self , name = none return self . find option ( name ) . has valid value ( , name = none return self . find option ( name ) . has valid value ( )
self , name = none if name == none : return trch . params is valid ( self . parameters ) else : return self . find option ( name ) . is valid ( , name = none if name == none : return trch . params is valid ( self . parameters ) else : return self . find option ( name ) . is valid ( )
self , name if self . find paramchoice ( name ) : return true else : return fals , name if self . find paramchoice ( name ) : return true else : return false
self , name if self . find parameter ( name ) : return true else : return fals , name if self . find parameter ( name ) : return true else : return false
self , name param = self . find parameter ( name ) if param is none : param = self . find paramchoice ( name ) return para , name param = self . find parameter ( name ) if param is none : param = self . find paramchoice ( name ) return param
self , name return self . find option ( name ) . get type ( , name return self . find option ( name ) . get type ( )
self , name , value return self . find option ( name ) . set value ( value , name , value return self . find option ( name ) . set value ( value )
self , name self . find option ( name ) . reset value ( , name self . find option ( name ) . reset value ( )
self , name return self . find option ( name ) . get attribute list ( , name return self . find option ( name ) . get attribute list ( )
self plist = [ ] for key in self . param list : plist . extend ( self . param list [ key ] . get parameter list ( ) ) return plis plist = [ ] for key in self . param list : plist . extend ( self . param list [ key ] . get parameter list ( ) ) return plist
self plist = [ ] for key in self . param list : plist . extend ( self . param list [ key ] . get parameter list ( ) ) for key in self . choice list : plist . extend ( self . choice list [ key ] . get parameter list ( ) ) return plis plist = [ ] for key in self . param list : plist . extend ( self . param list [ key ] . get parameter list ( ) ) for key in self . choice list : plist . extend ( self . choice list [ key ] . get parameter list ( ) ) return plist
self plist = [ ] for key in self . param list : plist . extend ( self . param list [ key ] . get parameter list ext ( ) ) for key in self . choice list : plist . extend ( self . choice list [ key ] . get parameter list ext ( ) ) return plis plist = [ ] for key in self . param list : plist . extend ( self . param list [ key ] . get parameter list ext ( ) ) for key in self . choice list : plist . extend ( self . choice list [ key ] . get parameter list ext ( ) ) return plist
self return self . type
self , name self . name = name
self , type self . type = type
self , name return getattr ( self , ' do ' + name . lower ( ) , name return getattr ( self , ' do ' + name . lower ( ) )
self , name return getattr ( self , ' complete ' + name . lower ( ) , name return getattr ( self , ' complete ' + name . lower ( ) )
self , name return getattr ( self , ' help ' + name . lower ( ) , name return getattr ( self , ' help ' + name . lower ( ) )
self return self . get name ( )
self return " %s " % self . prefi return " %s " % self . prefix
rl methods = [ ( x , getattr ( rl , x ) ) for x in dir ( rl ) if callable ( getattr ( rl , x ) ) ] return [ ( x , m . doc ) for x , m in methods if m . doc ethods = [ ( x , getattr ( rl , x ) ) for x in dir ( rl ) if callable ( getattr ( rl , x ) ) ] return [ ( x , m . doc ) for x , m in methods if m . doc ]
rl q = get doc ( rl ) out = [ ] for funcname , doc in q : out . append ( funcname ) out . append ( " \ " . join ( textwrap . wrap ( doc , 80 , initial indent = " " ) ) ) out . append ( " " ) return ou = get doc ( rl ) out = [ ] for funcname , doc in q : out . append ( funcname ) out . append ( " \ " . join ( textwrap . wrap ( doc , 80 , initial indent = " " ) ) ) out . append ( " " ) return out
on , filename global logfile if on == " on " : logfile = open ( filename , " w " ) else : logfile = fals, filename global logfile if on == " on " : logfile = open ( filename , " w " ) else : logfile = false
s if logfile : print >> logfile , s logfile . flush ( logfile : print >> logfile , s logfile . flush ( )
s , event type = none if sock silent : pass else : if event type is none : logsocket . sendto ( s , ( host , port ) ) elif event type in show event : logsocket . sendto ( s , ( host , port ) ) else : pas event type = none if sock silent : pass else : if event type is none : logsocket . sendto ( s , ( host , port ) ) elif event type in show event : logsocket . sendto ( s , ( host , port ) ) else : pass
lists set clipboard text ( make tab ( lists ) s set clipboard text ( make tab ( lists ) )
toclipboard set clipboard text ( str ( toclipboard ) ipboard set clipboard text ( str ( toclipboard ) )
paste list = false txt = get clipboard text ( ) if txt : if paste list and " \\t " in txt : array , flag = make list of list ( txt ) if flag : txt = repr ( array ) else : txt = " array(%s) " % repr ( array ) txt = " " . join ( [ c for c in txt if c not in " \\t\\r\ " ] ) return txt
self value = self . history length log sock ( " get history length:%d " % value , " history " ) return valu value = self . history length log sock ( " get history length:%d " % value , " history " ) return value
self , value log sock ( " set history length: old:%d new:%d " % ( self . history length , value ) , " history " ) self . history length = valu , value log sock ( " set history length: old:%d new:%d " % ( self . history length , value ) , " history " ) self . history length = value
self value = self . history cursor log sock ( " get history cursor:%d " % value , " history " ) return valu value = self . history cursor log sock ( " get history cursor:%d " % value , " history " ) return value
self , value log sock ( " set history cursor: old:%d new:%d " % ( self . history cursor , value ) , " history " ) self . history cursor = valu , value log sock ( " set history cursor: old:%d new:%d " % ( self . history cursor , value ) , " history " ) self . history cursor = value
self ' ' ' clear readline history . ' ' ' self . history [ : ] = [ ] self . history cursor = ' ' ' clear readline history . ' ' ' self . history [ : ] = [ ] self . history cursor = 0
self ' ' ' move to the first line in the history . ' ' ' self . history cursor = 0 if len ( self . history ) > 0 : self . l buffer = self . history [ 0 ' ' ' move to the first line in the history . ' ' ' self . history cursor = 0 if len ( self . history ) > 0 : self . l buffer = self . history [ 0 ]
self , current ' ' ' move to the end of the input history , i . e . , the line currently being entered . ' ' ' self . history cursor = len ( self . history ) current . set line ( self . history [ 1 ] . get line text ( ) , current ' ' ' move to the end of the input history , i . e . , the line currently being entered . ' ' ' self . history cursor = len ( self . history ) current . set line ( self . history [ 1 ] . get line text ( ) )
self , current ' ' ' search forward starting at the current line and moving down through the the history as necessary using a non incremental search for a string supplied by the user . ' ' ' return self . non i search ( 1 , current , current ' ' ' search forward starting at the current line and moving down through the the history as necessary using a non incremental search for a string supplied by the user . ' ' ' return self . non i search ( 1 , current )
self , partial ' ' ' search forward through the history for the string of characters between the start of the current line and the point . this is a non incremental search . by default , this command is unbound . ' ' ' q = self . search ( 1 , partial ) return , partial ' ' ' search forward through the history for the string of characters between the start of the current line and the point . this is a non incremental search . by default , this command is unbound . ' ' ' q = self . search ( 1 , partial ) return q
str , iswordfun markers = { true : " x " , false : " o " } return " " . join ( [ markers [ iswordfun ( ch ) ] for ch in str ] , iswordfun markers = { true : " x " , false : " o " } return " " . join ( [ markers [ iswordfun ( ch ) ] for ch in str ] )
str , is segment def mark start ( s ) : if s [ 0 : 1 ] == " x " : return " s " + s [ 1 : ] else : return s return " " . join ( map ( mark start , split words ( str , is segment ) ) , is segment def mark start ( s ) : if s [ 0 : 1 ] == " x " : return " s " + s [ 1 : ] else : return s return " " . join ( map ( mark start , split words ( str , is segment ) ) )
str , is segment return str find all ( mark start segment ( str , is segment ) , " s " , is segment return str find all ( mark start segment ( str , is segment ) , " s " )
str , is segment return [ x + 1 for x in str find all ( mark end segment ( str , is segment ) , " s " ) , is segment return [ x + 1 for x in str find all ( mark end segment ( str , is segment ) , " s " ) ]
str return not is non word token ( str return not is non word token ( str )
str if len ( str ) != 1 or str in " \\t\ " : return true else : return falsif len ( str ) != 1 or str in " \\t\ " : return true else : return false
self attr = 0 if self . bold : attr |= 0x0008 if self . backgroundbold : attr |= 0x0080 if self . inverse : attr |= 0x4000 attr |= self . trtable [ self . color ] attr |= ( self . trtable [ self . background ] << 4 ) return att attr = 0 if self . bold : attr |= 0x0008 if self . backgroundbold : attr |= 0x0080 if self . inverse : attr |= 0x4000 attr |= self . trtable [ self . color ] attr |= ( self . trtable [ self . background ] << 4 ) return attr
self , attr self . bold = bool ( attr & 0x0008 ) self . backgroundbold = bool ( attr & 0x0080 ) self . inverse = bool ( attr & 0x4000 ) self . color = self . revtable [ attr & 0x0007 ] self . background = self . revtable [ ( attr & 0x0070 ) >> 4 , attr self . bold = bool ( attr & 0x0008 ) self . backgroundbold = bool ( attr & 0x0080 ) self . inverse = bool ( attr & 0x4000 ) self . color = self . revtable [ attr & 0x0007 ] self . background = self . revtable [ ( attr & 0x0070 ) >> 4 ]
self x = ansi state ( ) x . bold = self . bold x . inverse = self . inverse x . color = self . color x . background = self . background x . backgroundbold = self . backgroundbold return x = ansi state ( ) x . bold = self . bold x . inverse = self . inverse x . color = self . color x . background = self . background x . backgroundbold = self . backgroundbold return x
self , text , attr = none n , res = self . write color ( text , attr ) return n , [ attr . winattr for attr , text in res , text , attr = none n , res = self . write color ( text , attr ) return n , [ attr . winattr for attr , text in res ]
text , attr = none a = ansi writer ( defaultstate ) return a . write color ( text , attr , attr = none a = ansi writer ( defaultstate ) return a . write color ( text , attr )
self raise not implemented erro raise not implemented error
self , x = none , y = none ' ' ' move or query the window cursor . ' ' ' raise not implemented erro , x = none , y = none ' ' ' move or query the window cursor . ' ' ' raise not implemented error
self raise not implemented erro raise not implemented error
self ' ' ' return next key press event from the queue , ignoring others . ' ' ' raise not implemented erro ' ' ' return next key press event from the queue , ignoring others . ' ' ' raise not implemented error
self return tru return true
self , line self . history . add history ( lineobj . text line ( line ) , line self . history . add history ( lineobj . text line ( line ) )
self , string ' ' ' insert text into the command line . ' ' ' self . l buffer . insert text ( string , string ' ' ' insert text into the command line . ' ' ' self . l buffer . insert text ( string )
self return ( 1 , 1 return ( 1 , 1 )
self , visible = none , size = none pas , visible = none , size = none pass
self self . bell count += self . bell count += 1
self , text self . text += tex , text self . text += text
self if self . test runner is none : self . test runner = unittest . text test runner ( verbosity = self . verbosity ) result = self . test runner . run ( self . test if self . test runner is none : self . test runner = unittest . text test runner ( verbosity = self . verbosity ) result = self . test runner . run ( self . test )
pstr return pstr . index ( " # " return pstr . index ( " # " )
mstr try : return mstr . index ( " # " ) except value error : return try : return mstr . index ( " # " ) except value error : return 1
def id = connected id ( ) return id != nonid = connected id ( ) return id != none
def cur id = none try : cur id = int ( dsz . env . get ( connected env ) , 16 ) if cur id == 0 : return return cur id except : return returcur id = none try : cur id = int ( dsz . env . get ( connected env ) , 16 ) if cur id == 0 : return return cur id except : return return
def if not is connected ( ) : return false try : state = dsz . env . get ( ki su enabled env ) if state . lower ( ) in ( ' true ' , ' enabled ' , ' on ' , ' 1 ' , ' go ' , ' use ' ) : return true except : pass return falsif not is connected ( ) : return false try : state = dsz . env . get ( ki su enabled env ) if state . lower ( ) in ( ' true ' , ' enabled ' , ' on ' , ' 1 ' , ' go ' , ' use ' ) : return true except : pass return false
def dsz . env . set ( ki su enabled env , ' on ' ) return trudsz . env . set ( ki su enabled env , ' on ' ) return true
def dsz . env . set ( ki su enabled env , ' off ' ) return trudsz . env . set ( ki su enabled env , ' off ' ) return true
instance = none , type = none return dsz . cmd . run ( ' available command kisu install ' ance = none , type = none return dsz . cmd . run ( ' available command kisu install ' )
instance = none , type = none instance id = ' type pc ' if instance != none : instance id = ' instance %s ' % instance if type != none : instance id = ' type %s ' % type return dsz . cmd . run ( ' kisu connect %s ' % instance id ance = none , type = none instance id = ' type pc ' if instance != none : instance id = ' instance %s ' % instance if type != none : instance id = ' type %s ' % type return dsz . cmd . run ( ' kisu connect %s ' % instance id )
def return dsz . cmd . run ( ' kisu disconnect ' return dsz . cmd . run ( ' kisu disconnect ' )
id unknown = ' unknown ' if id == none : return unknown else : try : import demi . mcf . kisu . ids for name in demi . mcf . kisu . ids . name table : if demi . mcf . kisu . ids . name table [ name ] == id : return name except : pass return unknownknown = ' unknown ' if id == none : return unknown else : try : import demi . mcf . kisu . ids for name in demi . mcf . kisu . ids . name table : if demi . mcf . kisu . ids . name table [ name ] == id : return name except : pass return unknown
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key params uninstall instance , self . dict [ ' instance ' ] ) mmsg . add message ( msg key params uninstall , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key params uninstall instance , self . dict [ ' instance ' ] ) mmsg . add message ( msg key params uninstall , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result install instance , self . dict [ ' instance ' ] ) mmsg . add message ( msg key result install , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result install instance , self . dict [ ' instance ' ] ) mmsg . add message ( msg key result install , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result uninstall instance , self . dict [ ' instance ' ] ) mmsg . add message ( msg key result uninstall , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result uninstall instance , self . dict [ ' instance ' ] ) mmsg . add message ( msg key result uninstall , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result upgrade instance , self . dict [ ' instance ' ] ) mmsg . add message ( msg key result upgrade , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result upgrade instance , self . dict [ ' instance ' ] ) mmsg . add message ( msg key result upgrade , submsg )
self try : self . persistence = ki su survey . persistence ( dsz . cmd . data . get ( ' persistence ' , dsz . type object ) [ 0 ] ) except : self . persistence = none retur try : self . persistence = ki su survey . persistence ( dsz . cmd . data . get ( ' persistence ' , dsz . type object ) [ 0 ] ) except : self . persistence = none return
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key params connect id , self . dict [ ' id ' ] ) mmsg . add message ( msg key params connect , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key params connect id , self . dict [ ' id ' ] ) mmsg . add message ( msg key params connect , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg2 = marshal message ( ) self . dict [ ' instance ' ] . marshal ( submsg2 ) submsg . add message ( msg key result connect instance , submsg2 ) mmsg . add message ( msg key result connect , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg2 = marshal message ( ) self . dict [ ' instance ' ] . marshal ( submsg2 ) submsg . add message ( msg key result connect instance , submsg2 ) mmsg . add message ( msg key result connect , submsg )
self try : self . configuration = ki su config . configuration ( dsz . cmd . data . get ( ' configuration ' , dsz . type object ) [ 0 ] ) except : self . configuration = none retur try : self . configuration = ki su config . configuration ( dsz . cmd . data . get ( ' configuration ' , dsz . type object ) [ 0 ] ) except : self . configuration = none return
self try : self . enumeration = ki su list . enumeration ( dsz . cmd . data . get ( ' enumeration ' , dsz . type object ) [ 0 ] ) except : self . enumeration = none retur try : self . enumeration = ki su list . enumeration ( dsz . cmd . data . get ( ' enumeration ' , dsz . type object ) [ 0 ] ) except : self . enumeration = none return
self try : self . load module = ki su load module . load module ( dsz . cmd . data . get ( ' load module ' , dsz . type object ) [ 0 ] ) except : self . load module = none retur try : self . load module = ki su load module . load module ( dsz . cmd . data . get ( ' load module ' , dsz . type object ) [ 0 ] ) except : self . load module = none return
self try : self . module = ki su read module . module ( dsz . cmd . data . get ( ' module ' , dsz . type object ) [ 0 ] ) except : self . module = none retur try : self . module = ki su read module . module ( dsz . cmd . data . get ( ' module ' , dsz . type object ) [ 0 ] ) except : self . module = none return
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result user , self . dict [ ' user ' ] ) mmsg . add message ( msg key result , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result user , self . dict [ ' user ' ] ) mmsg . add message ( msg key result , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key params steal process id , self . dict [ ' process id ' ] ) mmsg . add message ( msg key params steal , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key params steal process id , self . dict [ ' process id ' ] ) mmsg . add message ( msg key params steal , submsg )
self try : self . logon = logon as user . logon ( dsz . cmd . data . get ( ' logon ' , dsz . type object ) [ 0 ] ) except : self . logon = none retur try : self . logon = logon as user . logon ( dsz . cmd . data . get ( ' logon ' , dsz . type object ) [ 0 ] ) except : self . logon = none return
type , advanced = true config lines = list ( ) id = 0x7 fffffffffffffff while ( id == 0x7 fffffffffffffff ) : \\t\\t id = dsz . ui . get int ( " enter the pc id " , " 0 " ) config lines . append ( " < id>0x%x</ id>\ " % id ) return config line , advanced = true config lines = list ( ) id = 0x7 fffffffffffffff while ( id == 0x7 fffffffffffffff ) : \\t\\t id = dsz . ui . get int ( " enter the pc id " , " 0 " ) config lines . append ( " < id>0x%x</ id>\ " % id ) return config lines
def if ( dsz . ui . prompt ( " do you want to configure with fc? " , true ) ) : \\t\\t return false else : \\t\\t return truif ( dsz . ui . prompt ( " do you want to configure with fc? " , true ) ) : \\t\\t return false else : \\t\\t return true
payload file return dsz . cmd . run ( " python payload/ prep . py project pc2 . 2 args \\ " action disable file \\\\\\ " %s\\\\\\ " \\ " " % payload file oad file return dsz . cmd . run ( " python payload/ prep . py project pc2 . 2 args \\ " action disable file \\\\\\ " %s\\\\\\ " \\ " " % payload file )
payload file return pc2 2 . payload . settings . finalize ( payload file oad file return pc2 2 . payload . settings . finalize ( payload file )
def if ( dsz . env . check ( get destination dir ( ) , 0 , " " ) ) : \\t\\t return dsz . env . get ( get destination dir ( ) , 0 , " " ) else : \\t\\t return " "if ( dsz . env . check ( get destination dir ( ) , 0 , " " ) ) : \\t\\t return dsz . env . get ( get destination dir ( ) , 0 , " " ) else : \\t\\t return " "
def return " pc felony crowbar dir "return " pc felony crowbar dir "
argv dsz . control . echo . off ( ) return demi . windows . module . uninstall ( " pc " , demi . registry . pc . name , demi . registry . pc . id , ask = false dsz . control . echo . off ( ) return demi . windows . module . uninstall ( " pc " , demi . registry . pc . name , demi . registry . pc . id , ask = false )
argv if ( len ( argv ) != 2 ) : \\t\\t dsz . ui . echo ( " usage: %s <payload file> " % argv [ 0 ] , dsz . error ) return false return pc2 2 . payload . settings . finalize ( argv [ 1 ] if ( len ( argv ) != 2 ) : \\t\\t dsz . ui . echo ( " usage: %s <payload file> " % argv [ 0 ] , dsz . error ) return false return pc2 2 . payload . settings . finalize ( argv [ 1 ] )
def import dsz if dsz . dsz obj . check for stop ( ) : return true else : return falsimport dsz if dsz . dsz obj . check for stop ( ) : return true else : return false
str dsz . ui . echo ( str , check for stop = false dsz . ui . echo ( str , check for stop = false )
str dsz . ui . echo ( str , dsz . error , check for stop = false dsz . ui . echo ( str , dsz . error , check for stop = false )
str dsz . ui . echo ( str , dsz . warning , check for stop = false dsz . ui . echo ( str , dsz . warning , check for stop = false )
xml import dsz import mcl platform mcl platform . transfer xml to core ( xml ) dsz . dsz obj . xml store ( import dsz import mcl platform mcl platform . transfer xml to core ( xml ) dsz . dsz obj . xml store ( )
def import dsz dsz . dsz obj . go to background ( import dsz dsz . dsz obj . go to background ( )
status import dsz rtn = dsz . dsz obj . dsz dh set status ( status ) if rtn != 0 : raise runtime error ( ' failed to set command status ' us import dsz rtn = dsz . dsz obj . dsz dh set status ( status ) if rtn != 0 : raise runtime error ( ' failed to set command status ' )
demarsh import socket return socket . ntohs ( demarsh . get u16 ( ) rsh import socket return socket . ntohs ( demarsh . get u16 ( ) )
demarsh import socket return socket . ntohl ( demarsh . get u32 ( ) rsh import socket return socket . ntohl ( demarsh . get u32 ( ) )
demarsh val = get u16 ( demarsh ) if val & 32768 : val = ( val & 32767 ) 32768 return varsh val = get u16 ( demarsh ) if val & 32768 : val = ( val & 32767 ) 32768 return val
demarsh import socket val = socket . ntohl ( demarsh . get u32 ( ) ) if val & 2147483648 : val = ( val & 2147483647 ) 2147483648 return varsh import socket val = socket . ntohl ( demarsh . get u32 ( ) ) if val & 2147483648 : val = ( val & 2147483647 ) 2147483648 return val
demarsh import socket val1 = socket . ntohl ( demarsh . get u32 ( ) ) val2 = socket . ntohl ( demarsh . get u32 ( ) ) full val = val2 << 32 | val1 if full val & 9223372036854775808 : full val = ( full val & 9223372036854775807 ) 9223372036854775808 return full varsh import socket val1 = socket . ntohl ( demarsh . get u32 ( ) ) val2 = socket . ntohl ( demarsh . get u32 ( ) ) full val = val2 << 32 | val1 if full val & 9223372036854775808 : full val = ( full val & 9223372036854775807 ) 9223372036854775808 return full val
subdir = none import dsz import os . path res dir = dsz . env . get ( ' lpdir resources ' ) if subdir != none and len ( subdir ) > 0 : res dir = res dir + ' /%s ' % subdir return os . path . normpath ( res dir ir = none import dsz import os . path res dir = dsz . env . get ( ' lpdir resources ' ) if subdir != none and len ( subdir ) > 0 : res dir = res dir + ' /%s ' % subdir return os . path . normpath ( res dir )
element txt = ' ' for node in element . child nodes : if node . node type == node . text node : txt = txt + node . data return txent txt = ' ' for node in element . child nodes : if node . node type == node . text node : txt = txt + node . data return txt
name , global value = false import dsz if global value : return dsz . env . check ( name , check for stop = false ) else : return dsz . env . check ( name , int ( dsz . script . env [ ' script command id ' ] ) , check for stop = false , global value = false import dsz if global value : return dsz . env . check ( name , check for stop = false ) else : return dsz . env . check ( name , int ( dsz . script . env [ ' script command id ' ] ) , check for stop = false )
name , global value = false import dsz if global value : return dsz . env . get ( name , check for stop = false ) else : return dsz . env . get ( name , int ( dsz . script . env [ ' script command id ' ] ) , check for stop = false , global value = false import dsz if global value : return dsz . env . get ( name , check for stop = false ) else : return dsz . env . get ( name , int ( dsz . script . env [ ' script command id ' ] ) , check for stop = false )
self dsz . dsz obj . go to background ( dsz . dsz obj . go to background ( )
self , xml try : xml . add attribute ( ' data timestamp ' , dsz . dsz obj . dsz dh get collecttime str ( ) ) except : pass dsz . dsz obj . xml store ( xml . get xml ( ) , xml try : xml . add attribute ( ' data timestamp ' , dsz . dsz obj . dsz dh get collecttime str ( ) ) except : pass dsz . dsz obj . xml store ( xml . get xml ( ) )
self , status rtn = dsz . dsz obj . dsz dh set status ( status ) if rtn != 0 : raise runtime error ( ' failed to set command status ' , status rtn = dsz . dsz obj . dsz dh set status ( status ) if rtn != 0 : raise runtime error ( ' failed to set command status ' )
self , element name , namespace , attributes pas , element name , namespace , attributes pass
self , os error return dsz . dsz obj . dsz dh error get system ( os error , os error return dsz . dsz obj . dsz dh error get system ( os error )
output filename , input if not isinstance ( input , mcl . data . data handler input . data handler input ) : raise runtime error ( ' input must be of type mcl . data . data handler input . data handler input ' ) return dsz data handler output ( input ut filename , input if not isinstance ( input , mcl . data . data handler input . data handler input ) : raise runtime error ( ' input must be of type mcl . data . data handler input . data handler input ' ) return dsz data handler output ( input )
name , global value = false import dsz if global value : return dsz . env . check ( name ) else : return dsz . env . check ( name , int ( dsz . script . env [ ' script command id ' ] ) , global value = false import dsz if global value : return dsz . env . check ( name ) else : return dsz . env . check ( name , int ( dsz . script . env [ ' script command id ' ] ) )
name , global value = false import dsz if global value : return dsz . env . get ( name ) else : return dsz . env . get ( name , int ( dsz . script . env [ ' script command id ' ] ) , global value = false import dsz if global value : return dsz . env . get ( name ) else : return dsz . env . get ( name , int ( dsz . script . env [ ' script command id ' ] ) )
str import mcl platform . tasking mcl platform . tasking . echo ( str import mcl platform . tasking mcl platform . tasking . echo ( str )
str import mcl platform . tasking mcl platform . tasking . echo error ( str import mcl platform . tasking mcl platform . tasking . echo error ( str )
str import mcl platform . tasking mcl platform . tasking . echo good ( str import mcl platform . tasking mcl platform . tasking . echo good ( str )
def import mcl platform . tasking return mcl platform . tasking . get parameters ( import mcl platform . tasking return mcl platform . tasking . get parameters ( )
def import mcl platform . tasking return mcl platform . tasking . get procedure number ( import mcl platform . tasking return mcl platform . tasking . get procedure number ( )
str import mcl platform . tasking mcl platform . tasking . output error ( str import mcl platform . tasking mcl platform . tasking . output error ( str )
rpc info , wait = false import mcl platform . tasking return mcl platform . tasking . rpc perform call ( rpc info , wait nfo , wait = false import mcl platform . tasking return mcl platform . tasking . rpc perform call ( rpc info , wait )
def import mcl platform . tasking mcl platform . tasking . task go to background ( import mcl platform . tasking mcl platform . tasking . task go to background ( )
status import mcl platform . tasking mcl platform . tasking . task set status ( status us import mcl platform . tasking mcl platform . tasking . task set status ( status )
self , msg type self . messaging type = msg typ , msg type self . messaging type = msg type
self , provider name , provider id sub = self . m xml . add sub element ( ' provider ' ) sub . add attribute ( ' name ' , ' %s ' % provider name ) sub . add attribute ( ' id ' , ' %u ' % provider id , provider name , provider id sub = self . m xml . add sub element ( ' provider ' ) sub . add attribute ( ' name ' , ' %s ' % provider name ) sub . add attribute ( ' id ' , ' %u ' % provider id )
self , mask self . m xml . add sub element with text ( ' search mask ' , ' %s ' % mask , mask self . m xml . add sub element with text ( ' search mask ' , ' %s ' % mask )
self , path self . m xml . add sub element with text ( ' search path ' , ' %s ' % path , path self . m xml . add sub element with text ( ' search path ' , ' %s ' % path )
self self . m xml . clear ( ) self . m xml . start ( ' tasking info ' self . m xml . clear ( ) self . m xml . start ( ' tasking info ' )
self return self . m xm return self . m xml
self , max matches self . m xml . add sub element with text ( ' search max matches ' , ' %u ' % max matches , max matches self . m xml . add sub element with text ( ' search max matches ' , ' %u ' % max matches )
self sub = self . m xml . add sub element ( ' command target ' ) sub . add attribute ( ' type ' , ' local ' sub = self . m xml . add sub element ( ' command target ' ) sub . add attribute ( ' type ' , ' local ' )
self , name sub = self . m xml . add sub element ( ' command target ' ) sub . add attribute ( ' type ' , ' remote ' ) sub . set text ( ' %s ' % name , name sub = self . m xml . add sub element ( ' command target ' ) sub . add attribute ( ' type ' , ' remote ' ) sub . set text ( ' %s ' % name )
self , type self . m xml . add sub element with text ( ' task type ' , ' %s ' % type , type self . m xml . add sub element with text ( ' task type ' , ' %s ' % type )
subdir = none import mcl platform . tasking . resource return mcl platform . tasking . resource . get dir ( subdir ir = none import mcl platform . tasking . resource return mcl platform . tasking . resource . get dir ( subdir )
filename , flags , subdir = none , project = none import mcl platform . tasking . resource return mcl platform . tasking . resource . open ( filename , flags , subdir , project name , flags , subdir = none , project = none import mcl platform . tasking . resource return mcl platform . tasking . resource . open ( filename , flags , subdir , project )
name , global value = false import mcl platform . tasking . env return mcl platform . tasking . env . check value ( name , global value , global value = false import mcl platform . tasking . env return mcl platform . tasking . env . check value ( name , global value )
name , global value = false import mcl platform . tasking . env mcl platform . tasking . env . delete value ( name , global value , global value = false import mcl platform . tasking . env mcl platform . tasking . env . delete value ( name , global value )
name , global value = false import mcl platform . tasking . env return mcl platform . tasking . env . get value ( name , global value , global value = false import mcl platform . tasking . env return mcl platform . tasking . env . get value ( name , global value )
name , value , global value = false import mcl platform . tasking . env mcl platform . tasking . env . set value ( name , value , global value , value , global value = false import mcl platform . tasking . env mcl platform . tasking . env . set value ( name , value , global value )
dir import mcl platform . tasking . virtualdir mcl platform . tasking . virtualdir . set ( dir import mcl platform . tasking . virtualdir mcl platform . tasking . virtualdir . set ( dir )
self , attr , value self . m attributes [ attr ] = xml output . clean attribute ( value , attr , value self . m attributes [ attr ] = xml output . clean attribute ( value )
self , name , namespace = ' ' if namespace == none or namespace == ' ' : namespace = self . m default namespace sub = xml output ( ) sub . start ( name , namespace ) sub . set default namespace ( self . m default namespace ) self . m subelements . append ( sub ) return su , name , namespace = ' ' if namespace == none or namespace == ' ' : namespace = self . m default namespace sub = xml output ( ) sub . start ( name , namespace ) sub . set default namespace ( self . m default namespace ) self . m subelements . append ( sub ) return sub
self , ns name , ns path if len ( ns name ) > 0 and len ( ns path ) > 0 : self . m namespace defs . append ( [ ns name , ns path ] , ns name , ns path if len ( ns name ) > 0 and len ( ns path ) > 0 : self . m namespace defs . append ( [ ns name , ns path ] )
self self . m subelements = [ ] self . m attributes = { } self . m text = ' ' self . m name = ' ' self . m default namespace = ' ' self . m namespace = ' ' self . m namespace defs = [ self . m subelements = [ ] self . m attributes = { } self . m text = ' ' self . m name = ' ' self . m default namespace = ' ' self . m namespace = ' ' self . m namespace defs = [ ]
self return self . m default namespac return self . m default namespace
self return self . m nam return self . m name
self return self . m namespac return self . m namespace
self return self . m namespace def return self . m namespace defs
self return self . m subelement return self . m subelements
self return self . m tex return self . m text
self , namespace self . m default namespace = namespac , namespace self . m default namespace = namespace
self , data self . m text = ' ' data list = [ ] for val in data : data list . append ( ' %02x ' % val ) self . m text = ' ' . join ( data list , data self . m text = ' ' data list = [ ] for val in data : data list . append ( ' %02x ' % val ) self . m text = ' ' . join ( data list )
self , name , namespace = ' ' self . clear ( ) if namespace == none or namespace == ' ' : namespace = self . m default namespace self . m name = name self . m namespace = namespace retur , name , namespace = ' ' self . clear ( ) if namespace == none or namespace == ' ' : namespace = self . m default namespace self . m name = name self . m namespace = namespace return
text return xml output . clean string ( text , b attribute = true return xml output . clean string ( text , b attribute = true )
text return xml output . clean string ( text , b text = true return xml output . clean string ( text , b text = true )
self return self . m nanosecond return self . m nanoseconds
self return self . m second return self . m seconds
self return self . m typ return self . m type
self return len ( self . m data ) self . m on inde return len ( self . m data ) self . m on index
self val = self . get u8 ( ) if val == 0 : return false else : return tru val = self . get u8 ( ) if val == 0 : return false else : return true
self , endian = big endian return ( self . get u32 ( endian ) , self . get u32 ( endian ) , endian = big endian return ( self . get u32 ( endian ) , self . get u32 ( endian ) )
self return self . m on inde return self . m on index
self , endian = big endian import mcl . object . mcl time seconds = self . get s64 ( endian ) nanoseconds = self . get u64 ( endian ) type = self . get u8 ( ) return mcl . object . mcl time . mcl time ( seconds , nanoseconds , type , endian = big endian import mcl . object . mcl time seconds = self . get s64 ( endian ) nanoseconds = self . get u64 ( endian ) type = self . get u8 ( ) return mcl . object . mcl time . mcl time ( seconds , nanoseconds , type )
self val = self . get u8 ( ) if val & 128 : val = ( val & 127 ) 128 return va val = self . get u8 ( ) if val & 128 : val = ( val & 127 ) 128 return val
self , endian = big endian val = self . get u16 ( endian ) if val & 32768 : val = ( val & 32767 ) 32768 return va , endian = big endian val = self . get u16 ( endian ) if val & 32768 : val = ( val & 32767 ) 32768 return val
self , endian = big endian val = self . get u32 ( endian ) if val & 2147483648 : val = ( val & 2147483647 ) 2147483648 return va , endian = big endian val = self . get u32 ( endian ) if val & 2147483648 : val = ( val & 2147483647 ) 2147483648 return val
self return self . m is vali return self . m is valid
self self . m on index = 0 self . m is valid = tru self . m on index = 0 self . m is valid = true
self , data import array if not isinstance ( data , array . array ) or data . typecode != ' b ' : raise runtime error ( ' data must be an array of unsigned chars ' ) self . m data = data self . m on index = 0 self . m is valid = tru , data import array if not isinstance ( data , array . array ) or data . typecode != ' b ' : raise runtime error ( ' data must be an array of unsigned chars ' ) self . m data = data self . m on index = 0 self . m is valid = true
self , new index self . m on index = new index self . m is valid = tru , new index self . m on index = new index self . m is valid = true
self return len ( self . m data return len ( self . m data )
self return self . addres return self . address
self , addr self . address = add , addr self . address = addr
self , addr , mask self . address = addr self . mask = mask self . bits = 0 while mask : self . bits = self . bits + 1 mask = mask << 1 & 429496729 , addr , mask self . address = addr self . mask = mask self . bits = 0 while mask : self . bits = self . bits + 1 mask = mask << 1 & 4294967295
self return self . m typ return self . m type
self if self . m type == self . ipaddr type ipv4 : return self . m ipv4 else : return self . m ipv if self . m type == self . ipaddr type ipv4 : return self . m ipv4 else : return self . m ipv6
self return self . m ipv6 scope i return self . m ipv6 scope id
self if self . m type != self . ipaddr type ipv4 or self . m ipv4 != 0 : return true else : return fals if self . m type != self . ipaddr type ipv4 or self . m ipv4 != 0 : return true else : return false
self , scope id self . m ipv6 scope id = scope i , scope id self . m ipv6 scope id = scope id
type if type & ( msg type modifier little endian | msg type modifier big endian ) == msg type modifier big endian : return true else : return fals if type & ( msg type modifier little endian | msg type modifier big endian ) == msg type modifier big endian : return true else : return false
type if type & ( msg type modifier little endian | msg type modifier big endian ) == msg type modifier little endian : return true else : return fals if type & ( msg type modifier little endian | msg type modifier big endian ) == msg type modifier little endian : return true else : return false
endianess if endianess & ( msg type modifier little endian | msg type modifier big endian ) == msg type modifier native endian : return true else : return falsaness if endianess & ( msg type modifier little endian | msg type modifier big endian ) == msg type modifier native endian : return true else : return false
self if self . on index >= self . m total entries : raise stop iteration else : entry = self . getitem ( self . on index ) self . on index = self . on index + 1 return entr if self . on index >= self . m total entries : raise stop iteration else : entry = self . getitem ( self . on index ) self . on index = self . on index + 1 return entry
self , key , instance = 1 return self . get cache entry data ( key , msg type bool , instance , key , instance = 1 return self . get cache entry data ( key , msg type bool , instance )
self , key , type = msg type binary , instance = 1 return self . get cache entry data ( key , type , instance , key , type = msg type binary , instance = 1 return self . get cache entry data ( key , type , instance )
self , key , instance = 1 return demarshal message ( self . get cache entry data ( key , msg type msg , instance ) , key , instance = 1 return demarshal message ( self . get cache entry data ( key , msg type msg , instance ) )
self , key , instance = 1 return self . get cache entry data ( key , msg type s8 , instance , key , instance = 1 return self . get cache entry data ( key , msg type s8 , instance )
self , key , instance = 1 return self . get cache entry data ( key , msg type s16 , instance , key , instance = 1 return self . get cache entry data ( key , msg type s16 , instance )
self , key , instance = 1 return self . get cache entry data ( key , msg type s64 , instance , key , instance = 1 return self . get cache entry data ( key , msg type s64 , instance )
self , key , instance = 1 return self . get cache entry data ( key , msg type u16 , instance , key , instance = 1 return self . get cache entry data ( key , msg type u16 , instance )
self , key , instance = 1 return self . get cache entry data ( key , msg type u32 , instance , key , instance = 1 return self . get cache entry data ( key , msg type u32 , instance )
self , key , instance = 1 return self . get cache entry data ( key , msg type u64 , instance , key , instance = 1 return self . get cache entry data ( key , msg type u64 , instance )
self return self . m num retrieve return self . m num retrieved
self , key , data , endianess = msg type modifier native endian if data != false : data = true self . add ( msg type bool , key , data , endianess , key , data , endianess = msg type modifier native endian if data != false : data = true self . add ( msg type bool , key , data , endianess )
self , key , data , endianess = msg type modifier native endian self . add ( msg type binary , key , data , endianess , key , data , endianess = msg type modifier native endian self . add ( msg type binary , key , data , endianess )
self , key , msg , endianess = msg type modifier native endian self . add ( msg type msg , key , msg . serialize ( ) , endianess , key , msg , endianess = msg type modifier native endian self . add ( msg type msg , key , msg . serialize ( ) , endianess )
self , key , str , endianess = msg type modifier native endian if str == none : self . add ( msg type utf8 , key , ' ' , endianess ) else : self . add ( msg type utf8 , key , str , endianess ) retur , key , str , endianess = msg type modifier native endian if str == none : self . add ( msg type utf8 , key , ' ' , endianess ) else : self . add ( msg type utf8 , key , str , endianess ) return
self , key , str , endianess = msg type modifier native endian if str == none : self . add ( msg type utf16 , key , ' ' , endianess ) else : self . add ( msg type utf16 , key , str , endianess ) retur , key , str , endianess = msg type modifier native endian if str == none : self . add ( msg type utf16 , key , ' ' , endianess ) else : self . add ( msg type utf16 , key , str , endianess ) return
self , key , data , endianess = msg type modifier native endian self . add ( msg type s8 , key , data , endianess , key , data , endianess = msg type modifier native endian self . add ( msg type s8 , key , data , endianess )
self , key , data , endianess = msg type modifier native endian self . add ( msg type s16 , key , data , endianess , key , data , endianess = msg type modifier native endian self . add ( msg type s16 , key , data , endianess )
self , key , data , endianess = msg type modifier native endian self . add ( msg type s32 , key , data , endianess , key , data , endianess = msg type modifier native endian self . add ( msg type s32 , key , data , endianess )
self , key , data , endianess = msg type modifier native endian self . add ( msg type u8 , key , data , endianess , key , data , endianess = msg type modifier native endian self . add ( msg type u8 , key , data , endianess )
self , key , data , endianess = msg type modifier native endian self . add ( msg type u16 , key , data , endianess , key , data , endianess = msg type modifier native endian self . add ( msg type u16 , key , data , endianess )
self , key , data , endianess = msg type modifier native endian self . add ( msg type u32 , key , data , endianess , key , data , endianess = msg type modifier native endian self . add ( msg type u32 , key , data , endianess )
self , key , data , endianess = msg type modifier native endian self . add ( msg type u64 , key , data , endianess , key , data , endianess = msg type modifier native endian self . add ( msg type u64 , key , data , endianess )
self self . m marsh . clear ( self . m marsh . clear ( )
self return self . m marsh . get size ( return self . m marsh . get size ( )
self return self . m marsh . get data ( return self . m marsh . get data ( )
self , truefalse if truefalse : self . add u8 ( 1 ) else : self . add u8 ( 0 , truefalse if truefalse : self . add u8 ( 1 ) else : self . add u8 ( 0 )
self , buffer , include size = true if include size : self . add u32 ( len ( buffer ) ) if len ( buffer ) > 0 : self . m data . extend ( buffer , buffer , include size = true if include size : self . add u32 ( len ( buffer ) ) if len ( buffer ) > 0 : self . m data . extend ( buffer )
self , module error , os error , endian = big endian self . add u32 ( module error , endian ) self . add u32 ( os error , endian , module error , os error , endian = big endian self . add u32 ( module error , endian ) self . add u32 ( os error , endian )
self , data self . m data . append ( data & 255 , data self . m data . append ( data & 255 )
self , data self . add s8 ( data , data self . add s8 ( data )
self , data , endian = big endian self . add s16 ( data , endian , data , endian = big endian self . add s16 ( data , endian )
self , data , endian = big endian self . add s32 ( data , endian , data , endian = big endian self . add s32 ( data , endian )
self , data , endian = big endian self . add s64 ( data , endian , data , endian = big endian self . add s64 ( data , endian )
self import array self . m data = array . array ( ' b ' import array self . m data = array . array ( ' b ' )
self return len ( self . m data return len ( self . m data )
self , prefix , suffix , sub dir = none , utf8 = true raise runtime error ( ' data handler output . create log file must be overriden ' , prefix , suffix , sub dir = none , utf8 = true raise runtime error ( ' data handler output . create log file must be overriden ' )
self , status self . set task status ( status ) self . end ( , status self . set task status ( status ) self . end ( )
self , xml raise runtime error ( ' data handler output . record xml must be overriden ' , xml raise runtime error ( ' data handler output . record xml must be overriden ' )
self , element name , namespace , attributes raise runtime error ( ' data handler output . start must be overriden ' , element name , namespace , attributes raise runtime error ( ' data handler output . start must be overriden ' )
self , os error raise runtime error ( ' data handler output . translate os error must be overriden ' , os error raise runtime error ( ' data handler output . translate os error must be overriden ' )
self return self . m collect tim return self . m collect time
self , collect time self . m collect time = collect tim , collect time self . m collect time = collect time
self return self . m dat return self . m data
self , data self . m data = dat , data self . m data = data
self , dest self . m dest = des , dest self . m dest = dest
self return self . m message typ return self . m message type
self , message type self . m message type = message typ , message type self . m message type = message type
self return self . m priorit return self . m priority
self return self . m producer interfac return self . m producer interface
self , iface self . m producer interface = ifac , iface self . m producer interface = iface
self return self . m producer provide return self . m producer provider
self , provider self . m producer provider = provide , provider self . m producer provider = provider
self return self . m statu return self . m status
self return self . m task id return self . m task ids
self return self . m uui return self . m uuid
self , uuid self . m uuid = uui , uuid self . m uuid = uuid
name , global value = false import mcl platform . data . env return mcl platform . data . env . check value ( name , global value , global value = false import mcl platform . data . env return mcl platform . data . env . check value ( name , global value )
name , global value = false import mcl platform . data . env return mcl platform . data . env . get value ( name , global value , global value = false import mcl platform . data . env return mcl platform . data . env . get value ( name , global value )
name , value , global value = false import mcl platform . data . env mcl platform . data . env . set value ( name , value , global value , value , global value = false import mcl platform . data . env mcl platform . data . env . set value ( name , value , global value )
self , param name , value self . m set params [ param name ] = valu , param name , value self . m set params [ param name ] = value
self , params for set key in self . m set params . keys ( ) : params [ set key ] = self . m set params [ set key , params for set key in self . m set params . keys ( ) : params [ set key ] = self . m set params [ set key ]
self return self . m data nam return self . m data name
self return self . m optiona return self . m optional
self , new name self . m data name = new nam , new name self . m data name = new name
self , values self . m help = list ( values , values self . m help = list ( values )
self , new name self . m name = new nam , new name self . m name = new name
self , opt self . m optional = op , opt self . m optional = opt
self import copy return copy . deepcopy ( self . m data value str import copy return copy . deepcopy ( self . m data value str )
self import copy return copy . deepcopy ( self . m default value str import copy return copy . deepcopy ( self . m default value str )
self return self . m data nam return self . m data name
self return self . m data typ return self . m data type
self return self . m data value se return self . m data value set
self return self . m default value se return self . m default value set
self return self . m int valu return self . m int value
self return self . m int valu return self . m int value
self return self . m int valu return self . m int value
self return self . m int valu return self . m int value
self return self . m int valu return self . m int value
self return self . m date tim return self . m date time
self return self . m byte arra return self . m byte array
self return self . m ip add return self . m ip addr
self , name self . m data name = nam , name self . m data name = name
self import copy return copy . deepcopy ( self . m arguments import copy return copy . deepcopy ( self . m arguments )
self import copy return copy . deepcopy ( self . m help import copy return copy . deepcopy ( self . m help )
self import copy return copy . deepcopy ( self . m options import copy return copy . deepcopy ( self . m options )
self return self . m option prefi return self . m option prefix
self return self . m command i return self . m command id
self return self . m command name . encode ( ' utf 8 ' return self . m command name . encode ( ' utf 8 ' )
self return self . m command script . encode ( ' utf 8 ' return self . m command script . encode ( ' utf 8 ' )
self , script self . m command script = scrip , script self . m command script = script
element txt = ' ' for node in element . child nodes : if node . node type == node . text node : txt = txt + node . data return txent txt = ' ' for node in element . child nodes : if node . node type == node . text node : txt = txt + node . data return txt
self , arg self . m arguments . append ( arg ) if arg . is optional ( ) == false : self . m min args = self . m min args + 1 self . m max args = self . m max args + , arg self . m arguments . append ( arg ) if arg . is optional ( ) == false : self . m min args = self . m min args + 1 self . m max args = self . m max args + 1
self , option if len ( option ) > 0 : self . m rejected list . append ( option , option if len ( option ) > 0 : self . m rejected list . append ( option )
self , option if len ( option ) > 0 : self . m required list . append ( option , option if len ( option ) > 0 : self . m required list . append ( option )
self return non return none
self return self . m max arg return self . m max args
self return self . m min arg return self . m min args
self return list ( self . m rejected list return list ( self . m rejected list )
self return list ( self . m required list return list ( self . m required list )
self return self . m set dat return self . m set data
self if len ( self . m arguments ) == 0 : return true else : return fals if len ( self . m arguments ) == 0 : return true else : return false
self if len ( self . m set data ) == 0 : return true else : return fals if len ( self . m set data ) == 0 : return true else : return false
self , new name pas , new name pass
self return self . m foun return self . m found
self return self . m grou return self . m group
self if len ( self . m group ) > 0 : return true else : return fals if len ( self . m group ) > 0 : return true else : return false
self if len ( self . m valid values ) > 0 : return true else : return fals if len ( self . m valid values ) > 0 : return true else : return false
self , name self . m group = nam , name self . m group = name
tool name , tool version , usage mask = 0 , status = usage status none , comments = none , location = none import mcl platform . tools mcl platform . tools . record usage ( tool name , tool version , usage mask , status , comments , location name , tool version , usage mask = 0 , status = usage status none , comments = none , location = none import mcl platform . tools mcl platform . tools . record usage ( tool name , tool version , usage mask , status , comments , location )
step try : m = re . match ( " ( . *)\\[([0 9+])\\]$ " , step ) return ( m . group ( 1 ) , int ( m . group ( 2 ) ) ) except : return ( step , 1 try : m = re . match ( " ( . *)\\[([0 9+])\\]$ " , step ) return ( m . group ( 1 ) , int ( m . group ( 2 ) ) ) except : return ( step , 1 )
def dsz . dsz obj . echo on ( dsz . dsz obj . echo on ( )
def dsz . dsz obj . echo off ( dsz . dsz obj . echo off ( )
def dsz . dsz obj . flags save ( ) dsz . dsz obj . flags normalize ( dsz . dsz obj . flags save ( ) dsz . dsz obj . flags normalize ( )
def dsz . dsz obj . flags restore ( dsz . dsz obj . flags restore ( )
def dsz . dsz obj . quiet on ( dsz . dsz obj . quiet on ( )
def dsz . dsz obj . quiet off ( dsz . dsz obj . quiet off ( )
def dsz . dsz obj . wow64 disable ( dsz . dsz obj . wow64 disable ( )
def dsz . dsz obj . wow64 enable ( dsz . dsz obj . wow64 enable ( )
should exit = true if dsz . dsz obj . check for stop ( ) : if should exit : sys . exit ( 1 ) else : return true return falsld exit = true if dsz . dsz obj . check for stop ( ) : if should exit : sys . exit ( 1 ) else : return true return false
def if dsz . dsz obj . env [ ' script running locally ' ] == ' true ' : return true else : return falsif dsz . dsz obj . env [ ' script running locally ' ] == ' true ' : return true else : return false
name , value , type , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . script data add ( name , value , type , value , type , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . script data add ( name , value , type )
check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . script data clear ( k for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . script data clear ( )
check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . script data end ( k for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . script data end ( )
name , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . script data start ( name , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . script data start ( name )
check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . script data store ( k for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . script data store ( )
def return dsz . dsz obj . cmd get last id ( return dsz . dsz obj . cmd get last id ( )
c , flags = 0 , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) rtn = dsz . dsz obj . run ( c , flags ) return rtn [ 0 flags = 0 , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) rtn = dsz . dsz obj . run ( c , flags ) return rtn [ 0 ]
c , flags = 0 , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . run ( c , flags flags = 0 , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . run ( c , flags )
cmd id return dsz . dsz obj . cmd data clear ( cmd id d return dsz . dsz obj . cmd data clear ( cmd id )
name , type , cmd id = 0 , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . cmd data get ( name , type , cmd id , type , cmd id = 0 , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . cmd data get ( name , type , cmd id )
obj , name , type , cmd id = 0 , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . cmd data obj get ( obj , name , type , cmd id , name , type , cmd id = 0 , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . cmd data obj get ( obj , name , type , cmd id )
name , cmd id = 0 , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . cmd data get size ( name , cmd id , cmd id = 0 , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . cmd data get size ( name , cmd id )
name , id = 0 , addr = dsz . dsz obj . env [ ' target address ' ] , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . env check ( name , id , addr , id = 0 , addr = dsz . dsz obj . env [ ' target address ' ] , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . env check ( name , id , addr )
name , id = 0 , addr = dsz . dsz obj . env [ ' target address ' ] , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . env delete ( name , id , addr , id = 0 , addr = dsz . dsz obj . env [ ' target address ' ] , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . env delete ( name , id , addr )
name , id = 0 , addr = dsz . dsz obj . env [ ' target address ' ] , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . env get ( name , id , addr , id = 0 , addr = dsz . dsz obj . env [ ' target address ' ] , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . env get ( name , id , addr )
def current time = time . time ( ) gmt = time . gmtime ( current time ) fmt = ' % y %m %d % hh% mm% ss ' return ' %s . %03u ' % ( time . strftime ( fmt , gmt ) , current time * 1000 % 1000 current time = time . time ( ) gmt = time . gmtime ( current time ) fmt = ' % y %m %d % hh% mm% ss ' return ' %s . %03u ' % ( time . strftime ( fmt , gmt ) , current time * 1000 % 1000 )
def try : return dsz . process . windows . is system ( ) except : return falstry : return dsz . process . windows . is system ( ) except : return false
def try : user = dsz . process . get current ( ) return user == ' root ' except : pass return falstry : user = dsz . process . get current ( ) return user == ' root ' except : pass return false
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u8 ( msg key result result type , self . dict [ ' result type ' ] ) mmsg . add message ( msg key result , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u8 ( msg key result result type , self . dict [ ' result type ' ] ) mmsg . add message ( msg key result , submsg )
def projects = list ( ) data paths = dsz . lp . get project directories ( ) for path in data paths : if len ( glob . glob ( ' %s/ py scripts/ payload/ prep . py ' % path ) ) : dir , file = dsz . path . split ( path ) projects . append ( file ) return projectprojects = list ( ) data paths = dsz . lp . get project directories ( ) for path in data paths : if len ( glob . glob ( ' %s/ py scripts/ payload/ prep . py ' % path ) ) : dir , file = dsz . path . split ( path ) projects . append ( file ) return projects
dir , name , value try : txt = get element ( dir , name ) if txt . lower ( ) == value . lower ( ) : return true except : pass return fals , name , value try : txt = get element ( dir , name ) if txt . lower ( ) == value . lower ( ) : return true except : pass return false
element txt = ' ' for node in element . child nodes : if node . node type == node . text node : txt = txt + node . data return txent txt = ' ' for node in element . child nodes : if node . node type == node . text node : txt = txt + node . data return txt
top node , name try : element = top node . get elements by tag name ( name ) return get node text ( element [ 0 ] ) except : return ' 'ode , name try : element = top node . get elements by tag name ( name ) return get node text ( element [ 0 ] ) except : return ' '
def if dsz . version . checks . windows . is vista or greater ( ) : if dsz . version . checks . is os64 bit ( ) : return true return falsif dsz . version . checks . windows . is vista or greater ( ) : if dsz . version . checks . is os64 bit ( ) : return true return false
name , obj , stop variables = false if stop variables : if name . lower ( ) not in command data map complex : command data map complex [ name . lower ( ) ] = obj elif name . lower ( ) not in command data map simple : command data map simple [ name . lower ( ) ] = ob , obj , stop variables = false if stop variables : if name . lower ( ) not in command data map complex : command data map complex [ name . lower ( ) ] = obj elif name . lower ( ) not in command data map simple : command data map simple [ name . lower ( ) ] = obj
cmd dsz . cmd . run ( cmd ) return load command ( dsz . cmd . last id ( ) dsz . cmd . run ( cmd ) return load command ( dsz . cmd . last id ( ) )
cmd name , cmd str return start command ( cmd str ame , cmd str return start command ( cmd str )
self , name return tru , name return true
self while true : ret = self . iter . next ( ) if ret == none : return if type ( ret ) != self . iter type : continue if not self . evaluate ( ret ) : continue return ret retur while true : ret = self . iter . next ( ) if ret == none : return if type ( ret ) != self . iter type : continue if not self . evaluate ( ret ) : continue return ret return
self , ret return tru , ret return true
self mcl . tasking . echo ( ' tasking: ' ) for k in self . dict . keys ( ) : mcl . tasking . echo ( ' %s => %s ' % ( k , self . dict [ k ] ) mcl . tasking . echo ( ' tasking: ' ) for k in self . dict . keys ( ) : mcl . tasking . echo ( ' %s => %s ' % ( k , self . dict [ k ] ) )
self return get logs ( self . id return get logs ( self . id )
self return dsz . cmd . data . get ( ' command meta data:: status ' , dsz . type int , self . id ) [ 0 return dsz . cmd . data . get ( ' command meta data:: status ' , dsz . type int , self . id ) [ 0 ]
self return dsz . cmd . data . get ( ' command meta data:: bytes sent ' , dsz . type int , self . id ) [ 0 return dsz . cmd . data . get ( ' command meta data:: bytes sent ' , dsz . type int , self . id ) [ 0 ]
self return dsz . cmd . data . get ( ' command meta data:: bytes received ' , dsz . type int , self . id ) [ 0 return dsz . cmd . data . get ( ' command meta data:: bytes received ' , dsz . type int , self . id ) [ 0 ]
self return tru return true
self , data file full file = ' %s/%s ' % ( get log path ( ) , data file ) try : xml . sax . parse ( full file , self ) except exception as e : pas , data file full file = ' %s/%s ' % ( get log path ( ) , data file ) try : xml . sax . parse ( full file , self ) except exception as e : pass
self , content content = ' ' . join ( content . encode ( ' utf 8 ' ) ) if self . current text == none : self . current text = content else : self . current text += content retur , content content = ' ' . join ( content . encode ( ' utf 8 ' ) ) if self . current text == none : self . current text = content else : self . current text += content return
id return dsz . cmd . data . get ( ' command meta data:: xml log ' , dsz . type string , id eturn dsz . cmd . data . get ( ' command meta data:: xml log ' , dsz . type string , id )
id return dsz . cmd . data . get ( ' command meta data:: is running ' , dsz . type bool , id ) [ 0 eturn dsz . cmd . data . get ( ' command meta data:: is running ' , dsz . type bool , id ) [ 0 ]
def return dsz . env . get ( ' logpath ' , addr = ' ' return dsz . env . get ( ' logpath ' , addr = ' ' )
self return ' ' return ' '
self , value self . values . append ( value , value self . values . append ( value )
self , prompt for correct = true while true : dsz . script . check stop ( ) for value in self . values : value . update value ( ) if not prompt for correct : break if self . validate ( ' ' ) : if dsz . ui . prompt ( ' correct values? ' , true ) : brea , prompt for correct = true while true : dsz . script . check stop ( ) for value in self . values : value . update value ( ) if not prompt for correct : break if self . validate ( ' ' ) : if dsz . ui . prompt ( ' correct values? ' , true ) : break
self output = [ ] i = 0 str = self . uuid value . hex while i < 16 : i += 1 b = str [ 0 : 2 ] str = str [ 2 : ] output . append ( int ( ' 0x%s ' % b , 16 ) ) return outpu output = [ ] i = 0 str = self . uuid value . hex while i < 16 : i += 1 b = str [ 0 : 2 ] str = str [ 2 : ] output . append ( int ( ' 0x%s ' % b , 16 ) ) return output
self return ' true/ false ' return ' true/ false '
value , value object if value object . min value != none : if value < value object . min value : return false if value object . max value != none : if value > value object . max value : return false return true , value object if value object . min value != none : if value < value object . min value : return false if value object . max value != none : if value > value object . max value : return false return true
self range str = ' ' if self . min value != none : range str += ' min value=%d ' % self . min value if self . max value != none : if len ( range str ) > 0 : range str += ' ' range str += ' max value=%d ' % self . max value return range st range str = ' ' if self . min value != none : range str += ' min value=%d ' % self . min value if self . max value != none : if len ( range str ) > 0 : range str += ' ' range str += ' max value=%d ' % self . max value return range str
self , s self . date time value = datetime . fromtimestamp ( s ) self . value = ' %s ' % self . date time value date time value . check date time ( self . date time value , self , s self . date time value = datetime . fromtimestamp ( s ) self . value = ' %s ' % self . date time value date time value . check date time ( self . date time value , self )
self diff = self . date time value datetime . fromtimestamp ( 0 ) total seconds = diff . days * 3600 * 24 + diff . seconds return total second diff = self . date time value datetime . fromtimestamp ( 0 ) total seconds = diff . days * 3600 * 24 + diff . seconds return total seconds
value , value object if value object . min len != none : if len ( value ) < value object . min len : return false if value object . max len != none : if len ( value ) > value object . max len : return false return true , value object if value object . min len != none : if len ( value ) < value object . min len : return false if value object . max len != none : if len ( value ) > value object . max len : return false return true
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params target , self . dict [ ' target ' ] ) mmsg . add message ( msg key params , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params target , self . dict [ ' target ' ] ) mmsg . add message ( msg key params , submsg )
self try : self . memory item = memory . memory item ( dsz . cmd . data . get ( ' memory item ' , dsz . type object ) [ 0 ] ) except : self . memory item = none retur try : self . memory item = memory . memory item ( dsz . cmd . data . get ( ' memory item ' , dsz . type object ) [ 0 ] ) except : self . memory item = none return
self try : self . user = current users . user ( dsz . cmd . data . get ( ' user ' , dsz . type object ) [ 0 ] ) except : self . user = none retur try : self . user = current users . user ( dsz . cmd . data . get ( ' user ' , dsz . type object ) [ 0 ] ) except : self . user = none return
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add time ( msg key params delay , self . dict [ ' delay ' ] ) mmsg . add message ( msg key params , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add time ( msg key params delay , self . dict [ ' delay ' ] ) mmsg . add message ( msg key params , submsg )
self self . deviceitem = list ( ) try : for x in dsz . cmd . data . get ( ' deviceitem ' , dsz . type object ) : self . deviceitem . append ( device query . deviceitem ( x ) ) except : pas self . deviceitem = list ( ) try : for x in dsz . cmd . data . get ( ' deviceitem ' , dsz . type object ) : self . deviceitem . append ( device query . deviceitem ( x ) ) except : pass
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result add job id , self . dict [ ' job id ' ] ) mmsg . add message ( msg key result add , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result add job id , self . dict [ ' job id ' ] ) mmsg . add message ( msg key result add , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result taskservicejob trigger event subscription , self . dict [ ' subscription ' ] ) mmsg . add message ( msg key result taskservicejob trigger event , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result taskservicejob trigger event subscription , self . dict [ ' subscription ' ] ) mmsg . add message ( msg key result taskservicejob trigger event , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result taskservicejob trigger time random delay , self . dict [ ' random delay ' ] ) mmsg . add message ( msg key result taskservicejob trigger time , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result taskservicejob trigger time random delay , self . dict [ ' random delay ' ] ) mmsg . add message ( msg key result taskservicejob trigger time , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result taskservicejob trigger boot delay , self . dict [ ' delay ' ] ) mmsg . add message ( msg key result taskservicejob trigger boot , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result taskservicejob trigger boot delay , self . dict [ ' delay ' ] ) mmsg . add message ( msg key result taskservicejob trigger boot , submsg )
self self . alias item = list ( ) try : for x in dsz . cmd . data . get ( ' alias item ' , dsz . type object ) : self . alias item . append ( aliases . alias item ( x ) ) except : pas self . alias item = list ( ) try : for x in dsz . cmd . data . get ( ' alias item ' , dsz . type object ) : self . alias item . append ( aliases . alias item ( x ) ) except : pass
self self . env item = list ( ) try : for x in dsz . cmd . data . get ( ' env item ' , dsz . type object ) : self . env item . append ( lp get env . env item ( x ) ) except : pas self . env item = list ( ) try : for x in dsz . cmd . data . get ( ' env item ' , dsz . type object ) : self . env item . append ( lp get env . env item ( x ) ) except : pass
self self . command = list ( ) try : for x in dsz . cmd . data . get ( ' command ' , dsz . type object ) : self . command . append ( commands . command ( x ) ) except : pas self . command = list ( ) try : for x in dsz . cmd . data . get ( ' command ' , dsz . type object ) : self . command . append ( commands . command ( x ) ) except : pass
self try : self . library = library . library ( dsz . cmd . data . get ( ' library ' , dsz . type object ) [ 0 ] ) except : self . library = none retur try : self . library = library . library ( dsz . cmd . data . get ( ' library ' , dsz . type object ) [ 0 ] ) except : self . library = none return
self self . wrappers = list ( ) try : for x in dsz . cmd . data . get ( ' wrappers ' , dsz . type object ) : self . wrappers . append ( wrappers . wrappers ( x ) ) except : pas self . wrappers = list ( ) try : for x in dsz . cmd . data . get ( ' wrappers ' , dsz . type object ) : self . wrappers . append ( wrappers . wrappers ( x ) ) except : pass
self try : self . directory item = lp directory . directory item ( dsz . cmd . data . get ( ' directory item ' , dsz . type object ) [ 0 ] ) except : self . directory item = none retur try : self . directory item = lp directory . directory item ( dsz . cmd . data . get ( ' directory item ' , dsz . type object ) [ 0 ] ) except : self . directory item = none return
self try : self . sid = sid lookup . sid ( dsz . cmd . data . get ( ' sid ' , dsz . type object ) [ 0 ] ) except : self . sid = none retur try : self . sid = sid lookup . sid ( dsz . cmd . data . get ( ' sid ' , dsz . type object ) [ 0 ] ) except : self . sid = none return
self try : self . tasking info = registry hive . tasking info ( dsz . cmd . data . get ( ' tasking info ' , dsz . type object ) [ 0 ] ) except : self . tasking info = none retur try : self . tasking info = registry hive . tasking info ( dsz . cmd . data . get ( ' tasking info ' , dsz . type object ) [ 0 ] ) except : self . tasking info = none return
self self . domaincontroller = list ( ) try : for x in dsz . cmd . data . get ( ' domaincontroller ' , dsz . type object ) : self . domaincontroller . append ( domain controller . domaincontroller ( x ) ) except : pas self . domaincontroller = list ( ) try : for x in dsz . cmd . data . get ( ' domaincontroller ' , dsz . type object ) : self . domaincontroller . append ( domain controller . domaincontroller ( x ) ) except : pass
self self . driveritem = list ( ) try : for x in dsz . cmd . data . get ( ' driveritem ' , dsz . type object ) : self . driveritem . append ( drivers . driveritem ( x ) ) except : pas self . driveritem = list ( ) try : for x in dsz . cmd . data . get ( ' driveritem ' , dsz . type object ) : self . driveritem . append ( drivers . driveritem ( x ) ) except : pass
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params target , self . dict [ ' target ' ] ) mmsg . add message ( msg key params , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params target , self . dict [ ' target ' ] ) mmsg . add message ( msg key params , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params target , self . dict [ ' target ' ] ) mmsg . add message ( msg key params , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params target , self . dict [ ' target ' ] ) mmsg . add message ( msg key params , submsg )
self try : self . languages = language . languages ( dsz . cmd . data . get ( ' languages ' , dsz . type object ) [ 0 ] ) except : self . languages = none retur try : self . languages = language . languages ( dsz . cmd . data . get ( ' languages ' , dsz . type object ) [ 0 ] ) except : self . languages = none return
self try : self . match file times results = match file times . match file times results ( dsz . cmd . data . get ( ' match file times results ' , dsz . type object ) [ 0 ] ) except : self . match file times results = none retur try : self . match file times results = match file times . match file times results ( dsz . cmd . data . get ( ' match file times results ' , dsz . type object ) [ 0 ] ) except : self . match file times results = none return
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params get file , self . dict [ ' file ' ] ) mmsg . add message ( msg key params get , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params get file , self . dict [ ' file ' ] ) mmsg . add message ( msg key params get , submsg )
self try : self . file = file attributes . file ( dsz . cmd . data . get ( ' file ' , dsz . type object ) [ 0 ] ) except : self . file = none retur try : self . file = file attributes . file ( dsz . cmd . data . get ( ' file ' , dsz . type object ) [ 0 ] ) except : self . file = none return
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params dir , self . dict [ ' dir ' ] ) mmsg . add message ( msg key params , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params dir , self . dict [ ' dir ' ] ) mmsg . add message ( msg key params , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result fullpath , self . dict [ ' full path ' ] ) mmsg . add message ( msg key result , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result fullpath , self . dict [ ' full path ' ] ) mmsg . add message ( msg key result , submsg )
self try : self . target directory = mk dir . target directory ( dsz . cmd . data . get ( ' target directory ' , dsz . type object ) [ 0 ] ) except : self . target directory = none retur try : self . target directory = mk dir . target directory ( dsz . cmd . data . get ( ' target directory ' , dsz . type object ) [ 0 ] ) except : self . target directory = none return
self self . drive item = list ( ) try : for x in dsz . cmd . data . get ( ' drive item ' , dsz . type object ) : self . drive item . append ( drives . drive item ( x ) ) except : pas self . drive item = list ( ) try : for x in dsz . cmd . data . get ( ' drive item ' , dsz . type object ) : self . drive item . append ( drives . drive item ( x ) ) except : pass
self try : self . move results = move . move results ( dsz . cmd . data . get ( ' move results ' , dsz . type object ) [ 0 ] ) except : self . move results = none retur try : self . move results = move . move results ( dsz . cmd . data . get ( ' move results ' , dsz . type object ) [ 0 ] ) except : self . move results = none return
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params directory , self . dict [ ' directory ' ] ) mmsg . add message ( msg key params , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params directory , self . dict [ ' directory ' ] ) mmsg . add message ( msg key params , submsg )
self self . deletionitem = list ( ) try : for x in dsz . cmd . data . get ( ' deletionitem ' , dsz . type object ) : self . deletionitem . append ( delete . deletionitem ( x ) ) except : pas self . deletionitem = list ( ) try : for x in dsz . cmd . data . get ( ' deletionitem ' , dsz . type object ) : self . deletionitem . append ( delete . deletionitem ( x ) ) except : pass
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params dir , self . dict [ ' dir ' ] ) mmsg . add message ( msg key params , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params dir , self . dict [ ' dir ' ] ) mmsg . add message ( msg key params , submsg )
self try : self . target directory = rm dir . target directory ( dsz . cmd . data . get ( ' target directory ' , dsz . type object ) [ 0 ] ) except : self . target directory = none retur try : self . target directory = rm dir . target directory ( dsz . cmd . data . get ( ' target directory ' , dsz . type object ) [ 0 ] ) except : self . target directory = none return
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params dir , self . dict [ ' dir ' ] ) mmsg . add message ( msg key params , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params dir , self . dict [ ' dir ' ] ) mmsg . add message ( msg key params , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result dir , self . dict [ ' dir ' ] ) mmsg . add message ( msg key result , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result dir , self . dict [ ' dir ' ] ) mmsg . add message ( msg key result , submsg )
self try : self . current directory = pwd . current directory ( dsz . cmd . data . get ( ' current directory ' , dsz . type object ) [ 0 ] ) except : self . current directory = none retur try : self . current directory = pwd . current directory ( dsz . cmd . data . get ( ' current directory ' , dsz . type object ) [ 0 ] ) except : self . current directory = none return
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key file item windows short name , self . dict [ ' short name ' ] ) mmsg . add message ( msg key file item windows , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key file item windows short name , self . dict [ ' short name ' ] ) mmsg . add message ( msg key file item windows , submsg )
self , content dsz . data . task reader . characters ( self , content ) content = ' ' . join ( content . encode ( ' utf 8 ' ) ) if self . current text == none : self . current text = content else : self . current text += content retur , content dsz . data . task reader . characters ( self , content ) content = ' ' . join ( content . encode ( ' utf 8 ' ) ) if self . current text == none : self . current text = content else : self . current text += content return
self , str self . dict [ str ] = tru , str self . dict [ str ] = true
self , str if str in self . dict : return self . dict [ str ] return fals , str if str in self . dict : return self . dict [ str ] return false
self , name , type , text self . dict [ name ] = dsz . data . time ( type , text , name , type , text self . dict [ name ] = dsz . data . time ( type , text )
self , name = ' modified ' return self . dict [ name , name = ' modified ' return self . dict [ name ]
self mcl . tasking . echo ( ' %8s: %s ' % ( self . type , self . value ) mcl . tasking . echo ( ' %8s: %s ' % ( self . type , self . value ) )
self try : self . copy results = copy . copy results ( dsz . cmd . data . get ( ' copy results ' , dsz . type object ) [ 0 ] ) except : self . copy results = none retur try : self . copy results = copy . copy results ( dsz . cmd . data . get ( ' copy results ' , dsz . type object ) [ 0 ] ) except : self . copy results = none return
self try : self . taskinginfo = event log clear . taskinginfo ( dsz . cmd . data . get ( ' taskinginfo ' , dsz . type object ) [ 0 ] ) except : self . taskinginfo = none retur try : self . taskinginfo = event log clear . taskinginfo ( dsz . cmd . data . get ( ' taskinginfo ' , dsz . type object ) [ 0 ] ) except : self . taskinginfo = none return
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add bool ( msg key result status enabled , self . dict [ ' auditing enabled ' ] ) mmsg . add message ( msg key result status , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add bool ( msg key result status enabled , self . dict [ ' auditing enabled ' ] ) mmsg . add message ( msg key result status , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u8 ( msg key result modify type , self . dict [ ' type ' ] ) mmsg . add message ( msg key result modify , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u8 ( msg key result modify type , self . dict [ ' type ' ] ) mmsg . add message ( msg key result modify , submsg )
self try : self . status = audit . status ( dsz . cmd . data . get ( ' status ' , dsz . type object ) [ 0 ] ) except : self . status = none retur try : self . status = audit . status ( dsz . cmd . data . get ( ' status ' , dsz . type object ) [ 0 ] ) except : self . status = none return
self self . record = list ( ) try : for x in dsz . cmd . data . get ( ' record ' , dsz . type object ) : self . record . append ( event log filter . record ( x ) ) except : pas self . record = list ( ) try : for x in dsz . cmd . data . get ( ' record ' , dsz . type object ) : self . record . append ( event log filter . record ( x ) ) except : pass
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u64 ( msg key result load load address , self . dict [ ' load address ' ] ) mmsg . add message ( msg key result load , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u64 ( msg key result load load address , self . dict [ ' load address ' ] ) mmsg . add message ( msg key result load , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add bool ( msg key result unload unloaded , self . dict [ ' unloaded ' ] ) mmsg . add message ( msg key result unload , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add bool ( msg key result unload unloaded , self . dict [ ' unloaded ' ] ) mmsg . add message ( msg key result unload , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u8 ( msg key params type , self . dict [ ' type ' ] ) mmsg . add message ( msg key params , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u8 ( msg key params type , self . dict [ ' type ' ] ) mmsg . add message ( msg key params , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add bool ( msg key result noaction cleanup , self . dict [ ' cleanup ' ] ) mmsg . add message ( msg key result noaction , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add bool ( msg key result noaction cleanup , self . dict [ ' cleanup ' ] ) mmsg . add message ( msg key result noaction , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u16 ( msg key result status header flags , self . dict [ ' flags ' ] ) mmsg . add message ( msg key result status header , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u16 ( msg key result status header flags , self . dict [ ' flags ' ] ) mmsg . add message ( msg key result status header , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add data ( msg key result dns raw data , self . dict [ ' raw data ' ] ) mmsg . add message ( msg key result dns , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add data ( msg key result dns raw data , self . dict [ ' raw data ' ] ) mmsg . add message ( msg key result dns , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u8 ( msg key result info data type , self . dict [ ' data type ' ] ) mmsg . add message ( msg key result info , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u8 ( msg key result info data type , self . dict [ ' data type ' ] ) mmsg . add message ( msg key result info , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result namedpipe name , self . dict [ ' name ' ] ) mmsg . add message ( msg key result namedpipe , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result namedpipe name , self . dict [ ' name ' ] ) mmsg . add message ( msg key result namedpipe , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result mailslot name , self . dict [ ' name ' ] ) mmsg . add message ( msg key result mailslot , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result mailslot name , self . dict [ ' name ' ] ) mmsg . add message ( msg key result mailslot , submsg )
self , content dsz . data . task reader . characters ( self , content ) content = ' ' . join ( content . encode ( ' utf 8 ' ) ) if self . current text == none : self . current text = content else : self . current text += content retur , content dsz . data . task reader . characters ( self , content ) content = ' ' . join ( content . encode ( ' utf 8 ' ) ) if self . current text == none : self . current text = content else : self . current text += content return
self dsz . ui . echo ( ' type process local remote state ' ) dsz . ui . echo ( ' ' ) for item in self : item . display ( dsz . ui . echo ( ' type process local remote state ' ) dsz . ui . echo ( ' ' ) for item in self : item . display ( )
self prefix = ' ' if self . list type == start list : prefix = ' + ' elif self . list type == stop list : prefix = ' ' for conn in self . connection : conn . display ( prefix prefix = ' ' if self . list type == start list : prefix = ' + ' elif self . list type == stop list : prefix = ' ' for conn in self . connection : conn . display ( prefix )
self , prefix = ' ' dsz . ui . echo ( ' %s% 8s %s ' % ( prefix , self . type , self . name ) , prefix = ' ' dsz . ui . echo ( ' %s% 8s %s ' % ( prefix , self . type , self . name ) )
self , ret return ret . list type == self . list typ , ret return ret . list type == self . list type
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params target , self . dict [ ' target ' ] ) mmsg . add message ( msg key params , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params target , self . dict [ ' target ' ] ) mmsg . add message ( msg key params , submsg )
self self . net bios = list ( ) try : for x in dsz . cmd . data . get ( ' net bios ' , dsz . type object ) : self . net bios . append ( netbios . net bios ( x ) ) except : pas self . net bios = list ( ) try : for x in dsz . cmd . data . get ( ' net bios ' , dsz . type object ) : self . net bios . append ( netbios . net bios ( x ) ) except : pass
self self . netmap entry item = list ( ) try : for x in dsz . cmd . data . get ( ' netmap entry item ' , dsz . type object ) : self . netmap entry item . append ( netmap . netmap entry item ( x ) ) except : pas self . netmap entry item = list ( ) try : for x in dsz . cmd . data . get ( ' netmap entry item ' , dsz . type object ) : self . netmap entry item . append ( netmap . netmap entry item ( x ) ) except : pass
self self . route = list ( ) try : for x in dsz . cmd . data . get ( ' route ' , dsz . type object ) : self . route . append ( route . route ( x ) ) except : pas self . route = list ( ) try : for x in dsz . cmd . data . get ( ' route ' , dsz . type object ) : self . route . append ( route . route ( x ) ) except : pass
self self . entry = list ( ) try : for x in dsz . cmd . data . get ( ' entry ' , dsz . type object ) : self . entry . append ( arp . entry ( x ) ) except : pas self . entry = list ( ) try : for x in dsz . cmd . data . get ( ' entry ' , dsz . type object ) : self . entry . append ( arp . entry ( x ) ) except : pass
self self . process = list ( ) try : for x in dsz . cmd . data . get ( ' process ' , dsz . type object ) : self . process . append ( portmap . process ( x ) ) except : pas self . process = list ( ) try : for x in dsz . cmd . data . get ( ' process ' , dsz . type object ) : self . process . append ( portmap . process ( x ) ) except : pass
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key params process id , self . dict [ ' process id ' ] ) mmsg . add message ( msg key params , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key params process id , self . dict [ ' process id ' ] ) mmsg . add message ( msg key params , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u8 ( msg key result result type , self . dict [ ' result type ' ] ) mmsg . add message ( msg key result , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u8 ( msg key result result type , self . dict [ ' result type ' ] ) mmsg . add message ( msg key result , submsg )
self , content dsz . data . task reader . characters ( self , content ) content = ' ' . join ( content . encode ( ' utf 8 ' ) ) if self . current text == none : self . current text = content else : self . current text += content retur , content dsz . data . task reader . characters ( self , content ) content = ' ' . join ( content . encode ( ' utf 8 ' ) ) if self . current text == none : self . current text = content else : self . current text += content return
self dsz . ui . echo ( ' pid ppid created cpu time user ' ) dsz . ui . echo ( ' ' ) for item in self : if isinstance ( item , process list ) : item . display ( dsz . ui . echo ( ' pid ppid created cpu time user ' ) dsz . ui . echo ( ' ' ) for item in self : if isinstance ( item , process list ) : item . display ( )
self prefix = ' ' if self . list type == start list : prefix = ' + ' elif self . list type == stop list : prefix = ' ' for proc item in self . process item : proc item . display function ( prefix prefix = ' ' if self . list type == start list : prefix = ' + ' elif self . list type == stop list : prefix = ' ' for proc item in self . process item : proc item . display function ( prefix )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result process id , self . dict [ ' id ' ] ) mmsg . add message ( msg key result process , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result process id , self . dict [ ' id ' ] ) mmsg . add message ( msg key result process , submsg )
self try : self . process info = process info . process info ( dsz . cmd . data . get ( ' process info ' , dsz . type object ) [ 0 ] ) except : self . process info = none retur try : self . process info = process info . process info ( dsz . cmd . data . get ( ' process info ' , dsz . type object ) [ 0 ] ) except : self . process info = none return
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result process id , self . dict [ ' id ' ] ) mmsg . add message ( msg key result , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result process id , self . dict [ ' id ' ] ) mmsg . add message ( msg key result , submsg )
self try : self . process = run as child . process ( dsz . cmd . data . get ( ' process ' , dsz . type object ) [ 0 ] ) except : self . process = none retur try : self . process = run as child . process ( dsz . cmd . data . get ( ' process ' , dsz . type object ) [ 0 ] ) except : self . process = none return
self self . options = list ( ) try : for x in dsz . cmd . data . get ( ' options ' , dsz . type object ) : self . options . append ( process options . options ( x ) ) except : pas self . options = list ( ) try : for x in dsz . cmd . data . get ( ' options ' , dsz . type object ) : self . options . append ( process options . options ( x ) ) except : pass
self id = int ( dsz . script . env [ ' script command id ' ] ) owner = self . get mutex owner ( ) if owner == id : return dsz . env . delete ( self . name , 0 , ' ' ) return fals id = int ( dsz . script . env [ ' script command id ' ] ) owner = self . get mutex owner ( ) if owner == id : return dsz . env . delete ( self . name , 0 , ' ' ) return false
command , addr = dsz . script . env [ ' target address ' ] return process command ( ' prompt ' , command , addr and , addr = dsz . script . env [ ' target address ' ] return process command ( ' prompt ' , command , addr )
self , width , height , x , y self . b detach = true self . loc x = x self . loc y = y self . size width = width self . size height = height return tru , width , height , x , y self . b detach = true self . loc x = x self . loc y = y self . size width = width self . size height = height return true
self , x , y self . b detach = true self . loc x = x self . loc y = y return tru , x , y self . b detach = true self . loc x = x self . loc y = y return true
self , width , height self . size width = width self . size height = height return tru , width , height self . size width = width self . size height = height return true
self , value = true self . b focus = valu , value = true self . b focus = value
self , value = true self . b close = valu , value = true self . b close = value
self , value = true self . b disable = valu , value = true self . b disable = value
self , new name self . name = new nam , new name self . name = new name
self , cmd self . command = cm , cmd self . command = cmd
name , addr if dsz . env . check ( name , 0 , addr ) : return dsz . env . get ( name , 0 , addr ) else : return ' unknown ' , addr if dsz . env . check ( name , 0 , addr ) : return dsz . env . get ( name , 0 , addr ) else : return ' unknown '
addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' arch ' , addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' arch ' , addr )
addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' compiled arch ' , addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' compiled arch ' , addr )
addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' os ' , addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' os ' , addr )
addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' major version ' , addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' major version ' , addr )
addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' other version ' , addr = dsz . script . env [ ' target address ' ] return getenvvalue ( ' other version ' , addr )
name , addr if dsz . env . check ( name , 0 , addr ) : return dsz . env . get ( name , 0 , addr ) else : return ' unknown ' , addr if dsz . env . check ( name , 0 , addr ) : return dsz . env . get ( name , 0 , addr ) else : return ' unknown '
addr = dsz . script . env [ ' target address ' ] answer = string . lower ( getenvvalue ( ' os 64 bit ' , addr ) ) if answer == ' yes ' or answer == ' true ' : return true else : return fals = dsz . script . env [ ' target address ' ] answer = string . lower ( getenvvalue ( ' os 64 bit ' , addr ) ) if answer == ' yes ' or answer == ' true ' : return true else : return false
addr = dsz . script . env [ ' target address ' ] return not dsz . version . checks . is windows ( addr = dsz . script . env [ ' target address ' ] return not dsz . version . checks . is windows ( addr )
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' or ver . os == ' win9x ' : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' or ver . os == ' win9x ' : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 4 : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 4 : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 5 and ver . minor == 1 : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 5 and ver . minor == 1 : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ( ver . major == 5 and ver . minor >= 1 or ver . major > 5 ) : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ( ver . major == 5 and ver . minor >= 1 or ver . major > 5 ) : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 5 and ver . minor == 2 : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 5 and ver . minor == 2 : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 6 and ver . minor == 0 : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 6 and ver . minor == 0 : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major >= 6 : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major >= 6 : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 6 and ver . minor == 0 and ver . other >= 1 : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 6 and ver . minor == 0 and ver . other >= 1 : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 6 and ver . minor == 1 : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 6 and ver . minor == 1 : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ( ver . major == 6 and ver . minor >= 1 or ver . major > 6 ) : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ( ver . major == 6 and ver . minor >= 1 or ver . major > 6 ) : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 6 and ver . minor == 2 : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 6 and ver . minor == 2 : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ( ver . major == 6 and ver . minor >= 2 or ver . major > 6 ) : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ( ver . major == 6 and ver . minor >= 2 or ver . major > 6 ) : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) return ver . compiled arch != ver . arc = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) return ver . compiled arch != ver . arch
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' linux ' or ver . os == ' linux se ' : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' linux ' or ver . os == ' linux se ' : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' solaris ' : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' solaris ' : return true else : return false
def if dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . go to background ( if dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . go to background ( )
user prompt , default value = ' ' , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . get string ( user prompt , default value prompt , default value = ' ' , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . get string ( user prompt , default value )
user prompt , default value = ' ' , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . get int ( user prompt , default value prompt , default value = ' ' , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . get int ( user prompt , default value )
str , default to yes = true , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . prompt ( str , default to yes , default to yes = true , check for stop = true if check for stop and dsz . dsz obj . check for stop ( ) : sys . exit ( 1 ) return dsz . dsz obj . prompt ( str , default to yes )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add data ( msg key result data buffer , self . dict [ ' buffer ' ] ) mmsg . add message ( msg key result data , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add data ( msg key result data buffer , self . dict [ ' buffer ' ] ) mmsg . add message ( msg key result data , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result done index , self . dict [ ' index ' ] ) mmsg . add message ( msg key result done , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result done index , self . dict [ ' index ' ] ) mmsg . add message ( msg key result done , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg2 = marshal message ( ) self . dict [ ' common ' ] . marshal ( submsg2 ) submsg . add message ( msg key command stop all common , submsg2 ) mmsg . add message ( msg key command stop all , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg2 = marshal message ( ) self . dict [ ' common ' ] . marshal ( submsg2 ) submsg . add message ( msg key command stop all common , submsg2 ) mmsg . add message ( msg key command stop all , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u64 ( msg key result start process id , self . dict [ ' process id ' ] ) mmsg . add message ( msg key result start , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u64 ( msg key result start process id , self . dict [ ' process id ' ] ) mmsg . add message ( msg key result start , submsg )
path return re . match ( ' ^[ a za z]: . *$ ' , path ) != none or re . match ( ' ^/ . *$ ' , path ) != non return re . match ( ' ^[ a za z]: . *$ ' , path ) != none or re . match ( ' ^/ . *$ ' , path ) != none
self , key if self . typevalue dict . has key ( key ) : return self . typevalue dict [ key ] else : return none return non , key if self . typevalue dict . has key ( key ) : return self . typevalue dict [ key ] else : return none return none
self file list = self . get file list ( ) self . process files ( file list file list = self . get file list ( ) self . process files ( file list )
a , b if a [ 0 ] < b [ 0 ] : return 1 else : if a [ 0 ] > b [ 0 ] : return 1 return b if a [ 0 ] < b [ 0 ] : return 1 else : if a [ 0 ] > b [ 0 ] : return 1 return 0
cls , hive dsz . ui . echo ( ' warning , get query paths() not implemented ' , dsz . warning , hive dsz . ui . echo ( ' warning , get query paths() not implemented ' , dsz . warning )
self dsz . ui . echo ( ' warning , get actual paths() not implemented ' , dsz . warning dsz . ui . echo ( ' warning , get actual paths() not implemented ' , dsz . warning )
self , reader , ignore list = [ ] dsz . ui . echo ( ' error , process() not implemented ' , dsz . warning , reader , ignore list = [ ] dsz . ui . echo ( ' error , process() not implemented ' , dsz . warning )
self , tabcnt dsz . ui . echo ( ' error , store() not implemented ' , dsz . warning , tabcnt dsz . ui . echo ( ' error , store() not implemented ' , dsz . warning )
cls , hive if hive == ' hklm ' : return cls . computer paths else : if hive == ' hkcu ' : return cls . user paths return [ , hive if hive == ' hklm ' : return cls . computer paths else : if hive == ' hkcu ' : return cls . user paths return [ ]
cls , hive return cls . query path , hive return cls . query paths
cls , hive return cls . query path , hive return cls . query paths
cls return cls . path lisreturn cls . path list
cls , hive return cls . query path , hive return cls . query paths
cls return cls . path lisreturn cls . path list
self , reader , kv list local dict = reader . registry query ( system access . query path , reader . recursive ) kv dict = dict ( kv list ) kv list += self . get local acct ( reader , local dict , kv dict ) return kv lis , reader , kv list local dict = reader . registry query ( system access . query path , reader . recursive ) kv dict = dict ( kv list ) kv list += self . get local acct ( reader , local dict , kv dict ) return kv list
self , tabcnt self . store known ( tabcnt ) self . store unknown ( tabcnt , tabcnt self . store known ( tabcnt ) self . store unknown ( tabcnt )
self , tabcnt self . store known ( tabcnt ) self . store unknown ( tabcnt , tabcnt self . store known ( tabcnt ) self . store unknown ( tabcnt )
name print task ( ' setting peel module to %s ' % name ) if not dsz . cmd . run ( ' moduletoggle system mcl nt elevation set %s ' % name ) : print failure ( ) return false print success ( ) return tru print task ( ' setting peel module to %s ' % name ) if not dsz . cmd . run ( ' moduletoggle system mcl nt elevation set %s ' % name ) : print failure ( ) return false print success ( ) return true
task if b show output : dsz . ui . echo ( task if b show output : dsz . ui . echo ( task )
b state , msg = none if b state : print success ( msg ) else : print failure ( msg te , msg = none if b state : print success ( msg ) else : print failure ( msg )
msg = none print impl ( ' passed ' , msg , dsz . good = none print impl ( ' passed ' , msg , dsz . good )
msg , detail , type if not b show output : return else : if detail != none : dsz . ui . echo ( ' %s (%s) ' % ( msg , detail ) , type ) else : dsz . ui . echo ( ' %s ' % msg , type ) retur , detail , type if not b show output : return else : if detail != none : dsz . ui . echo ( ' %s (%s) ' % ( msg , detail ) , type ) else : dsz . ui . echo ( ' %s ' % msg , type ) return
listen port , bind addr import socket sock = socket . socket ( socket . af inet , socket . sock stream ) try : sock . bind ( ( ' %s ' % bind addr , listen port ) ) sock . listen ( listen backlog ) sock . settimeout ( 1 ) return sock except : sock . close ( ) raisen port , bind addr import socket sock = socket . socket ( socket . af inet , socket . sock stream ) try : sock . bind ( ( ' %s ' % bind addr , listen port ) ) sock . listen ( listen backlog ) sock . settimeout ( 1 ) return sock except : sock . close ( ) raise
plugins if dsz . script . is local ( ) : return plugins . local . plugin return plugins . remote . plugiins if dsz . script . is local ( ) : return plugins . local . plugin return plugins . remote . plugin
module arch arch = dsz . env . get ( ' arch ' ) comp arch = dsz . env . get ( ' compiled arch ' ) return comp arch == module arcle arch arch = dsz . env . get ( ' arch ' ) comp arch = dsz . env . get ( ' compiled arch ' ) return comp arch == module arch
module platform os str = dsz . env . get ( ' os ' ) if os str == ' winnt ' : return module platform == ' windows nt ' or module platform == ' winnt ' return falsle platform os str = dsz . env . get ( ' os ' ) if os str == ' winnt ' : return module platform == ' windows nt ' or module platform == ' winnt ' return false
task if b show output : dsz . ui . echo ( task if b show output : dsz . ui . echo ( task )
msg = none print impl ( ' passed ' , msg , dsz . good = none print impl ( ' passed ' , msg , dsz . good )
msg = none print impl ( ' failed ' , msg , dsz . error = none print impl ( ' failed ' , msg , dsz . error )
msg , detail , type if not b show output : return else : if detail != none : dsz . ui . echo ( ' %s (%s) ' % ( msg , detail ) , type ) else : dsz . ui . echo ( ' %s ' % msg , type ) retur , detail , type if not b show output : return else : if detail != none : dsz . ui . echo ( ' %s (%s) ' % ( msg , detail ) , type ) else : dsz . ui . echo ( ' %s ' % msg , type ) return
plugins obj , command to check commands found = [ ] for plugin in plugins obj . remote . plugin : if plugin . name . lower ( ) . startswith ( ( ' %s target ' % command to check . lower ( ) ) ) : commands found . append ( plugin . name ) return commands founins obj , command to check commands found = [ ] for plugin in plugins obj . remote . plugin : if plugin . name . lower ( ) . startswith ( ( ' %s target ' % command to check . lower ( ) ) ) : commands found . append ( plugin . name ) return commands found
module obj , command to check for system in module obj . moduletoggle . system : if system . name . upper ( ) . startswith ( command to check . upper ( ) ) : if ( system . selected == ' flav ' ) : return true else : return false return falsle obj , command to check for system in module obj . moduletoggle . system : if system . name . upper ( ) . startswith ( command to check . upper ( ) ) : if ( system . selected == ' flav ' ) : return true else : return false return false
def dsz . cmd . run ( ' background python python pre compiler . py project ops ' ) return trudsz . cmd . run ( ' background python python pre compiler . py project ops ' ) return true
args parser = get parser ( ) options = parser . parse args ( args ) return ( options , parser . print help parser = get parser ( ) options = parser . parse args ( args ) return ( options , parser . print help )
arguments interval = 0 if ( len ( arguments ) == 0 ) : interval = 300000 else : ( options , help ) = parse usbargs ( arguments ) interval = ( options . interval [ 0 ] * 1000 ) monitor drives ( interval ments interval = 0 if ( len ( arguments ) == 0 ) : interval = 300000 else : ( options , help ) = parse usbargs ( arguments ) interval = ( options . interval [ 0 ] * 1000 ) monitor drives ( interval )
eventlog = ' security ' eventcmd = ops . cmd . get dsz command ( ' eventlogquery ' , log = eventlog ) eventobject = eventcmd . execute ( ) current recnum = eventobject . eventlog [ 0 ] . mostrecentrecordnum return current recnutlog = ' security ' eventcmd = ops . cmd . get dsz command ( ' eventlogquery ' , log = eventlog ) eventobject = eventcmd . execute ( ) current recnum = eventobject . eventlog [ 0 ] . mostrecentrecordnum return current recnum
session , job list conn = get database conn ( ) with conn : curs = conn . executemany ( ( ' insert into scansweep queue (session , job , target , inprogress , complete) values ( " %s " , ? , ? , " false " , " false " ) ' % session ) , job list ) return truion , job list conn = get database conn ( ) with conn : curs = conn . executemany ( ( ' insert into scansweep queue (session , job , target , inprogress , complete) values ( " %s " , ? , ? , " false " , " false " ) ' % session ) , job list ) return true
session conn = get database conn ( ) query execute wrapper ( conn , query string = " update scansweep metadata set kill= ' true ' where session=? " , query list = [ session ] ) return truion conn = get database conn ( ) query execute wrapper ( conn , query string = " update scansweep metadata set kill= ' true ' where session=? " , query list = [ session ] ) return true
session , target conn = get database conn ( ) query execute wrapper ( conn , query string = ' insert into scansweep excludes (session , target) values (? , ?) ' , query list = [ session , target ] ) return truion , target conn = get database conn ( ) query execute wrapper ( conn , query string = ' insert into scansweep excludes (session , target) values (? , ?) ' , query list = [ session , target ] ) return true
def conn = get database conn ( ) curs = query execute wrapper ( conn , query string = ' select session from scansweep metadata ' , no return = false ) session list = [ ] for row in curs : session list . append ( row [ ' session ' ] ) return session lisconn = get database conn ( ) curs = query execute wrapper ( conn , query string = ' select session from scansweep metadata ' , no return = false ) session list = [ ] for row in curs : session list . append ( row [ ' session ' ] ) return session list
session , rule conn = get database conn ( ) pickled data = pickle . dumps ( rule ) query execute wrapper ( conn , query string = ' insert into scansweep escalate (session , rule) values (? , ?) ' , query list = [ session , pickled data ] ) return truion , rule conn = get database conn ( ) pickled data = pickle . dumps ( rule ) query execute wrapper ( conn , query string = ' insert into scansweep escalate (session , rule) values (? , ?) ' , query list = [ session , pickled data ] ) return true
session , rule conn = get database conn ( ) pickled data = pickle . dumps ( rule ) query execute wrapper ( conn , query string = ' delete from scansweep escalate where session=? and rule=? ' , query list = [ session , pickled data ] ) return truion , rule conn = get database conn ( ) pickled data = pickle . dumps ( rule ) query execute wrapper ( conn , query string = ' delete from scansweep escalate where session=? and rule=? ' , query list = [ session , pickled data ] ) return true
session rule list = get escalate rules ( session ) if ( len ( rule list ) > 0 ) : return true else : return falsion rule list = get escalate rules ( session ) if ( len ( rule list ) > 0 ) : return true else : return false
def scansweepdb = get database ( ) return scansweepdb . connectioscansweepdb = get database ( ) return scansweepdb . connection
def return ' arpcache 'return ' arpcache '
def return ' arpcache 'return ' arpcache '
self , file to read if ( not file to read ) : return f = open ( file to read , ' r ' ) tasking = f . readlines ( ) f . close ( ) for line in tasking : if ( re . search ( ' monitor ' , line ) is not none ) : return true return fals , file to read if ( not file to read ) : return f = open ( file to read , ' r ' ) tasking = f . readlines ( ) f . close ( ) for line in tasking : if ( re . search ( ' monitor ' , line ) is not none ) : return true return false
self , escalation rule , arpentry arpcache = arpentry try : if eval ( escalation rule ) : return true else : return false except : return fals , escalation rule , arpentry arpcache = arpentry try : if eval ( escalation rule ) : return true else : return false except : return false
self , escalation rule arpcache = arpcache obj ( ) try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return fals , escalation rule arpcache = arpcache obj ( ) try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return false
def return ' monitor 'return ' monitor '
self return set ( glob . glob ( self . glob path ) return set ( glob . glob ( self . glob path ) )
self return 3 return 30
self return 3 return 30
def return ' netconnections 'return ' netconnections '
self , escalation rule , connection netconnections = connection try : if eval ( escalation rule ) : return true else : return false except : return fals , escalation rule , connection netconnections = connection try : if eval ( escalation rule ) : return true else : return false except : return false
self , escalation rule netconnections = netconnection obj ( ) try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return fals , escalation rule netconnections = netconnection obj ( ) try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return false
def return ' arp 'return ' arp '
def return ' arp 'return ' arp '
self return ( ' arp response for %s (%s) ' % ( self . target , self . mac ) return ( ' arp response for %s (%s) ' % ( self . target , self . mac ) )
self , escalation rule arp = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return fals , escalation rule arp = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return false
self return scan . return data ( self return scan . return data ( self )
self return [ ' internet address ' , ' physical address ' , ' oui ' , ' target id ' , ' time stamp ' return [ ' internet address ' , ' physical address ' , ' oui ' , ' target id ' , ' time stamp ' ]
self return [ ' target ' , ' mac ' , ' oui ' , ' target id ' , ' timestamp ' return [ ' target ' , ' mac ' , ' oui ' , ' target id ' , ' timestamp ' ]
self return ( self . get data fields ( ) + [ ' success ' ] return ( self . get data fields ( ) + [ ' success ' ] )
self , job if ( not ( len ( job ) == 1 ) ) : return false return tru , job if ( not ( len ( job ) == 1 ) ) : return false return true
def return ' scanner\\\\|* 'return ' scanner\\\\|* '
self return ( ' %s response for %s ' % ( self . type , self . target ) return ( ' %s response for %s ' % ( self . type , self . target ) )
self , escalation rule scanner = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return fals , escalation rule scanner = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return false
self , escalation rule scanner = self try : if eval ( escalation rule ) : return true else : return false except : return fals , escalation rule scanner = self try : if eval ( escalation rule ) : return true else : return false except : return false
self return scan . return data ( self return scan . return data ( self )
self return [ ' targeted address ' , ' type ' , ' data ' , ' time stamp ' return [ ' targeted address ' , ' type ' , ' data ' , ' time stamp ' ]
self return [ ' target ' , ' type ' , ' data ' , ' timestamp ' return [ ' target ' , ' type ' , ' data ' , ' timestamp ' ]
self return ( self . get data fields ( ) + [ ' success ' ] return ( self . get data fields ( ) + [ ' success ' ] )
self , job if ( ( not ( len ( job ) == 2 ) ) or ( not ( job [ 1 ] in [ ' http ' , ' win scan ' , ' ssh ' , ' winn ' ] ) ) ) : return false return tru , job if ( ( not ( len ( job ) == 2 ) ) or ( not ( job [ 1 ] in [ ' http ' , ' win scan ' , ' ssh ' , ' winn ' ] ) ) ) : return false return true
self return 3 return 30
def return ' daputouch 'return ' daputouch '
self return ( ' dapu ping pong success from %s ' % self . target return ( ' dapu ping pong success from %s ' % self . target )
self , escalation rule daputouch = self try : if eval ( escalation rule ) : return true else : return false except : return fals , escalation rule daputouch = self try : if eval ( escalation rule ) : return true else : return false except : return false
self , escalation rule daputouch = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return fals , escalation rule daputouch = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return false
self return scan . return data ( self return scan . return data ( self )
self return [ ' targeted address ' , ' port ' , ' success ' , ' error ' return [ ' targeted address ' , ' port ' , ' success ' , ' error ' ]
self return ( self . get data fields ( ) + [ ' success ' ] return ( self . get data fields ( ) + [ ' success ' ] )
self , job if ( ( not ( len ( job ) == 2 ) ) or ( not ( int ( job [ 1 ] ) in [ 445 ] ) ) ) : return false return tru , job if ( ( not ( len ( job ) == 2 ) ) or ( not ( int ( job [ 1 ] ) in [ 445 ] ) ) ) : return false return true
self return 3 return 30
def return ' smbtouch\\\\|* 'return ' smbtouch\\\\|* '
def return ' smbtouch 'return ' smbtouch '
self return ( ' sm btouch response for %s ' % self . target return ( ' sm btouch response for %s ' % self . target )
self , escalation rule smbtouch = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return fals , escalation rule smbtouch = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return false
self , escalation rule smbtouch = self try : if eval ( escalation rule ) : return true else : return false except : return fals , escalation rule smbtouch = self try : if eval ( escalation rule ) : return true else : return false except : return false
self return scan . return data ( self return scan . return data ( self )
self return [ ' targeted address ' , ' port ' , ' os ' , ' arch ' , ' creds ' , ' pipe ' , ' error ' , ' vulnerable ' , ' not vulnerable ' , ' not supported ' , ' time stamp ' return [ ' targeted address ' , ' port ' , ' os ' , ' arch ' , ' creds ' , ' pipe ' , ' error ' , ' vulnerable ' , ' not vulnerable ' , ' not supported ' , ' time stamp ' ]
self return [ ' target ' , ' port ' , ' os ' , ' arch ' , ' credentials ' , ' pipe ' , ' error ' , ' vulnerable ' , ' not vulnerable ' , ' not supported ' , ' timestamp ' return [ ' target ' , ' port ' , ' os ' , ' arch ' , ' credentials ' , ' pipe ' , ' error ' , ' vulnerable ' , ' not vulnerable ' , ' not supported ' , ' timestamp ' ]
self return ( self . get data fields ( ) + [ ' success ' ] return ( self . get data fields ( ) + [ ' success ' ] )
self return 3 return 30
def return ' banner\\\\|*\\\\|* 'return ' banner\\\\|*\\\\|* '
def return ' banner 'return ' banner '
self return ( ' banner timeout waiting on %s ' % self . target return ( ' banner timeout waiting on %s ' % self . target )
self , escalation rule banner = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return fals , escalation rule banner = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return false
self return scan . return data ( self return scan . return data ( self )
self return [ ' targeted address ' , ' responding address ' , ' return address ' , ' type ' , ' port ' , ' error ' , ' datasize ' , ' first text line ' , ' time stamp ' return [ ' targeted address ' , ' responding address ' , ' return address ' , ' type ' , ' port ' , ' error ' , ' datasize ' , ' first text line ' , ' time stamp ' ]
self return [ ' target ' , ' respondingip ' , ' returnip ' , ' type ' , ' port ' , ' error ' , ' datasize ' , ' firsttextline ' , ' timestamp ' return [ ' target ' , ' respondingip ' , ' returnip ' , ' type ' , ' port ' , ' error ' , ' datasize ' , ' firsttextline ' , ' timestamp ' ]
self return ( self . get data fields ( ) + [ ' success ' , ' moduleerror ' , ' oserror ' ] return ( self . get data fields ( ) + [ ' success ' , ' moduleerror ' , ' oserror ' ] )
def return ' scan 'return ' scan '
self , old data dict for key in old data dict . keys ( ) : setattr ( self , key , old data dict [ key ] , old data dict for key in old data dict . keys ( ) : setattr ( self , key , old data dict [ key ] )
self , target , verbose pas , target , verbose pass
self return [ return [ ]
def return ' netbios 'return ' netbios '
def return ' netbios 'return ' netbios '
self return ( ' netbios result for %s ' % self . target return ( ' netbios result for %s ' % self . target )
self , escalation rule netbios = self try : if eval ( escalation rule ) : return true else : return false except : return fals , escalation rule netbios = self try : if eval ( escalation rule ) : return true else : return false except : return false
self return scan . return data ( self return scan . return data ( self )
self return ( self . get data fields ( ) + [ ' success ' ] return ( self . get data fields ( ) + [ ' success ' ] )
self , job if ( not ( len ( job ) == 1 ) ) : return false return tru , job if ( not ( len ( job ) == 1 ) ) : return false return true
def return ' rpctouch\\\\|* 'return ' rpctouch\\\\|* '
def return ' rpctouch 'return ' rpctouch '
self , escalation rule rpctouch = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return fals , escalation rule rpctouch = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return false
self , escalation rule rpctouch = self try : if eval ( escalation rule ) : return true else : return false except : return fals , escalation rule rpctouch = self try : if eval ( escalation rule ) : return true else : return false except : return false
self return scan . return data ( self return scan . return data ( self )
self return [ ' targeted address ' , ' port ' , ' os ' , ' time stamp ' return [ ' targeted address ' , ' port ' , ' os ' , ' time stamp ' ]
self return ( self . get data fields ( ) + [ ' success ' ] return ( self . get data fields ( ) + [ ' success ' ] )
self , job if ( ( not ( len ( job ) == 2 ) ) or ( not ( int ( job [ 1 ] ) in [ 139 , 445 ] ) ) ) : return false return tru , job if ( ( not ( len ( job ) == 2 ) ) or ( not ( int ( job [ 1 ] ) in [ 139 , 445 ] ) ) ) : return false return true
self return 3 return 30
def return ' rpc2\\\\|*\\\\|* 'return ' rpc2\\\\|*\\\\|* '
def return ' rpc2 'return ' rpc2 '
self , escalation rule rpc2 = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return fals , escalation rule rpc2 = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return false
self return scan . return data ( self return scan . return data ( self )
self return [ ' targeted address ' , ' type ' , ' port ' , ' native os ' , ' native lan man ' , ' primary domain ' , ' oem domain name ' , ' looks like ' , ' error ' , ' time stamp ' return [ ' targeted address ' , ' type ' , ' port ' , ' native os ' , ' native lan man ' , ' primary domain ' , ' oem domain name ' , ' looks like ' , ' error ' , ' time stamp ' ]
self return [ ' target ' , ' type ' , ' port ' , ' nativeos ' , ' nativelanman ' , ' primarydomain ' , ' oemdomain ' , ' lookslike ' , ' error ' , ' timestamp ' return [ ' target ' , ' type ' , ' port ' , ' nativeos ' , ' nativelanman ' , ' primarydomain ' , ' oemdomain ' , ' lookslike ' , ' error ' , ' timestamp ' ]
self return ( self . get data fields ( ) + [ ' success ' ] return ( self . get data fields ( ) + [ ' success ' ] )
self , job if ( ( not ( len ( job ) == 3 ) ) or ( not ( int ( job [ 1 ] ) in [ 1 ] ) ) or ( not ( int ( job [ 2 ] ) in [ 135 , 139 , 445 , 80 ] ) ) ) : return false return tru , job if ( ( not ( len ( job ) == 3 ) ) or ( not ( int ( job [ 1 ] ) in [ 1 ] ) ) or ( not ( int ( job [ 2 ] ) in [ 135 , 139 , 445 , 80 ] ) ) ) : return false return true
self return 3 return 30
def return ' ping 'return ' ping '
self if ( self . ttl is none ) : return ( ' ping response for %s (%s) ' % ( self . target , self . responsetype ) ) else : return ( ' ping response for %s ( ttl %s , %s) ' % ( self . target , self . ttl , self . responsetype ) if ( self . ttl is none ) : return ( ' ping response for %s (%s) ' % ( self . target , self . responsetype ) ) else : return ( ' ping response for %s ( ttl %s , %s) ' % ( self . target , self . ttl , self . responsetype ) )
self if ( self . multiple responses == true ) : return self . response list else : return scan . return data ( self if ( self . multiple responses == true ) : return self . response list else : return scan . return data ( self )
self return [ ' targeted address ' , ' responding address ' , ' source address ' , ' ttl ' , ' elapsed ' , ' response type ' , ' icmp type ' , ' icmp code ' , ' time stamp ' return [ ' targeted address ' , ' responding address ' , ' source address ' , ' ttl ' , ' elapsed ' , ' response type ' , ' icmp type ' , ' icmp code ' , ' time stamp ' ]
self return [ ' target ' , ' respondingip ' , ' sourceip ' , ' ttl ' , ' elapsed ' , ' responsetype ' , ' icmptype ' , ' icmpcode ' , ' timestamp ' return [ ' target ' , ' respondingip ' , ' sourceip ' , ' ttl ' , ' elapsed ' , ' responsetype ' , ' icmptype ' , ' icmpcode ' , ' timestamp ' ]
self return ( self . get data fields ( ) + [ ' success ' , ' broadcast ' ] return ( self . get data fields ( ) + [ ' success ' , ' broadcast ' ] )
self , job if ( not ( ( len ( job ) == 1 ) or ( ( len ( job ) == 2 ) and ( job [ 1 ] . lower ( ) == ' broadcast ' ) ) ) ) : return false return tru , job if ( not ( ( len ( job ) == 1 ) or ( ( len ( job ) == 2 ) and ( job [ 1 ] . lower ( ) == ' broadcast ' ) ) ) ) : return false return true
self return 1 return 15
file name , file path try : list files = dsz . file . get names ( str ( file name ) , str ( file path ) ) return list files except exception as e : dsz . ui . echo ( str ( e ) , dsz . error name , file path try : list files = dsz . file . get names ( str ( file name ) , str ( file path ) ) return list files except exception as e : dsz . ui . echo ( str ( e ) , dsz . error )
options cmd = ' dir mask {0} path " {1} " ' . format ( options . file mask , options . dir path ) if ( options . recursive == true ) : cmd = ( cmd + ' recursive ' ) return cmons cmd = ' dir mask {0} path " {1} " ' . format ( options . file mask , options . dir path ) if ( options . recursive == true ) : cmd = ( cmd + ' recursive ' ) return cmd
options if ( options . target file path == none ) : return false elif ( options . dir path == none ) : return false elif ( options . file mask == none ) : return false elif ( options . search item == none ) : return false else : return truons if ( options . target file path == none ) : return false elif ( options . dir path == none ) : return false elif ( options . file mask == none ) : return false elif ( options . search item == none ) : return false else : return true
def str = ' python <script name> args <file name/mask> <file path> ' return ststr = ' python <script name> args <file name/mask> <file path> ' return str
path list for path in path list : if re . search ( ' system volume information ' , path ) : path list . remove ( path ) return path lis list for path in path list : if re . search ( ' system volume information ' , path ) : path list . remove ( path ) return path list
def pprint ( scans , [ ' type ' , ' description ' , ' protocol ' , ' port ' , ' broadcast ' ] , [ ' type ' , ' description ' , ' protocol ' , ' port ' , ' broadcast ' ] pprint ( scans , [ ' type ' , ' description ' , ' protocol ' , ' port ' , ' broadcast ' ] , [ ' type ' , ' description ' , ' protocol ' , ' port ' , ' broadcast ' ] )
ipstring try : ipsplit = ipstring . split ( ' . ' ) if ( len ( ipsplit ) != 4 ) : return false for oct in ipsplit : if ( ( int ( oct ) > 255 ) or ( int ( oct ) < 0 ) ) : return false except : return false return truring try : ipsplit = ipstring . split ( ' . ' ) if ( len ( ipsplit ) != 4 ) : return false for oct in ipsplit : if ( ( int ( oct ) > 255 ) or ( int ( oct ) < 0 ) ) : return false except : return false return true
guid mainkey = ' system\\\\currentcontrolset\\\\control\\\etwork\\\\{4 d36 e972 e325 11 ce bfc1 08002 be10318} ' values dict = get values ( ' l ' , ( ' %s\\\\%s\\\\ connection ' % ( mainkey , guid ) ) ) return values dic mainkey = ' system\\\\currentcontrolset\\\\control\\\etwork\\\\{4 d36 e972 e325 11 ce bfc1 08002 be10318} ' values dict = get values ( ' l ' , ( ' %s\\\\%s\\\\ connection ' % ( mainkey , guid ) ) ) return values dict
timestring return datetime . fromtimestamp ( int ( timestring ) ) . strftime ( ' % y %m %d % h:%m:% s ' string return datetime . fromtimestamp ( int ( timestring ) ) . strftime ( ' % y %m %d % h:%m:% s ' )
def dsz . ui . echo ( ' *************************** ' ) dsz . ui . echo ( ' * yak script completed . * ' ) dsz . ui . echo ( ' *************************** ' ) return trudsz . ui . echo ( ' *************************** ' ) dsz . ui . echo ( ' * yak script completed . * ' ) dsz . ui . echo ( ' *************************** ' ) return true
garbage return yakinstall ( ' u ' age return yakinstall ( ' u ' )
garbage return yakverify ( age return yakverify ( )
garbage return yakcollect ( local parse path age return yakcollect ( local parse path )
garbage global file name file name = dsz . ui . get string ( ' new upload name for yak2: ' , ' help16 . exe ' ) dsz . ui . echo ( ( ' *** upload name now set to %s *** ' % file name ) , dsz . warning ) return truage global file name file name = dsz . ui . get string ( ' new upload name for yak2: ' , ' help16 . exe ' ) dsz . ui . echo ( ( ' *** upload name now set to %s *** ' % file name ) , dsz . warning ) return true
args if ( len ( args ) > 0 ) : getmaclist ( args ) return 1 if dsz . version . checks . windows . is vista or greater ( ) : arpquery ( vista = true ) else : arpquery ( vista = false if ( len ( args ) > 0 ) : getmaclist ( args ) return 1 if dsz . version . checks . windows . is vista or greater ( ) : arpquery ( vista = true ) else : arpquery ( vista = false )
alert bat file , output dir subprocess . popen ( ( ' cmd / k %s ' % alert bat file ) , creationflags = subprocess . create new console ) return trut bat file , output dir subprocess . popen ( ( ' cmd / k %s ' % alert bat file ) , creationflags = subprocess . create new console ) return true
file to read , output dir handler ( file to read , parse config , output dir to read , output dir handler ( file to read , parse config , output dir )
file to read , output dir handler ( file to read , parse netbios , output dir to read , output dir handler ( file to read , parse netbios , output dir )
file to read , output dir handler ( file to read , parse netmap , output dir to read , output dir handler ( file to read , parse netmap , output dir )
file to read , output dir handler ( file to read , parse netconnections , output dir to read , output dir handler ( file to read , parse netconnections , output dir )
file to read , output dir handler ( file to read , parse ping , output dir to read , output dir handler ( file to read , parse ping , output dir )
def dsz . ui . echo ( ' running user query script . . . ' , dsz . good ) dsz . control . echo . off ( ) dsz . cmd . run ( ' background log userquery all ' , dsz . run flag record ) dsz . control . echo . on ( dsz . ui . echo ( ' running user query script . . . ' , dsz . good ) dsz . control . echo . off ( ) dsz . cmd . run ( ' background log userquery all ' , dsz . run flag record ) dsz . control . echo . on ( )
def dsz . ui . echo ( ' running dns cache display . . . ' , dsz . good ) dsz . control . echo . off ( ) dsz . cmd . run ( ' background log dns cache display ' , dsz . run flag record ) dsz . control . echo . on ( dsz . ui . echo ( ' running dns cache display . . . ' , dsz . good ) dsz . control . echo . off ( ) dsz . cmd . run ( ' background log dns cache display ' , dsz . run flag record ) dsz . control . echo . on ( )
self l files = self . list files ( ) size = 0 for f in l files : size += f . size print ( ' about to get %d files totalling %d bytes . will prompt for individual files > %d bytes ' % ( len ( l files ) , size , self . get max size ( ) ) l files = self . list files ( ) size = 0 for f in l files : size += f . size print ( ' about to get %d files totalling %d bytes . will prompt for individual files > %d bytes ' % ( len ( l files ) , size , self . get max size ( ) ) )
self l files = self . list files ( ) size = 0 for f in l files : size += f . size print ( ' about to get %d files totalling %d bytes . will prompt for individual files > %d bytes ' % ( len ( l files ) , size , self . get max size ( ) ) l files = self . list files ( ) size = 0 for f in l files : size += f . size print ( ' about to get %d files totalling %d bytes . will prompt for individual files > %d bytes ' % ( len ( l files ) , size , self . get max size ( ) ) )
self return os . path . normpath ( ( ( ( ( dsz . env . get ( ' logpath ' ) + os . sep ) + self . localpath ) + os . sep ) + self . localname ) return os . path . normpath ( ( ( ( ( dsz . env . get ( ' logpath ' ) + os . sep ) + self . localpath ) + os . sep ) + self . localname ) )
name , data = none return set ( name , data , db handle = ops . db . open or create voldb ( ) , data = none return set ( name , data , db handle = ops . db . open or create voldb ( ) )
name , data = none , proj name = none return set ( name , data , db handle = ops . project . get pdb ( proj name ) , data = none , proj name = none return set ( name , data , db handle = ops . project . get pdb ( proj name ) )
name return clear ( name , db handle = ops . db . database ( db = ops . db . target db , isolation level = none ) return clear ( name , db handle = ops . db . database ( db = ops . db . target db , isolation level = none ) )
name return clear ( name , db handle = ops . db . open or create voldb ( ) return clear ( name , db handle = ops . db . open or create voldb ( ) )
name , proj name = none return clear ( name , db handle = ops . project . get pdb ( proj name ) , proj name = none return clear ( name , db handle = ops . project . get pdb ( proj name ) )
name return get ( name , db handle = ops . db . database ( db = ops . db . target db , isolation level = none ) return get ( name , db handle = ops . db . database ( db = ops . db . target db , isolation level = none ) )
name return get ( name , db handle = ops . db . open or create voldb ( ) return get ( name , db handle = ops . db . open or create voldb ( ) )
def return get all ( db handle = ops . db . database ( db = ops . db . target db , isolation level = none ) return get all ( db handle = ops . db . database ( db = ops . db . target db , isolation level = none ) )
def return get all ( db handle = ops . db . open or create voldb ( ) return get all ( db handle = ops . db . open or create voldb ( ) )
def return ops . system . clocks . gmtime ( return ops . system . clocks . gmtime ( )
age return datetime . timedelta ( seconds = ops . timehelper . get seconds from age ( age ) return datetime . timedelta ( seconds = ops . timehelper . get seconds from age ( age ) )
env , cmdid = 0 , addr = dsz . script . env [ ' target address ' ] dsz . env . delete ( env , cmdid , addr , cmdid = 0 , addr = dsz . script . env [ ' target address ' ] dsz . env . delete ( env , cmdid , addr )
env , cmdid = 0 , addr = dsz . script . env [ ' target address ' ] value = get ( env , cmdid , addr ) if value : return value . upper ( ) else : return valu , cmdid = 0 , addr = dsz . script . env [ ' target address ' ] value = get ( env , cmdid , addr ) if value : return value . upper ( ) else : return value
env , cmdid = 0 , addr = dsz . script . env [ ' target address ' ] value = upper ( env , cmdid , addr ) return ( ( value == ' true ' ) if value else value , cmdid = 0 , addr = dsz . script . env [ ' target address ' ] value = upper ( env , cmdid , addr ) return ( ( value == ' true ' ) if value else value )
env , base = 10 , cmdid = 0 , addr = dsz . script . env [ ' target address ' ] value = get ( env , cmdid , addr ) return ( int ( value , base ) if value else value , base = 10 , cmdid = 0 , addr = dsz . script . env [ ' target address ' ] value = get ( env , cmdid , addr ) return ( int ( value , base ) if value else value )
self set ( test , ascii ) self . assert equal ( get ( test ) , ascii set ( test , ascii ) self . assert equal ( get ( test ) , ascii )
self set ( test , ascii ) self . assert equal ( type ( get ( test ) ) , unicode set ( test , ascii ) self . assert equal ( type ( get ( test ) ) , unicode )
self set ( test , unicode ) self . assert equal ( get ( test ) , unicode set ( test , unicode ) self . assert equal ( get ( test ) , unicode )
self set ( test , ' 0x beef ' ) self . assert equal ( numeric ( test , base = 16 ) , 48879 set ( test , ' 0x beef ' ) self . assert equal ( numeric ( test , base = 16 ) , 48879 )
self set ( test , true ) self . assert true ( bool ( test ) set ( test , true ) self . assert true ( bool ( test ) )
self set ( test , false ) self . assert false ( bool ( test ) set ( test , false ) self . assert false ( bool ( test ) )
self set ( test , upper ) self . assert equal ( lower ( test ) , lower set ( test , upper ) self . assert equal ( lower ( test ) , lower )
def retval = os . path . join ( logdir , ' tmp ' ) if ( not os . path . exists ( retval ) ) : os . mkdir ( retval ) return retvaretval = os . path . join ( logdir , ' tmp ' ) if ( not os . path . exists ( retval ) ) : os . mkdir ( retval ) return retval
def return time . strftime ( ' % h:% m:% s ' return time . strftime ( ' % h:% m:% s ' )
def return time . strftime ( ' % y %m %d ' return time . strftime ( ' % y %m %d ' )
def return ( ( datestamp ( ) + ' ' ) + timestamp ( ) return ( ( datestamp ( ) + ' ' ) + timestamp ( ) )
def return ( ( datetimestamp ( ) + ' ' ) + target addr return ( ( datetimestamp ( ) + ' ' ) + target addr )
msg return ( msg . encode ( ' utf8 ' ) if ( type ( msg ) is unicode ) else msg return ( msg . encode ( ' utf8 ' ) if ( type ( msg ) is unicode ) else msg )
msg , type = dsz . good , stamp = none dsz . ui . echo ( ( ' [%s] %s ' % ( ( stamp if stamp else targetdatetimestamp ( ) ) , utf8 ( msg ) ) ) , type , type = dsz . good , stamp = none dsz . ui . echo ( ( ' [%s] %s ' % ( ( stamp if stamp else targetdatetimestamp ( ) ) , utf8 ( msg ) ) ) , type )
msg , stamp = none info ( msg , type = dsz . warning , stamp = stamp , stamp = none info ( msg , type = dsz . warning , stamp = stamp )
msg , stamp = none info ( msg , type = dsz . error , stamp = stamp , stamp = none info ( msg , type = dsz . error , stamp = stamp )
msg = none dsz . ui . pause ( ( msg if ( msg is not none ) else ' press enter to continue . ' ) = none dsz . ui . pause ( ( msg if ( msg is not none ) else ' press enter to continue . ' ) )
cmd flags = dsz . control . method ( ) dsz . control . echo . off ( ) ret = dsz . cmd . run ( ( ' available command %s load ' % cmd ) ) del flags return reflags = dsz . control . method ( ) dsz . control . echo . off ( ) ret = dsz . cmd . run ( ( ' available command %s load ' % cmd ) ) del flags return ret
def retval = [ ] for projdir in get all project names ( ) : retval . append ( os . path . join ( ops . baselogdir , projdir ) ) return retvaretval = [ ] for projdir in get all project names ( ) : retval . append ( os . path . join ( ops . baselogdir , projdir ) ) return retval
def retval = [ ] for fullprojdir in get all project logdirs ( ) : dbfile = os . path . join ( fullprojdir , ' project . db ' ) if ( not os . path . exists ( dbfile ) ) : create new pdb ( dbfile ) retval . append ( dbfile ) return retvaretval = [ ] for fullprojdir in get all project logdirs ( ) : dbfile = os . path . join ( fullprojdir , ' project . db ' ) if ( not os . path . exists ( dbfile ) ) : create new pdb ( dbfile ) retval . append ( dbfile ) return retval
self , ** targ options if ( ' target object ' in targ options ) : newtarg = targ options [ ' target object ' ] else : newtarg = target ( self , ** targ options ) newtarg . save ( self . pdb ) self . targets . append ( newtarg ) return newtar , ** targ options if ( ' target object ' in targ options ) : newtarg = targ options [ ' target object ' ] else : newtarg = target ( self , ** targ options ) newtarg . save ( self . pdb ) self . targets . append ( newtarg ) return newtarg
self , target object with self . pdb as pdb : curs = pdb . execute ( ' delete from targets where target id = :targetid ' , { ' targetid ' : target object . target id } ) self . targets = non , target object with self . pdb as pdb : curs = pdb . execute ( ' delete from targets where target id = :targetid ' , { ' targetid ' : target object . target id } ) self . targets = none
self return self . nam return self . name
self , value self . name = valu , value self . name = value
self return get pdb ( self . name return get pdb ( self . name )
self if ( self . targets is none ) : self . targets = list ( ) with self . pdb as pdb : curs = pdb . execute ( ' select * from targets ' ) for row in curs : self . targets . append ( target ( project = self , dbrow = row ) ) return self . target if ( self . targets is none ) : self . targets = list ( ) with self . pdb as pdb : curs = pdb . execute ( ' select * from targets ' ) for row in curs : self . targets . append ( target ( project = self , dbrow = row ) ) return self . targets
self , value self . targets = valu , value self . targets = value
self , value self . macs = valu , value self . macs = value
self return ops . db . get tdb ( self . target id , self . project . name return ops . db . get tdb ( self . target id , self . project . name )
self self . quickdict = dict ( ) for service in self . service : self . quickdict [ service . servicename . lower ( ) ] = servic self . quickdict = dict ( ) for service in self . service : self . quickdict [ service . servicename . lower ( ) ] = service
self retval = [ ] for interface in self . interfaceitem : for ipaddr in interface . ipaddress : retval . append ( ipaddr . ip ) return retva retval = [ ] for interface in self . interfaceitem : for ipaddr in interface . ipaddress : retval . append ( ipaddr . ip ) return retval
self retval = [ ] for interface in self . interfaceitem : retval . append ( interface . address ) return retva retval = [ ] for interface in self . interfaceitem : retval . append ( interface . address ) return retval
self return os . path . join ( self . dszparent . path , self . name return os . path . join ( self . dszparent . path , self . name )
self if ( self . quickdict is none ) : self . quickdict = dict ( ) for subkey in self . subkey : self . quickdict [ subkey . name . lower ( ) ] = subkey for valval in self . value : self . quickdict [ valval . name . lower ( ) ] = valva if ( self . quickdict is none ) : self . quickdict = dict ( ) for subkey in self . subkey : self . quickdict [ subkey . name . lower ( ) ] = subkey for valval in self . value : self . quickdict [ valval . name . lower ( ) ] = valval
self if ( self . friendly gmt time is none ) : self . friendly gmt time = datetime . datetime . utcfromtimestamp ( self . gmttimeseconds . value ) return self . friendly gmt tim if ( self . friendly gmt time is none ) : self . friendly gmt time = datetime . datetime . utcfromtimestamp ( self . gmttimeseconds . value ) return self . friendly gmt time
self if ( self . friendly local time is none ) : self . friendly local time = datetime . datetime . utcfromtimestamp ( self . localtimeseconds . value ) return self . friendly local tim if ( self . friendly local time is none ) : self . friendly local time = datetime . datetime . utcfromtimestamp ( self . localtimeseconds . value ) return self . friendly local time
self if ( self . skew is none ) : self . skew = ( self . datainit self . friendly gmt time ) return self . ske if ( self . skew is none ) : self . skew = ( self . datainit self . friendly gmt time ) return self . skew
self return self . dataini return self . datainit
self retval = ' ' for outputline in self . processoutput : retval = ( retval + outputline . output ) return retva retval = ' ' for outputline in self . processoutput : retval = ( retval + outputline . output ) return retval
def return get error from command id ( cmdid = dsz . cmd . last id ( ) return get error from command id ( cmdid = dsz . cmd . last id ( ) )
self return ( self . audit event failure == 1 return ( self . audit event failure == 1 )
self if ( self . friendly is none ) : self . populate driver data ( ) return self . friendl if ( self . friendly is none ) : self . populate driver data ( ) return self . friendly
self if ( self . proctype is none ) : self . populate driver data ( ) return self . drivertyp if ( self . proctype is none ) : self . populate driver data ( ) return self . drivertype
self return os . path . split ( self . name ) [ 1 return os . path . split ( self . name ) [ 1 ]
self retval = [ ] retval . extend ( self . initialconnectionlistitem . connectionitem ) for start in self . startconnectionlistitem : retval . extend ( start . connectionitem ) for stop in self . stopconnectionlistitem : retval . extend ( stop . connectionitem retval = [ ] retval . extend ( self . initialconnectionlistitem . connectionitem ) for start in self . startconnectionlistitem : retval . extend ( start . connectionitem ) for stop in self . stopconnectionlistitem : retval . extend ( stop . connectionitem )
self if ( self . friendly is none ) : self . populate elist data ( ) return self . friendl if ( self . friendly is none ) : self . populate elist data ( ) return self . friendly
self if ( self . proctype is none ) : self . populate elist data ( ) return self . proctyp if ( self . proctype is none ) : self . populate elist data ( ) return self . proctype
self if ( self . path != ' ' ) : return os . path . join ( self . path , self . name ) else : return self . nam if ( self . path != ' ' ) : return os . path . join ( self . path , self . name ) else : return self . name
self return ( ( self . name . find ( ' security update ' ) > ( 1 ) ) or ( self . name . lower ( ) . find ( ' hotfix ' ) > ( 1 ) ) return ( ( self . name . find ( ' security update ' ) > ( 1 ) ) or ( self . name . lower ( ) . find ( ' hotfix ' ) > ( 1 ) ) )
def ops . preload ( ' language ' ) flags = dsz . control . method ( ) dsz . control . echo . on ( ) ops . info ( ' querying language ' ) dsz . cmd . run ( ' language ' ops . preload ( ' language ' ) flags = dsz . control . method ( ) dsz . control . echo . on ( ) ops . info ( ' querying language ' ) dsz . cmd . run ( ' language ' )
def sig cmd = ops . cmd . get dsz command ( ' python ifthen . py project te di ' ) sig result = sig cmd . execute ( ) if ( not sig cmd . success ) : ops . error ( ' failed to execute script . ' sig cmd = ops . cmd . get dsz command ( ' python ifthen . py project te di ' ) sig result = sig cmd . execute ( ) if ( not sig cmd . success ) : ops . error ( ' failed to execute script . ' )
def cmd = ops . cmd . get dsz command ( ' activity monitor ' ) start monitor ( cmd , mon display = true , cache tag = ' ops activity monitor ' , save delay = 15 , cache size = 1 , use volatile = true ) ops . info ( ' activity monitor started (or already running) ' cmd = ops . cmd . get dsz command ( ' activity monitor ' ) start monitor ( cmd , mon display = true , cache tag = ' ops activity monitor ' , save delay = 15 , cache size = 1 , use volatile = true ) ops . info ( ' activity monitor started (or already running) ' )
proctree , depth retval = list ( ) for rootproc in proctree : retval . append ( prettyproc ( rootproc [ 0 ] , depth ) ) retval . extend ( treecurse ( rootproc [ 1 ] , ( depth + 1 ) ) ) return retvatree , depth retval = list ( ) for rootproc in proctree : retval . append ( prettyproc ( rootproc [ 0 ] , depth ) ) retval . extend ( treecurse ( rootproc [ 1 ] , ( depth + 1 ) ) ) return retval
value mark ( value , done e mark ( value , done )
value mark ( value , error e mark ( value , error )
name if ( name is none ) : return none initdb ( ) name = ( ' ops::survey::marker::%s ' % name ) r = ops . marker . get volatile ( name ) return ( r [ ' extra ' ] , r [ ' last date ' ] if ( name is none ) : return none initdb ( ) name = ( ' ops::survey::marker::%s ' % name ) r = ops . marker . get volatile ( name ) return ( r [ ' extra ' ] , r [ ' last date ' ] )
value s = state ( value ) if ( s is none ) : return false elif ( s == ( started , none ) ) : return true else : return false s = state ( value ) if ( s is none ) : return false elif ( s == ( started , none ) ) : return true else : return false
value s = state ( value ) if ( s is none ) : return false elif ( s [ 0 ] == error ) : return true else : return false s = state ( value ) if ( s is none ) : return false elif ( s [ 0 ] == error ) : return true else : return false
def with open ( flags list , ' r ' ) as input : return json . load ( input with open ( flags list , ' r ' ) as input : return json . load ( input )
header padding = ( 72 ( len ( header ) // 2 ) ) print ( ) dsz . ui . echo ( ( ( ( ( ( ' ' * padding ) + ' ' ) + header ) + ' ' ) + ( ' ' * padding ) ) , dsz . good er padding = ( 72 ( len ( header ) // 2 ) ) print ( ) dsz . ui . echo ( ( ( ( ( ( ' ' * padding ) + ' ' ) + header ) + ' ' ) + ( ' ' * padding ) ) , dsz . good )
self return self . processor . flag return self . processor . flags
self , ignore = [ ] return self . processor . process child elements ( self . element , ignore , ignore = [ ] return self . processor . process child elements ( self . element , ignore )
self enforce ( false , ( lambda : ( " xml element handeler ' validate ' not implemented for %s " % self . class ) ) enforce ( false , ( lambda : ( " xml element handeler ' validate ' not implemented for %s " % self . class ) ) )
self self . process ( validate = true self . process ( validate = true )
self return self . handler ( validate = true return self . handler ( validate = true )
self self . handler ( self . handler ( )
self return self . process ( validate = true return self . process ( validate = true )
self return self . process ( return self . process ( )
maxage = datetime . timedelta ( 0 ) , target id = none if ( target id is none ) : target id = ops . project . get target id ( ) ifconfig data = get ifconfig ( maxage = maxage , target id = target id ) return ifconfig data . interfaceitege = datetime . timedelta ( 0 ) , target id = none if ( target id is none ) : target id = ops . project . get target id ( ) ifconfig data = get ifconfig ( maxage = maxage , target id = target id ) return ifconfig data . interfaceitem
maxage = timedelta ( seconds = 0 ) , target id = none , use volatile = false , cmd options = dict ( ) pasge = timedelta ( seconds = 0 ) , target id = none , use volatile = false , cmd options = dict ( ) pass
maxage = timedelta ( seconds = 0 ) , target id = none , use volatile = false , cmd options = dict ( ) pasge = timedelta ( seconds = 0 ) , target id = none , use volatile = false , cmd options = dict ( ) pass
maxage = timedelta ( seconds = 0 ) , target id = none , use volatile = false , cmd options = dict ( ) pasge = timedelta ( seconds = 0 ) , target id = none , use volatile = false , cmd options = dict ( ) pass
dsz cmd return str ( dsz cmd ) . lower ( ) . strip ( cmd return str ( dsz cmd ) . lower ( ) . strip ( )
dsz cmd if ( not ( type ( dsz cmd ) == type ( ops . cmd . get dsz command ( ' redirect ' ) ) ) ) : return false if ( not ( convert str ( dsz cmd . plugin ) == ' redirect ' ) ) : return false return trucmd if ( not ( type ( dsz cmd ) == type ( ops . cmd . get dsz command ( ' redirect ' ) ) ) ) : return false if ( not ( convert str ( dsz cmd . plugin ) == ' redirect ' ) ) : return false return true
self for opt in self . optdict : if ( opt not in valid options ) : return false return tru for opt in self . optdict : if ( opt not in valid options ) : return false return true
self for opt in self . optdict : if ( opt not in valid options ) : return false return tru for opt in self . optdict : if ( opt not in valid options ) : return false return true
self if ( ' mask ' in self . optdict ) : return self . optdict [ ' mask ' ] else : return ' * ' if ( ' mask ' in self . optdict ) : return self . optdict [ ' mask ' ] else : return ' * '
self , val val = val . strip ( ) if ( ( val is not none ) and ( val != ' ' ) ) : self . optdict [ ' mask ' ] = val else : del self . optdict [ ' mask ' , val val = val . strip ( ) if ( ( val is not none ) and ( val != ' ' ) ) : self . optdict [ ' mask ' ] = val else : del self . optdict [ ' mask ' ]
self if ( ' path ' in self . optdict ) : return self . optdict [ ' path ' ] else : return non if ( ' path ' in self . optdict ) : return self . optdict [ ' path ' ] else : return none
self , val if val : self . optdict [ ' recursive ' ] = true else : del self . optdict [ ' recursive ' , val if val : self . optdict [ ' recursive ' ] = true else : del self . optdict [ ' recursive ' ]
self if ( ' dirsonly ' in self . optdict ) : return true else : return fals if ( ' dirsonly ' in self . optdict ) : return true else : return false
self , val if val : self . optdict [ ' dirsonly ' ] = true else : del self . optdict [ ' dirsonly ' , val if val : self . optdict [ ' dirsonly ' ] = true else : del self . optdict [ ' dirsonly ' ]
self if ( ' time ' in self . optdict ) : return self . optdict [ ' time ' ] else : return ' modified ' if ( ' time ' in self . optdict ) : return self . optdict [ ' time ' ] else : return ' modified '
self , val if ( val in [ ' modified ' , ' created ' , ' accessed ' ] ) : self . optdict [ ' time ' ] = val elif ( val is none ) : del self . optdict [ ' time ' ] else : raise ops command exception ( ' time must be one of accessed|created|modified ' , val if ( val in [ ' modified ' , ' created ' , ' accessed ' ] ) : self . optdict [ ' time ' ] = val elif ( val is none ) : del self . optdict [ ' time ' ] else : raise ops command exception ( ' time must be one of accessed|created|modified ' )
self if ( ' age ' in self . optdict ) : return self . optdict [ ' age ' ] else : return non if ( ' age ' in self . optdict ) : return self . optdict [ ' age ' ] else : return none
self if ( ' before ' in self . optdict ) : return self . optdict [ ' before ' ] else : return non if ( ' before ' in self . optdict ) : return self . optdict [ ' before ' ] else : return none
self if ( ' max ' in self . optdict ) : return self . optdict [ ' max ' ] else : return non if ( ' max ' in self . optdict ) : return self . optdict [ ' max ' ] else : return none
self , val if ( val is not none ) : try : val = int ( val ) except : raise ops command exception ( ' max for a dir command must be an integer ' ) self . optdict [ ' max ' ] = val else : del self . optdict [ ' max ' , val if ( val is not none ) : try : val = int ( val ) except : raise ops command exception ( ' max for a dir command must be an integer ' ) self . optdict [ ' max ' ] = val else : del self . optdict [ ' max ' ]
self if ( ' hash ' in self . optdict ) : return self . optdict [ ' hash ' ] else : return non if ( ' hash ' in self . optdict ) : return self . optdict [ ' hash ' ] else : return none
self , val if ( val is not none ) : self . optdict [ ' hash ' ] = val else : del self . optdict [ ' hash ' , val if ( val is not none ) : self . optdict [ ' hash ' ] = val else : del self . optdict [ ' hash ' ]
self if ( ' chunksize ' in self . optdict ) : return self . optdict [ ' chunksize ' ] else : return non if ( ' chunksize ' in self . optdict ) : return self . optdict [ ' chunksize ' ] else : return none
self , val if ( val is not none ) : try : val = int ( val ) except : raise ops command exception ( ' chunksize for a dir command must be an integer ' ) self . optdict [ ' chunksize ' ] = val else : del self . optdict [ ' chunksize ' , val if ( val is not none ) : try : val = int ( val ) except : raise ops command exception ( ' chunksize for a dir command must be an integer ' ) self . optdict [ ' chunksize ' ] = val else : del self . optdict [ ' chunksize ' ]
self return self . optdict [ ' hive ' return self . optdict [ ' hive ' ]
self if ( ' key ' in self . optdict ) : return self . optdict [ ' key ' ] else : return non if ( ' key ' in self . optdict ) : return self . optdict [ ' key ' ] else : return none
self if ( ' value ' in self . optdict ) : return self . optdict [ ' value ' ] else : return non if ( ' value ' in self . optdict ) : return self . optdict [ ' value ' ] else : return none
self if ( ( ' recursive ' in self . optdict ) and self . optdict [ ' recursive ' ] ) : return true else : return fals if ( ( ' recursive ' in self . optdict ) and self . optdict [ ' recursive ' ] ) : return true else : return false
self , val if val : self . optdict [ ' recursive ' ] = true elif ( ' recursive ' in self . optdict ) : del self . optdict [ ' recursive ' , val if val : self . optdict [ ' recursive ' ] = true elif ( ' recursive ' in self . optdict ) : del self . optdict [ ' recursive ' ]
self , val if val : self . optdict [ ' wow64 ' ] = val elif ( ' wow64 ' in self . optdict ) : del self . optdict [ ' wow64 ' , val if val : self . optdict [ ' wow64 ' ] = val elif ( ' wow64 ' in self . optdict ) : del self . optdict [ ' wow64 ' ]
self , val if val : self . optdict [ ' wow32 ' ] = val elif ( ' wow32 ' in self . optdict ) : del self . optdict [ ' wow32 ' , val if val : self . optdict [ ' wow32 ' ] = val elif ( ' wow32 ' in self . optdict ) : del self . optdict [ ' wow32 ' ]
self if ( ' chunksize ' in self . optdict ) : return self . optdict [ ' chunksize ' ] else : return non if ( ' chunksize ' in self . optdict ) : return self . optdict [ ' chunksize ' ] else : return none
self return self . opt initia return self . opt initial
self , buffer size assert ( ( buffer size is none ) or ( ( type ( buffer size ) is int ) and ( buffer size > 0 ) ) ) , ' buffer size must be an integer greater than zero; or none to clear this option . ' self . opt initial = buffer siz , buffer size assert ( ( buffer size is none ) or ( ( type ( buffer size ) is int ) and ( buffer size > 0 ) ) ) , ' buffer size must be an integer greater than zero; or none to clear this option . ' self . opt initial = buffer size
self return self . opt bar return self . opt bare
self , bare assert ( type ( bare ) is bool ) , ' bare must be boolean . ' self . opt bare = bar , bare assert ( type ( bare ) is bool ) , ' bare must be boolean . ' self . opt bare = bare
self return self . opt targe return self . opt target
self if ( ( self . data is not none ) and ( self . object number is not none ) ) : return false if ( ( self . data is none ) and ( self . object number is none ) ) : return false return tru if ( ( self . data is not none ) and ( self . object number is not none ) ) : return false if ( ( self . data is none ) and ( self . object number is none ) ) : return false return true
self return do safety handlers ( self return do safety handlers ( self )
self return ( ' background ' in self . prefixes return ( ' background ' in self . prefixes )
self , val if ( val and ( not ( ' background ' in self . prefixes ) ) ) : self . prefixes . append ( ' background ' ) elif ( ( not val ) and ( ' background ' in self . prefixes ) ) : self . prefixes . remove ( ' background ' , val if ( val and ( not ( ' background ' in self . prefixes ) ) ) : self . prefixes . append ( ' background ' ) elif ( ( not val ) and ( ' background ' in self . prefixes ) ) : self . prefixes . remove ( ' background ' )
self return ( ' monitor ' in self . prefixes return ( ' monitor ' in self . prefixes )
self , val if ( val and ( not ( ' monitor ' in self . prefixes ) ) ) : self . prefixes . append ( ' monitor ' ) elif ( ( not val ) and ( ' monitor ' in self . prefixes ) ) : self . prefixes . remove ( ' monitor ' , val if ( val and ( not ( ' monitor ' in self . prefixes ) ) ) : self . prefixes . append ( ' monitor ' ) elif ( ( not val ) and ( ' monitor ' in self . prefixes ) ) : self . prefixes . remove ( ' monitor ' )
self for prefix in self . prefixes : if ( prefix . find ( ' user ' ) == 0 ) : splits = prefix . split ( ' = ' ) return splits [ 1 ] else : return non for prefix in self . prefixes : if ( prefix . find ( ' user ' ) == 0 ) : splits = prefix . split ( ' = ' ) return splits [ 1 ] else : return none
self , val if ( val and ( not ( ' log ' in self . prefixes ) ) ) : self . prefixes . append ( ' log ' ) elif ( ( not val ) and ( ' log ' in self . prefixes ) ) : self . prefixes . remove ( ' log ' , val if ( val and ( not ( ' log ' in self . prefixes ) ) ) : self . prefixes . append ( ' log ' ) elif ( ( not val ) and ( ' log ' in self . prefixes ) ) : self . prefixes . remove ( ' log ' )
self for prefix in self . prefixes : if ( prefix . find ( ' dst= ' ) == 0 ) : splits = prefix . split ( ' = ' ) return splits [ 1 ] else : return non for prefix in self . prefixes : if ( prefix . find ( ' dst= ' ) == 0 ) : splits = prefix . split ( ' = ' ) return splits [ 1 ] else : return none
self , value for prefix in self . prefixes : if ( prefix . find ( ' dst= ' ) == 0 ) : self . prefixes . remove ( prefix ) if ( value is none ) : return self . prefixes . append ( ( ' dst=%s ' % value ) , value for prefix in self . prefixes : if ( prefix . find ( ' dst= ' ) == 0 ) : self . prefixes . remove ( prefix ) if ( value is none ) : return self . prefixes . append ( ( ' dst=%s ' % value ) )
self return self . succes return self . success
self return self . channe return self . channel
self return self . plugi return self . plugin
obj , optname return ( ( optname in obj . optdict ) and obj . optdict [ optname ] , optname return ( ( optname in obj . optdict ) and obj . optdict [ optname ] )
obj , optname if ( optname in obj . optdict ) : return obj . optdict [ optname ] else : return non , optname if ( optname in obj . optdict ) : return obj . optdict [ optname ] else : return none
obj , val , optname if ( ( optname in obj . optdict ) and ( ( val is none ) or ( val is false ) ) ) : del obj . optdict [ optname ] elif val : obj . optdict [ optname ] = tru , val , optname if ( ( optname in obj . optdict ) and ( ( val is none ) or ( val is false ) ) ) : del obj . optdict [ optname ] elif val : obj . optdict [ optname ] = true
plugin , reason flags = dsz . control . method ( ) dsz . control . echo . off ( ) ret = dsz . cmd . run ( ( ' wrappers register %s " %s " pre script wrappers/disabled . py project ops ' % ( plugin , reason ) ) ) del flags return rein , reason flags = dsz . control . method ( ) dsz . control . echo . off ( ) ret = dsz . cmd . run ( ( ' wrappers register %s " %s " pre script wrappers/disabled . py project ops ' % ( plugin , reason ) ) ) del flags return ret
self if ( ' disable ' in self . optdict ) : return self . optdict [ ' disable ' ] else : return non if ( ' disable ' in self . optdict ) : return self . optdict [ ' disable ' ] else : return none
self return ( ( ' force ' in self . optdict ) and self . optdict [ ' force ' ] return ( ( ' force ' in self . optdict ) and self . optdict [ ' force ' ] )
self return ( ( ' status ' in self . optdict ) and self . optdict [ ' status ' ] return ( ( ' status ' in self . optdict ) and self . optdict [ ' status ' ] )
self , val if ( ( ( val is none ) or ( val is false ) ) and ( ' status ' in self . optdict ) ) : del self . optdict [ ' status ' ] elif val : self . optdict [ ' status ' ] = tru , val if ( ( ( val is none ) or ( val is false ) ) and ( ' status ' in self . optdict ) ) : del self . optdict [ ' status ' ] elif val : self . optdict [ ' status ' ] = true
self return ( ( ' on ' in self . optdict ) and self . optdict [ ' on ' ] return ( ( ' on ' in self . optdict ) and self . optdict [ ' on ' ] )
self , val if ( ( ( val is none ) or ( val is false ) ) and ( ' on ' in self . optdict ) ) : del self . optdict [ ' on ' ] elif val : self . optdict [ ' on ' ] = true self . optdict [ ' off ' ] = fals , val if ( ( ( val is none ) or ( val is false ) ) and ( ' on ' in self . optdict ) ) : del self . optdict [ ' on ' ] elif val : self . optdict [ ' on ' ] = true self . optdict [ ' off ' ] = false
self return ( ( ' off ' in self . optdict ) and self . optdict [ ' off ' ] return ( ( ' off ' in self . optdict ) and self . optdict [ ' off ' ] )
self , val if ( ( ( val is none ) or ( val is false ) ) and ( ' off ' in self . optdict ) ) : del self . optdict [ ' off ' ] elif val : self . optdict [ ' off ' ] = true self . optdict [ ' on ' ] = fals , val if ( ( ( val is none ) or ( val is false ) ) and ( ' off ' in self . optdict ) ) : del self . optdict [ ' off ' ] elif val : self . optdict [ ' off ' ] = true self . optdict [ ' on ' ] = false
def return ops . cmd . quickrun ( ' commands ' return ops . cmd . quickrun ( ' commands ' )
self for opt in self . optdict : if ( opt not in valid options ) : return false return tru for opt in self . optdict : if ( opt not in valid options ) : return false return true
self for opt in self . optdict : if ( opt not in valid options ) : return false for req in self . reqopts : if ( req not in self . optdict ) : return false return tru for opt in self . optdict : if ( opt not in valid options ) : return false for req in self . reqopts : if ( req not in self . optdict ) : return false return true
self return self . auto minima return self . auto minimal
self , val self . auto minimal = va , val self . auto minimal = val
self for opt in self . optdict : if ( opt not in valid options ) : return false return tru for opt in self . optdict : if ( opt not in valid options ) : return false return true
self if self . tcp : return ' tcp ' elif self . udp : return ' udp ' else : return non if self . tcp : return ' tcp ' elif self . udp : return ' udp ' else : return none
self , val if ( val == tcp ) : self . tcp = true elif ( val == udp ) : self . udp = true else : raise ops command exception ( ' protocol must be tcp or udp ' , val if ( val == tcp ) : self . tcp = true elif ( val == udp ) : self . udp = true else : raise ops command exception ( ' protocol must be tcp or udp ' )
self if ( ( ' tcp ' in self . optdict ) and self . optdict [ ' tcp ' ] ) : return true else : return fals if ( ( ' tcp ' in self . optdict ) and self . optdict [ ' tcp ' ] ) : return true else : return false
self return self . directio return self . direction
self , val if ( not ( val in [ implantlisten , lplisten ] ) ) : raise ops command exception ( ' redirect command: direction must be one of lplisten or implantlisten ' ) self . direction = va , val if ( not ( val in [ implantlisten , lplisten ] ) ) : raise ops command exception ( ' redirect command: direction must be one of lplisten or implantlisten ' ) self . direction = val
self return self . listenpor return self . listenport
self , val val = int ( val ) if ( ( val < 0 ) or ( val > 65535 ) ) : raise ops command exception ( ' listen port must be an integer between 0 65535 ' ) self . listenport = va , val val = int ( val ) if ( ( val < 0 ) or ( val > 65535 ) ) : raise ops command exception ( ' listen port must be an integer between 0 65535 ' ) self . listenport = val
self , val if ( val is none ) : self . bind addr = ' 0 . 0 . 0 . 0 ' elif util . ip . validate ( val ) : self . bind addr = va , val if ( val is none ) : self . bind addr = ' 0 . 0 . 0 . 0 ' elif util . ip . validate ( val ) : self . bind addr = val
self if ( self . direction == lplisten ) : retval = str ( self . listen port ) if ( self . bind address != ' 0 . 0 . 0 . 0 ' ) : retval += ( ' %s ' % self . bind address ) return retval else : return non if ( self . direction == lplisten ) : retval = str ( self . listen port ) if ( self . bind address != ' 0 . 0 . 0 . 0 ' ) : retval += ( ' %s ' % self . bind address ) return retval else : return none
self return self . target add return self . target addr
self , value value = value . strip ( ) if util . ip . validate ( value ) : self . target addr = value else : raise ops command exception ( ' invalid target ip address ' , value value = value . strip ( ) if util . ip . validate ( value ) : self . target addr = value else : raise ops command exception ( ' invalid target ip address ' )
self return self . source addr . strip ( return self . source addr . strip ( )
self , value value = value . strip ( ) if util . ip . validate ( value ) : self . source addr = value else : raise ops command exception ( ( ' invalid source ip address %s ' % value ) , value value = value . strip ( ) if util . ip . validate ( value ) : self . source addr = value else : raise ops command exception ( ( ' invalid source ip address %s ' % value ) )
self return self . source por return self . source port
self return self . client por return self . client port
self if ( self . client port > ( 1 ) ) : return ( ' %d %s ' % ( self . client port , self . client address ) ) else : return non if ( self . client port > ( 1 ) ) : return ( ' %d %s ' % ( self . client port , self . client address ) ) else : return none
self return self . limit add return self . limit addr
self , value value = value . strip ( ) if util . ip . validate ( value ) : self . limit mask = value else : raise ops command exception ( ( ' invalid limit mask %s ' % value ) , value value = value . strip ( ) if util . ip . validate ( value ) : self . limit mask = value else : raise ops command exception ( ( ' invalid limit mask %s ' % value ) )
self if ( ' connections ' in self . optdict ) : return self . optdict [ ' connections ' ] else : return if ( ' connections ' in self . optdict ) : return self . optdict [ ' connections ' ] else : return 0
self , value if ( value is not none ) : try : value = int ( value ) self . optdict [ ' connections ' ] = value except value error : raise ops command exception ( ' max connections for a redirect command must be an integer >= 0 ' ) else : self . optdict [ ' connections ' ] = , value if ( value is not none ) : try : value = int ( value ) self . optdict [ ' connections ' ] = value except value error : raise ops command exception ( ' max connections for a redirect command must be an integer >= 0 ' ) else : self . optdict [ ' connections ' ] = 0
self if ( ( ' sendnotify ' in self . optdict ) and self . optdict [ ' sendnotify ' ] ) : return true else : return fals if ( ( ' sendnotify ' in self . optdict ) and self . optdict [ ' sendnotify ' ] ) : return true else : return false
self , val if ( ( ( val is none ) or ( val is false ) ) and ( ' sendnotify ' in self . optdict ) ) : del self . optdict [ ' sendnotify ' ] elif ( val is true ) : self . optdict [ ' sendnotify ' ] = va , val if ( ( ( val is none ) or ( val is false ) ) and ( ' sendnotify ' in self . optdict ) ) : del self . optdict [ ' sendnotify ' ] elif ( val is true ) : self . optdict [ ' sendnotify ' ] = val
self if ( self . validate input ( ) and ( ops . env . get ( ' ops noinject ' ) . upper ( ) != ' true ' ) ) : return ( true , ' ' ) else : return ( false , ' ops noinject is set to true , you should probably not run passworddump ' if ( self . validate input ( ) and ( ops . env . get ( ' ops noinject ' ) . upper ( ) != ' true ' ) ) : return ( true , ' ' ) else : return ( false , ' ops noinject is set to true , you should probably not run passworddump ' )
self return self . opt lis return self . opt list
self , list assert ( type ( list ) is bool ) , ' list option must be boolean . ' self . opt list = lis , list assert ( type ( list ) is bool ) , ' list option must be boolean . ' self . opt list = list
self return self . opt monito return self . opt monitor
self return self . opt minima return self . opt minimal
self , minimal assert ( type ( minimal ) is bool ) , ' minimal option must be boolean . ' self . opt minimal = minima , minimal assert ( type ( minimal ) is bool ) , ' minimal option must be boolean . ' self . opt minimal = minimal
self return self . opt ignor return self . opt ignore
self return self . opt targe return self . opt target
self return ( self . list ^ bool ( self . monitor ) return ( self . list ^ bool ( self . monitor ) )
maxage = timedelta ( seconds = 0 ) , target id = none , use volatile = false servlist = get service list ( maxage = maxage , target id = target id ) return filter ( ( lambda x : ( x . state == ' running ' ) ) , servlist ge = timedelta ( seconds = 0 ) , target id = none , use volatile = false servlist = get service list ( maxage = maxage , target id = target id ) return filter ( ( lambda x : ( x . state == ' running ' ) ) , servlist )
maxage = datetime . timedelta . max , target id = none time cmd = ops . cmd . get dsz command ( ' time ' ) return ( ops . project . generic cache get ( time cmd , time tag , maxage = maxage , target id = target id ) . timeitem , datetime . datetime . utcnow ( ) ge = datetime . timedelta . max , target id = none time cmd = ops . cmd . get dsz command ( ' time ' ) return ( ops . project . generic cache get ( time cmd , time tag , maxage = maxage , target id = target id ) . timeitem , datetime . datetime . utcnow ( ) )
maxage = datetime . timedelta . max , target id = none ( timeitem , now ) = sync ( maxage , target id ) return timeitem . friendly biage = datetime . timedelta . max , target id = none ( timeitem , now ) = sync ( maxage , target id ) return timeitem . friendly bias
maxage = datetime . timedelta . max , target id = none ( timeitem , now ) = sync ( maxage , target id ) return ( ( now + timeitem . skew ) + timeitem . friendly bias ge = datetime . timedelta . max , target id = none ( timeitem , now ) = sync ( maxage , target id ) return ( ( now + timeitem . skew ) + timeitem . friendly bias )
target id = none return ops . system . registry . get registrykey ( ' l ' , ' software\\\\ microsoft\\\\ windows nt\\\\ current version\\\\ profile list ' , cache tag = ' ops system profilespath ' , use volatile = false ) . key [ 0 ] [ ' profiles directory ' ] . valuet id = none return ops . system . registry . get registrykey ( ' l ' , ' software\\\\ microsoft\\\\ windows nt\\\\ current version\\\\ profile list ' , cache tag = ' ops system profilespath ' , use volatile = false ) . key [ 0 ] [ ' profiles directory ' ] . value
project = none if ( project is none ) : projectdb = ops . project . get pdb ( ) else : projectdb = ops . project . get pdb ( project = project ) projectdb . ensure table ( ' drivertracker ' , ' create table drivertracker (targetid , driver , path , first seen , sha1 , reported , pulled) ' ect = none if ( project is none ) : projectdb = ops . project . get pdb ( ) else : projectdb = ops . project . get pdb ( project = project ) projectdb . ensure table ( ' drivertracker ' , ' create table drivertracker (targetid , driver , path , first seen , sha1 , reported , pulled) ' )
cmd return ( false , ' because of psp concerns , this command is not recommended . ' return ( false , ' because of psp concerns , this command is not recommended . ' )
def env data = ops . system . environment . get environment ( maxage = timedelta ( seconds = 600 ) , use volatile = true ) retval = dict ( ) for env var in env data . environment . value : retval [ env var . name ] = env var . value return retvaenv data = ops . system . environment . get environment ( maxage = timedelta ( seconds = 600 ) , use volatile = true ) retval = dict ( ) for env var in env data . environment . value : retval [ env var . name ] = env var . value return retval
self , procparms valid = true for parm in procparms : if ( not ( parm in self . processparms ) ) : valid = false return vali , procparms valid = true for parm in procparms : if ( not ( parm in self . processparms ) ) : valid = false return valid
self action . execute ( self ) self . path = self . execparams [ ' directory ' ] mask = self . execparams . get ( ' dirmask ' , ' * ' ) self . result = get dir list ( mask = mask , path = self . path ) return ( self . result is not none action . execute ( self ) self . path = self . execparams [ ' directory ' ] mask = self . execparams . get ( ' dirmask ' , ' * ' ) self . result = get dir list ( mask = mask , path = self . path ) return ( self . result is not none )
self , varname ret = none if ( varname == ' filename ' ) : ret = os . path . join ( self . path , self . result [ 0 ] ) elif ( varname == ' directory ' ) : ret = self . path return re , varname ret = none if ( varname == ' filename ' ) : ret = os . path . join ( self . path , self . result [ 0 ] ) elif ( varname == ' directory ' ) : ret = self . path return ret
self , goodif parsed = shallow ( parser . st2list ( parser . expr ( goodif ) ) ) [ 0 ] if ( not isinstance ( parsed , list ) ) : parsed = [ parsed ] return parse , goodif parsed = shallow ( parser . st2list ( parser . expr ( goodif ) ) ) [ 0 ] if ( not isinstance ( parsed , list ) ) : parsed = [ parsed ] return parsed
self , vendor data return self . add attribute package ( vendor data , vendor data return self . add attribute package ( vendor data )
self return self . get all ps ps ( return self . get all ps ps ( )
self return self . get all ps ps ( ) [ ( 1 ) return self . get all ps ps ( ) [ ( 1 ) ]
self action . execute ( self ) self . result = self . execparams [ ' text ' ] return tru action . execute ( self ) self . result = self . execparams [ ' text ' ] return true
self action . execute ( self ) self . result = self . parent . process ( self . execparams ) return ( self . result is not none action . execute ( self ) self . result = self . parent . process ( self . execparams ) return ( self . result is not none )
str return util . ip . validate ( str return util . ip . validate ( str )
self ret = { } for attr in self . data to save . values ( ) : if attr . config : ret [ attr . name ] = self [ attr . name ] return re ret = { } for attr in self . data to save . values ( ) : if attr . config : ret [ attr . name ] = self [ attr . name ] return ret
self , attr if isinstance ( attr , psp attribute ) : attr = attr . name try : atobj = self . data to save [ attr . lower ( ) ] return atobj . display except : return ' ' , attr if isinstance ( attr , psp attribute ) : attr = attr . name try : atobj = self . data to save [ attr . lower ( ) ] return atobj . display except : return ' '
lst return ( ( lambda psp : isinstance ( psp , psp ) ) , lst return ( ( lambda psp : isinstance ( psp , psp ) ) , lst )
lst if ( not ( type ( lst ) == list ) ) : lst = [ lst ] return ( ( lambda psp : ( not ( psp . vendor == none ) ) ) , lst if ( not ( type ( lst ) == list ) ) : lst = [ lst ] return ( ( lambda psp : ( not ( psp . vendor == none ) ) ) , lst )
vendor return get previous config ( vendor or return get previous config ( vendor )
lines , echocode for line in lines : dsz . ui . echo ( line , echocode s , echocode for line in lines : dsz . ui . echo ( line , echocode )
vendor return os . path . join ( ops . data , ' psp f ps ' , ' {0} fp . xml ' . format ( vendor ) or return os . path . join ( ops . data , ' psp f ps ' , ' {0} fp . xml ' . format ( vendor ) )
vendor return os . path . join ( ops . data , ' psp f ps ' , ' {0} actions . xml ' . format ( vendor ) or return os . path . join ( ops . data , ' psp f ps ' , ' {0} actions . xml ' . format ( vendor ) )
mac assert ( ( type ( mac ) is str ) or ( type ( mac ) is unicode ) ) , ' mac must be a string representation . ' norm mac = normalize ( mac ) return validate ethii ( norm mac assert ( ( type ( mac ) is str ) or ( type ( mac ) is unicode ) ) , ' mac must be a string representation . ' norm mac = normalize ( mac ) return validate ethii ( norm mac )
def lastid = dsz . cmd . last id ( ) return dsz command metadata ( lastid lastid = dsz . cmd . last id ( ) return dsz command metadata ( lastid )
input fullpath = dsz . ui . get string ( ' please enter the full path to the file you want parse: ' , ' ' ) if ( fullpath == ' ' ) : dsz . ui . echo ( ' no string entered ' , dsz . error ) return false return parsefile ( fullpath t fullpath = dsz . ui . get string ( ' please enter the full path to the file you want parse: ' , ' ' ) if ( fullpath == ' ' ) : dsz . ui . echo ( ' no string entered ' , dsz . error ) return false return parsefile ( fullpath )
input if dsz . version . checks . is os64 bit ( ) : dll path = ' uploads\\\\x64\\\\mssli64 . dll ' else : dll path = ' uploads\\\\i386\\\\mssli . dll ' return dll u ( ( ' %s\\\\%s ' % ( stla path , dll path ) ) t if dsz . version . checks . is os64 bit ( ) : dll path = ' uploads\\\\x64\\\\mssli64 . dll ' else : dll path = ' uploads\\\\i386\\\\mssli . dll ' return dll u ( ( ' %s\\\\%s ' % ( stla path , dll path ) ) )
input if dsz . version . checks . is os64 bit ( ) : dll path = ' uploads\\\\x64\\\\mssld64 . dll ' else : dll path = ' uploads\\\\i386\\\\mssld . dll ' if dll u ( ( ' %s\\\\%s ' % ( stla path , dll path ) ) ) : return collectfiles ( ) return falst if dsz . version . checks . is os64 bit ( ) : dll path = ' uploads\\\\x64\\\\mssld64 . dll ' else : dll path = ' uploads\\\\i386\\\\mssld . dll ' if dll u ( ( ' %s\\\\%s ' % ( stla path , dll path ) ) ) : return collectfiles ( ) return false
input success = dll u ( ( ' %s\\\\ uploads\\\\msgkd . dll ' % grok path ) ) if ( not success ) : return false success = collectfiles ( ) if ( not success ) : return false return trut success = dll u ( ( ' %s\\\\ uploads\\\\msgkd . dll ' % grok path ) ) if ( not success ) : return false success = collectfiles ( ) if ( not success ) : return false return true
curpath dsz . control . echo . off ( ) cmd = ( ' cd %s ' % curpath ) dsz . cmd . run ( cmd ) dsz . control . echo . on ( ) return truath dsz . control . echo . off ( ) cmd = ( ' cd %s ' % curpath ) dsz . cmd . run ( cmd ) dsz . control . echo . on ( ) return true
input global file name file name = dsz . ui . get string ( ' new upload name for grok: ' , ' help16 . exe ' ) dsz . ui . echo ( ( ' *** upload name now set to %s *** ' % file name ) , dsz . warning t global file name file name = dsz . ui . get string ( ' new upload name for grok: ' , ' help16 . exe ' ) dsz . ui . echo ( ( ' *** upload name now set to %s *** ' % file name ) , dsz . warning )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key params buffer size , self . dict [ ' buffer size ' ] ) mmsg . add message ( msg key params , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key params buffer size , self . dict [ ' buffer size ' ] ) mmsg . add message ( msg key params , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result string value , self . dict [ ' str ' ] ) mmsg . add message ( msg key result string , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result string value , self . dict [ ' str ' ] ) mmsg . add message ( msg key result string , submsg )
self try : self . ge zu kernel memory response = ge zu kernel memory . ge zu kernel memory response ( dsz . cmd . data . get ( ' ge zu kernel memory response ' , dsz . type object ) [ 0 ] ) except : self . ge zu kernel memory response = none retur try : self . ge zu kernel memory response = ge zu kernel memory . ge zu kernel memory response ( dsz . cmd . data . get ( ' ge zu kernel memory response ' , dsz . type object ) [ 0 ] ) except : self . ge zu kernel memory response = none return
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result server server , self . dict [ ' server ' ] ) mmsg . add message ( msg key result server , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result server server , self . dict [ ' server ' ] ) mmsg . add message ( msg key result server , submsg )
self , content dsz . data . task reader . characters ( self , content ) content = ' ' . join ( content . encode ( ' utf 8 ' ) ) if self . current text == none : self . current text = content else : self . current text += content retur , content dsz . data . task reader . characters ( self , content ) content = ' ' . join ( content . encode ( ' utf 8 ' ) ) if self . current text == none : self . current text = content else : self . current text += content return
self , index if index < 0 or index >= len ( self . column item ) : return none else : return self . column item [ index ] . nam , index if index < 0 or index >= len ( self . column item ) : return none else : return self . column item [ index ] . name
self , cell , index , name while len ( self . table data ) <= index : self . table data . append ( none ) self . table data [ index ] = cell if name : self . cells . setattr ( name , cell ) retur , cell , index , name while len ( self . table data ) <= index : self . table data . append ( none ) self . table data [ index ] = cell if name : self . cells . setattr ( name , cell ) return
self return [ ' arp query ' return [ ' arp query ' ]
self return [ ' netmap minimal ' return [ ' netmap minimal ' ]
string , size while ( len ( string ) < ( size 1 ) ) : string = ( ' %s ' % string ) return strinng , size while ( len ( string ) < ( size 1 ) ) : string = ( ' %s ' % string ) return string
self return [ ' route query ' return [ ' route query ' ]
filename , path for key in tasking options . keys ( ) : if ( key . lower ( ) in filename . lower ( ) ) : t = tasking options [ key ] return t ( ( ' %s/%s ' % ( path , filename ) ) ) return nonname , path for key in tasking options . keys ( ) : if ( key . lower ( ) in filename . lower ( ) ) : t = tasking options [ key ] return t ( ( ' %s/%s ' % ( path , filename ) ) ) return none
self return [ ' language ' return [ ' language ' ]
self return [ ' audit status ' return [ ' audit status ' ]
self return [ ' ifconfig ' return [ ' ifconfig ' ]
self return fals return false
self raise exception ( ( ' this task is incomplete: %s ' % self . name ) raise exception ( ( ' this task is incomplete: %s ' % self . name ) )
self dsz . ui . echo ( ( ' task: %s ' % self . name ) ) pas dsz . ui . echo ( ( ' task: %s ' % self . name ) ) pass
self return self . verif return self . verify
self return [ ' netstat list ' return [ ' netstat list ' ]
self raise runtime error ( ' threads are not supported in embedded dsz python scripts ' raise runtime error ( ' threads are not supported in embedded dsz python scripts ' )
self self . acquire = self . semlock . acquire self . release = self . semlock . releas self . acquire = self . semlock . acquire self . release = self . semlock . release
self return self . semlock . get value ( return self . semlock . get value ( )
self self . acquire = self . lock . acquire self . release = self . lock . releas self . acquire = self . lock . acquire self . release = self . lock . release
self self . cond . acquire ( ) try : if self . flag . acquire ( false ) : self . flag . release ( ) return true return false finally : self . cond . release ( self . cond . acquire ( ) try : if self . flag . acquire ( false ) : self . flag . release ( ) return true return false finally : self . cond . release ( )
self self . cond . acquire ( ) try : self . flag . acquire ( false ) finally : self . cond . release ( self . cond . acquire ( ) try : self . flag . acquire ( false ) finally : self . cond . release ( )
conn return conn . recv ( return conn . recv ( )
conn return multiprocessing . recvfd ( conn . fileno ( ) return multiprocessing . recvfd ( conn . fileno ( ) )
obj global lock , listener , cache for h in cache : close ( h ) cache . clear ( ) lock = threading . lock ( ) listener = nonglobal lock , listener , cache for h in cache : close ( h ) cache . clear ( ) lock = threading . lock ( ) listener = none
handle if popen . thread is spawning ( ) : return ( none , popen . duplicate for child ( handle ) , true ) dup handle = duplicate ( handle ) cache . add ( dup handle ) sub debug ( ' reducing handle %d ' , handle ) return ( get listener ( ) . address , dup handle , false le if popen . thread is spawning ( ) : return ( none , popen . duplicate for child ( handle ) , true ) dup handle = duplicate ( handle ) cache . add ( dup handle ) sub debug ( ' reducing handle %d ' , handle ) return ( get listener ( ) . address , dup handle , false )
conn rh = reduce handle ( conn . fileno ( ) ) return rebuild connection , ( rh , conn . readable , conn . writable rh = reduce handle ( conn . fileno ( ) ) return rebuild connection , ( rh , conn . readable , conn . writable )
reduced handle , readable , writable handle = rebuild handle ( reduced handle ) return multiprocessing . connection ( handle , readable = readable , writable = writable ced handle , readable , writable handle = rebuild handle ( reduced handle ) return multiprocessing . connection ( handle , readable = readable , writable = writable )
fd , family , type , proto = 0 s = socket . fromfd ( fd , family , type , proto ) if s . class is not socket . socket : s = socket . socket ( sock = s ) return , family , type , proto = 0 s = socket . fromfd ( fd , family , type , proto ) if s . class is not socket . socket : s = socket . socket ( sock = s ) return s
reduced handle , family , type , proto fd = rebuild handle ( reduced handle ) sock = fromfd ( fd , family , type , proto ) close ( fd ) return socced handle , family , type , proto fd = rebuild handle ( reduced handle ) sock = fromfd ( fd , family , type , proto ) close ( fd ) return sock
conn rh = reduce handle ( conn . fileno ( ) ) return rebuild pipe connection , ( rh , conn . readable , conn . writable rh = reduce handle ( conn . fileno ( ) ) return rebuild pipe connection , ( rh , conn . readable , conn . writable )
reduced handle , readable , writable handle = rebuild handle ( reduced handle ) return multiprocessing . pipe connection ( handle , readable = readable , writable = writable ced handle , readable , writable handle = rebuild handle ( reduced handle ) return multiprocessing . pipe connection ( handle , readable = readable , writable = writable )
def ' ' ' returns a manager associated with a running server process the managers methods such as ` lock()` , ` condition()` and ` queue()` can be used to create shared objects . ' ' ' from multiprocessing . managers import sync manager m = sync manager ( ) m . start ( ) return ' ' ' returns a manager associated with a running server process the managers methods such as ` lock()` , ` condition()` and ` queue()` can be used to create shared objects . ' ' ' from multiprocessing . managers import sync manager m = sync manager ( ) m . start ( ) return m
duplex = true ' ' ' returns two connection object connected by a pipe ' ' ' from multiprocessing . connection import pipe return pipe ( duplex ex = true ' ' ' returns two connection object connected by a pipe ' ' ' from multiprocessing . connection import pipe return pipe ( duplex )
def ' ' ' check whether this is a fake forked process in a frozen executable . if so then run code specified by commandline and exit . ' ' ' if sys . platform == ' win32 ' and getattr ( sys , ' frozen ' , false ) : from multiprocessing . forking import freeze support freeze support ( ' ' ' check whether this is a fake forked process in a frozen executable . if so then run code specified by commandline and exit . ' ' ' if sys . platform == ' win32 ' and getattr ( sys , ' frozen ' , false ) : from multiprocessing . forking import freeze support freeze support ( )
def ' ' ' return package logger if it does not already exist then it is created ' ' ' from multiprocessing . util import get logger return get logger ( ' ' ' return package logger if it does not already exist then it is created ' ' ' from multiprocessing . util import get logger return get logger ( )
level = none ' ' ' turn on logging and add a handler which prints to stderr ' ' ' from multiprocessing . util import log to stderr return log to stderr ( level l = none ' ' ' turn on logging and add a handler which prints to stderr ' ' ' from multiprocessing . util import log to stderr return log to stderr ( level )
def ' ' ' install support for sending connections and sockets between processes ' ' ' from multiprocessing import reductio ' ' ' install support for sending connections and sockets between processes ' ' ' from multiprocessing import reduction
def ' ' ' returns a non recursive lock object ' ' ' from multiprocessing . synchronize import lock return lock ( ' ' ' returns a non recursive lock object ' ' ' from multiprocessing . synchronize import lock return lock ( )
lock = none ' ' ' returns a condition object ' ' ' from multiprocessing . synchronize import condition return condition ( lock = none ' ' ' returns a condition object ' ' ' from multiprocessing . synchronize import condition return condition ( lock )
value = 1 ' ' ' returns a semaphore object ' ' ' from multiprocessing . synchronize import semaphore return semaphore ( value e = 1 ' ' ' returns a semaphore object ' ' ' from multiprocessing . synchronize import semaphore return semaphore ( value )
value = 1 ' ' ' returns a bounded semaphore object ' ' ' from multiprocessing . synchronize import bounded semaphore return bounded semaphore ( value e = 1 ' ' ' returns a bounded semaphore object ' ' ' from multiprocessing . synchronize import bounded semaphore return bounded semaphore ( value )
def ' ' ' returns an event object ' ' ' from multiprocessing . synchronize import event return event ( ' ' ' returns an event object ' ' ' from multiprocessing . synchronize import event return event ( )
maxsize = 0 ' ' ' returns a queue object ' ' ' from multiprocessing . queues import queue return queue ( maxsize ize = 0 ' ' ' returns a queue object ' ' ' from multiprocessing . queues import queue return queue ( maxsize )
processes = none , initializer = none , initargs = ( ) , maxtasksperchild = none ' ' ' returns a process pool object ' ' ' from multiprocessing . pool import pool return pool ( processes , initializer , initargs , maxtasksperchild esses = none , initializer = none , initargs = ( ) , maxtasksperchild = none ' ' ' returns a process pool object ' ' ' from multiprocessing . pool import pool return pool ( processes , initializer , initargs , maxtasksperchild )
typecode or type , * args ' ' ' returns a shared object ' ' ' from multiprocessing . sharedctypes import raw value return raw value ( typecode or type , * args code or type , * args ' ' ' returns a shared object ' ' ' from multiprocessing . sharedctypes import raw value return raw value ( typecode or type , * args )
typecode or type , size or initializer , ** kwds ' ' ' returns a synchronized shared array ' ' ' from multiprocessing . sharedctypes import array return array ( typecode or type , size or initializer , ** kwds code or type , size or initializer , ** kwds ' ' ' returns a synchronized shared array ' ' ' from multiprocessing . sharedctypes import array return array ( typecode or type , size or initializer , ** kwds )
executable ' ' ' sets the path to a python . exe or pythonw . exe binary used to run child processes on windows instead of sys . executable . useful for people embedding python . ' ' ' from multiprocessing . forking import set executable set executable ( executable utable ' ' ' sets the path to a python . exe or pythonw . exe binary used to run child processes on windows instead of sys . executable . useful for people embedding python . ' ' ' from multiprocessing . forking import set executable set executable ( executable )
self , time , priority , action , argument event = event ( time , priority , action , argument ) heapq . heappush ( self . queue , event ) return event
self , delay , priority , action , argument time = self . timefunc ( ) + delay return self . enterabs ( time , priority , action , argument )
self , event self . queue . remove ( event ) heapq . heapify ( self . queue )
self return not self . queue
self q = self . queue delayfunc = self . delayfunc timefunc = self . timefunc pop = heapq . heappop while q : time , priority , action , argument = checked event = q [ 0 ] now = timefunc ( ) if now < time : delayfunc ( time now ) else : event = pop ( q ) if event is checked event : action ( * argument ) delayfunc ( 0 ) else : heapq . heappush ( q , event )
def import sys import token if len ( sys . argv ) == 1 : sys . argv = sys . argv + [ ' include/graminit . h ' , ' lib/symbol . py ' ] token . main ( import sys import token if len ( sys . argv ) == 1 : sys . argv = sys . argv + [ ' include/graminit . h ' , ' lib/symbol . py ' ] token . main ( )
s return s . startswith ( ' / ' )
a , * p path = a for b in p : if b . startswith ( ' / ' ) : path = b elif path == ' ' or path . endswith ( ' / ' ) : path += b else : path += ' / ' + b return path
p return genericpath . splitext ( p , sep , altsep , extsep turn genericpath . splitext ( p , sep , altsep , extsep )
p return ( ' ' , p )
p i = p . rfind ( ' / ' ) + 1 return p [ i : ]
p i = p . rfind ( ' / ' ) + 1 head = p [ : i ] if head and head != ' / ' * len ( head ) : head = head . rstrip ( ' / ' ) return head
path try : st = os . lstat ( path ) except ( os . error , attribute error ) : return false return stat . s islnk ( st . st mode )
f1 , f2 s1 = os . stat ( f1 ) s2 = os . stat ( f2 ) return samestat ( s1 , s2 )
s1 , s2 return s1 . st ino == s2 . st ino and s1 . st dev == s2 . st dev
path if islink ( path ) : return false try : s1 = os . lstat ( path ) s2 = os . lstat ( join ( path , ' . . ' ) ) except os . error : return false dev1 = s1 . st dev dev2 = s2 . st dev if dev1 != dev2 : return true ino1 = s1 . st ino ino2 = s2 . st ino if ino1 == ino2 : return true return false
top , func , arg warnings . warnpy3k ( ' in 3 . x , os . path . walk is removed in favor of os . walk . ' , stacklevel = 2 ) try : names = os . listdir ( top ) except os . error : return func ( arg , top , names ) for name in names : name = join ( top , name ) try : st = os . lstat ( name ) except os . error : continue if stat . s isdir ( st . st mode ) : walk ( name , func , arg )
path if not isabs ( path ) : if isinstance ( path , unicode ) : cwd = os . getcwdu ( ) else : cwd = os . getcwd ( ) path = join ( cwd , path ) return normpath ( path )
path paths seen = set ( ) while islink ( path ) : if path in paths seen : return none paths seen . add ( path ) resolved = os . readlink ( path ) if not isabs ( resolved ) : dir = dirname ( path ) path = normpath ( join ( dir , resolved ) ) else : path = normpath ( resolved ) return path
path , start = curdir if not path : raise value error ( ' no path specified ' ) start list = [ x for x in abspath ( start ) . split ( sep ) if x ] path list = [ x for x in abspath ( path ) . split ( sep ) if x ] i = len ( commonprefix ( [ start list , path list ] ) ) rel list = [ pardir ] * ( len ( start list ) i ) + path list [ i : ] if not rel list : return curdir return join ( * rel list )
self if self . is cgi ( ) : self . run cgi ( ) else : self . send error ( 501 , ' can only post to cgi scripts ' )
self splitpath = url collapse path split ( self . path ) if splitpath [ 0 ] in self . cgi directories : self . cgi info = splitpath return true return false
self , path return executable ( path )
self , path head , tail = os . path . splitext ( path ) return tail . lower ( ) in ( ' . py ' , ' . pyw ' )
def global nobody if nobody : return nobody try : import pwd except import error : return 1 try : nobody = pwd . getpwnam ( ' nobody ' ) [ 2 ] except key error : nobody = 1 + max ( map ( lambda x : x [ 2 ] , pwd . getpwall ( ) ) ) return nobody
stream import marshal magic = stream . read ( 4 ) if magic != imp . get magic ( ) : return else : stream . read ( 4 ) return marshal . load ( stream am import marshal magic = stream . read ( 4 ) if magic != imp . get magic ( ) : return else : stream . read ( 4 ) return marshal . load ( stream )
path = none , prefix = ' ' if path is none : importers = iter importers ( ) else : importers = map ( get importer , path ) yielded = { } for i in importers : for name , ispkg in iter importer modules ( i , prefix ) : if name not in yielded : yielded [ name ] = 1 yield ( i , name , ispkg ) return
importer , prefix = ' ' if not hasattr ( importer , ' iter modules ' ) : return [ ] return importer . iter modules ( prefix rter , prefix = ' ' if not hasattr ( importer , ' iter modules ' ) : return [ ] return importer . iter modules ( prefix )
self , fullname self . reopen ( ) try : mod = imp . load module ( fullname , self . file , self . filename , self . etc ) finally : if self . file : self . file . close ( ) return mo , fullname self . reopen ( ) try : mod = imp . load module ( fullname , self . file , self . filename , self . etc ) finally : if self . file : self . file . close ( ) return mod
self , pathname return open ( pathname , ' rb ' ) . read ( , pathname return open ( pathname , ' rb ' ) . read ( )
self , fullname if fullname is none : fullname = self . fullname elif fullname != self . fullname : raise import error ( ' loader for module %s cannot handle module %s ' % ( self . fullname , fullname ) ) return fullnam , fullname if fullname is none : fullname = self . fullname elif fullname != self . fullname : raise import error ( ' loader for module %s cannot handle module %s ' % ( self . fullname , fullname ) ) return fullname
self , fullname fullname = self . fix name ( fullname ) return self . etc [ 2 ] == imp . pkg director , fullname fullname = self . fix name ( fullname ) return self . etc [ 2 ] == imp . pkg directory
self return imp importer ( self . filename ) . find module ( ' init ' return imp importer ( self . filename ) . find module ( ' init ' )
fullname = ' ' if fullname . startswith ( ' . ' ) : raise import error ( ' relative module names not supported ' ) if ' . ' in fullname : pkg = ' . ' . join ( fullname . split ( ' . ' ) [ : 1 ] ) if pkg not in sys . modules : import ( pkg ) path = getattr ( sys . modules [ pkg ] , ' path ' , none ) or [ ] else : for importer in sys . meta path : yield importer path = sys . path for item in path : yield get importer ( item ) if ' . ' not in fullname : yield imp importer ( ) return
module or name if module or name in sys . modules : module or name = sys . modules [ module or name ] if isinstance ( module or name , module type ) : module = module or name loader = getattr ( module , ' loader ' , none ) if loader is not none : return loader fullname = module . name else : fullname = module or name return find loader ( fullname )
fullname for importer in iter importers ( fullname ) : loader = importer . find module ( fullname ) if loader is not none : return loader return
package , resource loader = get loader ( package ) if loader is none or not hasattr ( loader , ' get data ' ) : return else : mod = sys . modules . get ( package ) or loader . load module ( package ) if mod is none or not hasattr ( mod , ' file ' ) : return parts = resource . split ( ' / ' ) parts . insert ( 0 , os . path . dirname ( mod . file ) ) resource name = os . path . join ( * parts ) return loader . get data ( resource name )
self , message raise not implemented error ( ' method must be implemented by subclass ' )
self , key raise not implemented error ( ' method must be implemented by subclass ' )
self , key try : self . remove ( key ) except key error : pass
self , key , default = none try : return self . getitem ( key ) except key error : return default
self , key raise not implemented error ( ' method must be implemented by subclass ' )
self , key raise not implemented error ( ' method must be implemented by subclass ' )
self , key raise not implemented error ( ' method must be implemented by subclass ' )
self raise not implemented error ( ' method must be implemented by subclass ' )
self return list ( self . iterkeys ( ) )
self for key in self . iterkeys ( ) : try : value = self [ key ] except key error : continue yield value
self return list ( self . itervalues ( ) )
self for key in self . iterkeys ( ) : try : value = self [ key ] except key error : continue yield ( key , value )
self return list ( self . iteritems ( ) )
self , key raise not implemented error ( ' method must be implemented by subclass ' )
self for key in self . iterkeys ( ) : self . discard ( key )
self , key , default = none try : result = self [ key ] except key error : return default self . discard ( key ) return result
self for key in self . iterkeys ( ) : return ( key , self . pop ( key ) ) else : raise key error ( ' no messages in mailbox ' )
self raise not implemented error ( ' method must be implemented by subclass ' )
self raise not implemented error ( ' method must be implemented by subclass ' )
self raise not implemented error ( ' method must be implemented by subclass ' )
self , key try : self . remove ( key ) except key error : pass except os error as e : if e . errno != errno . enoent : raise
self , key f = open ( os . path . join ( self . path , self . lookup ( key ) ) , ' r ' ) try : return f . read ( ) finally : f . close ( )
self , key f = open ( os . path . join ( self . path , self . lookup ( key ) ) , ' rb ' ) return proxy file ( f )
self self . refresh ( ) for key in self . toc : try : self . lookup ( key ) except key error : continue yield key
self , key self . refresh ( ) return key in self . toc
self , folder return maildir ( os . path . join ( self . path , ' . ' + folder ) , factory = self . factory , create = false )
self now = time . time ( ) for entry in os . listdir ( os . path . join ( self . path , ' tmp ' ) ) : path = os . path . join ( self . path , ' tmp ' , entry ) if now os . path . getatime ( path ) > 129600 : os . remove ( path )
self , key try : if os . path . exists ( os . path . join ( self . path , self . toc [ key ] ) ) : return self . toc [ key ] except key error : pass self . refresh ( ) try : return self . toc [ key ] except key error : raise key error ( ' no message with key: %s ' % key )
self if not hasattr ( self , ' onetime keys ' ) : self . onetime keys = self . iterkeys ( ) while true : try : return self [ self . onetime keys . next ( ) ] except stop iteration : return none except key error : continue return none
self , message self . lookup ( ) self . toc [ self . next key ] = self . append message ( message ) self . next key += 1 self . pending = true return self . next key 1
self , key self . lookup ( key ) del self . toc [ key ] self . pending = true
self self . lookup ( ) for key in self . toc . keys ( ) : yield key
self , key self . lookup ( ) return key in self . toc
self if not self . locked : lock file ( self . file ) self . locked = true
self if self . locked : unlock file ( self . file ) self . locked = false
self self . flush ( ) if self . locked : self . unlock ( ) self . file . close ( )
self , message self . file . seek ( 0 , 2 ) before = self . file . tell ( ) try : self . pre message hook ( self . file ) offsets = self . install message ( message ) self . post message hook ( self . file ) except base exception : self . file . truncate ( before ) raise self . file . flush ( ) self . file length = self . file . tell ( ) return offsets
self , key start , stop = self . lookup ( key ) self . file . seek ( start ) from line = self . file . readline ( ) . replace ( os . linesep , ' ' ) string = self . file . read ( stop self . file . tell ( ) ) msg = self . message factory ( string . replace ( os . linesep , ' \ ' ) ) msg . set from ( from line [ 5 : ] ) return msg
self , key , from = false start , stop = self . lookup ( key ) self . file . seek ( start ) if not from : self . file . readline ( ) return partial file ( self . file , self . file . tell ( ) , stop )
self , f if f . tell ( ) != 0 : f . write ( os . linesep )
self , key path = os . path . join ( self . path , str ( key ) ) try : f = open ( path , ' rb+ ' ) except io error as e : if e . errno == errno . enoent : raise key error ( ' no message with key: %s ' % key ) else : raise else : f . close ( ) os . remove ( path )
self , key try : f = open ( os . path . join ( self . path , str ( key ) ) , ' rb ' ) except io error as e : if e . errno == errno . enoent : raise key error ( ' no message with key: %s ' % key ) else : raise return proxy file ( f )
self return iter ( sorted ( ( int ( entry ) for entry in os . listdir ( self . path ) if entry . isdigit ( ) ) ) )
self , key return os . path . exists ( os . path . join ( self . path , str ( key ) ) )
self if not self . locked : self . file = open ( os . path . join ( self . path , ' . mh sequences ' ) , ' rb+ ' ) lock file ( self . file ) self . locked = true
self if self . locked : unlock file ( self . file ) sync close ( self . file ) del self . file self . locked = false
self if self . locked : self . unlock ( )
self result = [ ] for entry in os . listdir ( self . path ) : if os . path . isdir ( os . path . join ( self . path , entry ) ) : result . append ( entry ) return result
self , folder path = os . path . join ( self . path , folder ) entries = os . listdir ( path ) if entries == [ ' . mh sequences ' ] : os . remove ( os . path . join ( path , ' . mh sequences ' ) ) elif entries == [ ] : pass else : raise not empty error ( ' folder not empty: %s ' % self . path ) os . rmdir ( path )
self , message , key pending sequences = message . get sequences ( ) all sequences = self . get sequences ( ) for name , key list in all sequences . iteritems ( ) : if name in pending sequences : key list . append ( key ) elif key in key list : del key list [ key list . index ( key ) ] for sequence in pending sequences : if sequence not in all sequences : all sequences [ sequence ] = [ key ] self . set sequences ( all sequences )
self , key singlefile mailbox . remove ( self , key ) if key in self . labels : del self . labels [ key ]
self self . lookup ( ) labels = set ( ) for label list in self . labels . values ( ) : labels . update ( label list ) labels . difference update ( self . special labels ) return list ( labels )
self , f f . write ( ' babyl options:%s version: 5%s labels:%s%s\\x1f ' % ( os . linesep , os . linesep , ' , ' . join ( self . get labels ( ) ) , os . linesep ) )
self , f f . write ( ' \\x0c ' + os . linesep )
self , message for name in ( ' headers ' , ' unixfrom ' , ' payload ' , ' charset ' , ' preamble ' , ' epilogue ' , ' defects ' , ' default type ' ) : self . dict [ name ] = message . dict [ name ]
self , message if isinstance ( message , message ) : return raise type error ( ' cannot convert to specified type ' )
self return self . subdir
self , subdir if subdir == ' new ' or subdir == ' cur ' : self . subdir = subdir else : raise value error ( " subdir must be ' new ' or ' cur ' : %s " % subdir )
self if self . info . startswith ( ' 2 , ' ) : return self . info [ 2 : ] else : return ' '
self , flag self . set flags ( ' ' . join ( set ( self . get flags ( ) ) | set ( flag ) ) )
self , flag if self . get flags ( ) != ' ' : self . set flags ( ' ' . join ( set ( self . get flags ( ) ) set ( flag ) ) )
self return self . date
self , date try : self . date = float ( date ) except value error : raise type error ( " can ' t convert to float: %s " % date )
self return self . info
self , info if isinstance ( info , str ) : self . info = info else : raise type error ( ' info must be a string: %s ' % type ( info ) )
self , from , time = none if time is not none : if time is true : time = time . gmtime ( ) from += ' ' + time . asctime ( time ) self . from = from return
self , flag if ' status ' in self or ' x status ' in self : self . set flags ( ' ' . join ( set ( self . get flags ( ) ) set ( flag ) ) )
self return self . sequences [ : ]
self , sequence if isinstance ( sequence , str ) : if sequence not in self . sequences : self . sequences . append ( sequence ) else : raise type error ( ' sequence must be a string: %s ' % type ( sequence ) )
self , sequence try : self . sequences . remove ( sequence ) except value error : pass
self return self . labels [ : ]
self , label if isinstance ( label , str ) : if label not in self . labels : self . labels . append ( label ) else : raise type error ( ' label must be a string: %s ' % type ( label ) )
self , label try : self . labels . remove ( label ) except value error : pass
self return message ( self . visible )
self , visible self . visible = message ( visible )
self for header in self . visible . keys ( ) : if header in self : self . visible . replace header ( header , self [ header ] ) else : del self . visible [ header ] for header in ( ' date ' , ' from ' , ' reply to ' , ' to ' , ' cc ' , ' subject ' ) : if header in self and header not in self . visible : self . visible [ header ] = self [ header ]
self , size = none return self . read ( size , self . file . read )
self , size = none return self . read ( size , self . file . readline )
self , sizehint = none result = [ ] for line in self : result . append ( line ) if sizehint is not none : sizehint = len ( line ) if sizehint <= 0 : break return result
self return self . pos
self , offset , whence = 0 if whence == 1 : self . file . seek ( self . pos ) self . file . seek ( offset , whence ) self . pos = self . file . tell ( )
self del self . file
self , size , read method if size is none : size = 1 self . file . seek ( self . pos ) result = read method ( size ) self . pos = self . file . tell ( ) return result
self return proxy file . tell ( self ) self . start
self , offset , whence = 0 if whence == 0 : self . pos = self . start whence = 1 elif whence == 2 : self . pos = self . stop whence = 1 proxy file . seek ( self , offset , whence )
self , size , read method remaining = self . stop self . pos if remaining <= 0 : return ' ' else : if size is none or size < 0 or size > remaining : size = remaining return proxy file . read ( self , size , read method )
f if fcntl : fcntl . lockf ( f , fcntl . lock un ) if os . path . exists ( f . name + ' . lock ' ) : os . remove ( f . name + ' . lock ' )
path fd = os . open ( path , os . o creat | os . o excl | os . o rdwr , 438 ) try : return open ( path , ' rb+ ' ) finally : os . close ( fd )
path return create carefully ( ' %s . %s . %s . %s ' % ( path , int ( time . time ( ) ) , socket . gethostname ( ) , os . getpid ( ) ) )
f f . flush ( ) if hasattr ( os , ' fsync ' ) : os . fsync ( f . fileno ( ) )
f sync flush ( f ) f . close ( )
