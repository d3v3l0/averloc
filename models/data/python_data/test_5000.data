filename return [ line . strip ( ) for line in open ( filename , ' r ' ) if line . strip ( ) and not line . strip ( ) . startswith ( ' ' ) ]
fname , url , url image readme = open ( path . join ( path . dirname ( file ) , fname ) ) . read ( ) if hasattr ( readme , ' decode ' ) : # in python 3 , turn bytes into str . readme = readme . decode ( ' utf8 ' ) readme = re . sub ( r ' `<([^>]*)>` ' , r ' `\\1 < ' + url + r " /blob/master/\\1>` " , readme ) readme = re . sub ( r " \\ . \\ . image:: / " , " . . image:: " + url image + " / " , readme ) return readme
self , * args , ** kwargs response = self . session . post ( * args , ** kwargs ) browser . add soup ( response , self . soup config ) return response
self if self . session is not none : self . session . cookies . clear ( ) self . session . close ( ) self . session = none
self for input in self . form . find all ( ( " input " , " textarea " , " select " , " button " ) ) : input copy = copy . copy ( input ) # text between the opening tag and the closing tag often # contains a lot of spaces that we don ' t want here . for subtag in input copy . find all ( ) + [ input copy ] : if subtag . string : subtag . string = subtag . string . strip ( ) print ( input copy )
self if self . state . form is none : raise attribute error ( " no form has been selected yet on this page . " ) return self . state . form
httpbin browser = mechanicalsoup . stateful browser ( user agent = ' 007 ' ) resp = browser . open ( httpbin + " /user agent " ) assert resp . json ( ) == { ' user agent ' : ' 007 ' bin browser = mechanicalsoup . stateful browser ( user agent = ' 007 ' ) resp = browser . open ( httpbin + " /user agent " ) assert resp . json ( ) == { ' user agent ' : ' 007 ' }
filename with open ( filename , " rb " ) as f : return f . read ( name with open ( filename , " rb " ) as f : return f . read ( )
value if isinstance ( value , bytes ) : value = value . decode ( ' latin1 ' ) return value . translate ( { 40 : r ' \\( ' , 41 : r ' \\) ' , 92 : r ' \\\\ ' } )
element , box , get image from uri , base url if isinstance ( box , boxes . table column group box ) : if any ( child . tag == ' col ' for child in element ) : box . span = none # sum of the children\u2019s spans else : integer attribute ( element , box , ' span ' ) box . children = ( boxes . table column box . anonymous from ( box , [ ] ) for i in range ( box . span ) ) return [ box ]
cls , exception name = type ( exception ) . name value = str ( exception ) return cls ( ' %s: %s ' % ( name , value ) if value else name , exception name = type ( exception ) . name value = str ( exception ) return cls ( ' %s: %s ' % ( name , value ) if value else name )
self , rule descriptors , url fetcher
self return [ html5 ph stylesheet return [ html5 ph stylesheet ]
self , target = none , stylesheets = none , zoom = 1 , attachments = none , presentational hints = false , font config = none return self . render ( stylesheets , enable hinting = false , presentational hints = presentational hints , font config = font config ) . write pdf ( target , zoom , attachments )
style , key value = style [ key ] return value if value != ' current color ' else style [ ' color ' e , key value = style [ key ] return value if value != ' current color ' else style [ ' color ' ]
url if url . startswith ( ' data: ' ) : # data ur is can be huge , but don\u2019t need this anyway . return url url = url . encode ( filesystem encoding if url . startswith ( ' file: ' ) else ' utf 8 ' ) return quote ( url , safe = b " /:?#[]@!$& ' ()*+ , ;=~% " )
symbols , negative , value return symbols [ ( value 1 ) % len ( symbols ) ]
self return self . width + self . padding left + self . padding right
self return self . padding width ( ) + self . border left width + self . border right width
self return ( self . border box x ( ) , self . border box y ( ) , self . border width ( ) , self . border height ( ) )
self , ratio return self . rounded box ( self . border top width * ratio , self . border right width * ratio , self . border bottom width * ratio , self . border left width * ratio , ratio return self . rounded box ( self . border top width * ratio , self . border right width * ratio , self . border bottom width * ratio , self . border left width * ratio )
self return ( self . style [ ' page ' ] , self . style [ ' page ' ] )
context , box , outer children widths = [ min content width ( context , child , outer = true ) for child in box . children if not child . is absolutely positioned ( ) ] children min width = margin width ( box , max ( children widths ) if children widths else 0 ) width = box . style [ ' width ' ] if width != ' auto ' and width . unit == ' px ' : cell min width = adjust ( box , outer , width . value ) else : cell min width = 0 return max ( children min width , cell min width )
context , box , containing block if context . excluded shapes : highest y = context . excluded shapes [ 1 ] . position y if box . position y < highest y : box . translate ( 0 , highest y box . position y ) position x , position y , available width = avoid collisions ( context , box , containing block ) if box . style [ ' float ' ] == ' right ' : position x += available width box . margin width ( ) box . translate ( position x box . position x , position y box . position y ) return box
self self . excluded shapes = [ ] self . excluded shapes lists . append ( self . excluded shapes self . excluded shapes = [ ] self . excluded shapes lists . append ( self . excluded shapes )
box , property name , refer to , main flex direction = none value = box . style [ property name ] percent = percentage ( value , refer to ) setattr ( box , property name , percent ) if property name in ( ' min width ' , ' min height ' ) and percent == ' auto ' : if ( main flex direction is none or property name != ( ' min %s ' % main flex direction ) ) : setattr ( box , property name , 0 )
def first = [ ' font stretch ' , ' font weight ' , ' font family ' , ' font variant ' , ' font style ' , ' font size ' , ' line height ' , ' marks ' ] order = sorted ( initial values ) for name in first : order . remove ( name ) return tuple ( first + order )
computer , name , values return tuple ( length ( computer , name , value , pixels only = true ) for value in values )
computer , name , value if value == ' normal ' : return 400 elif value == ' bold ' : return 700 elif value in ( ' bolder ' , ' lighter ' ) : parent value = computer [ ' parent style ' ] [ ' font weight ' ] return font weight relative [ value ] [ parent value ] else : return value
computer , name , values if values != ' none ' : , key = values anchor name = computer [ ' element ' ] . get ( key ) or none computer [ ' target collector ' ] . collect anchor ( anchor name ) return anchor name
computer , name , values if values == ' none ' : return none else : type , key = values if type == ' attr() ' : return computer [ ' element ' ] . get ( key ) or none elif type == ' string ' : return key
computer , name , value result = [ ] for function , args in value : if function == ' translate ' : args = length or percentage tuple ( computer , name , args ) result . append ( ( function , args ) ) return tuple ( result )
tokens parts = [ ] for split part in split on comma ( tokens ) : if not split part : # happens when there ' s a comma at the beginning , at the end , or # when two commas are next to each other . return for part in split part : parts . append ( part ) return parts
token if token . type == ' dimension ' : factor = angle to radians . get ( token . unit ) if factor is not none : return token . value * factor
self return self . computed style return self . computed styles
origin , importance if origin == ' user agent ' : return 1 elif origin == ' user ' and not importance : return 2 elif origin == ' author ' and not importance : return 3 elif origin == ' author ' : # and importance return 4 else : assert origin == ' user ' # and importance return 5
self , anchor name , target counter values , target box item = self . target lookup items . get ( anchor name ) if item and item . state == ' pending ' : item . state = ' up to date ' item . target box = target box # store the counter values in the target box like # compute content list does . # todo: remove attribute or set a default value in box class if not hasattr ( target box , ' cached counter values ' ) : target box . cached counter values = copy . deepcopy ( target counter values )
token result = parse color ( token ) if result == ' current color ' : return ' inherit ' else : return result
token , base url if token . type != ' function ' : if get keyword ( token ) == ' none ' : return ' none ' , none return get image ( token , base url n , base url if token . type != ' function ' : if get keyword ( token ) == ' none ' : return ' none ' , none return get image ( token , base url )
token , base url if token . type != ' function ' : if get keyword ( token ) == ' none ' : return ' none ' , none parsed url = get url ( token , base url ) if parsed url : if parsed url [ 0 ] == ' url ' and parsed url [ 1 ] [ 0 ] == ' external ' : return ' url ' , parsed url [ 1 ] [ 1 ]
keyword return keyword in ( ' border box ' , ' padding box ' , ' content box ' )
keyword return keyword in ( ' auto ' , ' keep ' , ' discard ' )
token keyword = get keyword ( token ) if keyword == ' auto ' : return ' auto ' else : return get length ( token )
keyword return keyword in ( ' normal ' , ' historical forms ' ord return keyword in ( ' normal ' , ' historical forms ' )
token keyword = get keyword ( token ) if keyword in ( ' normal ' , ' bold ' , ' bolder ' , ' lighter ' ) : return keyword if token . type == ' number ' and token . int value is not none : if token . int value in ( 100 , 200 , 300 , 400 , 500 , 600 , 700 , 800 , 900 ) : return token . int value
token length = get length ( token , negative = false , percentage = true ) if length : return length if get keyword ( token ) == ' none ' : return dimension ( float ( ' inf ' ) , ' px ' )
token if get keyword ( token ) == ' auto ' : return ' auto ' if token . type == ' number ' and token . int value is not none : return token . int value
keyword if keyword in ( ' solid ' , ' double ' , ' dotted ' , ' dashed ' , ' wavy ' ) : return keyword
keyword return keyword in ( ' flex start ' , ' flex end ' , ' center ' , ' baseline ' , ' stretch ' )
args , stdin = b ' ' stdin = io . bytes io ( stdin ) stdout = io . bytes io ( ) try : main . html = fake html main . main ( args . split ( ) , stdin = stdin , stdout = stdout ) finally : main . html = html return stdout . getvalue ( , stdin = b ' ' stdin = io . bytes io ( stdin ) stdout = io . bytes io ( ) try : main . html = fake html main . main ( args . split ( ) , stdin = stdin , stdout = stdout ) finally : main . html = html return stdout . getvalue ( )
@ line1 , line2 = white space lines ( 1 , ' pre ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + ' box2 , = line2 . children text2 , = box2 . children assert text2 . text == ' is text 'ne1 , line2 = white space lines ( 1 , ' pre ' ) box1 , = line1 . children text1 , = box1 . children assert text1 . text == ' this + ' box2 , = line2 . children text2 , = box2 . children assert text2 . text == ' is text '
@ assert pixels ( ' image translate ' , 8 , 8 , ' ' ' r bbb bbbb bbbb bbbb ' ' ' , ' ' ' <style> @page { size: 8px; margin: 2px; background: #fff; } div { transform: translate(1px , 2px); font size: 0 } </style> <div><img src= " pattern . png " ></div> ' ' ' sert pixels ( ' image translate ' , 8 , 8 , ' ' ' r bbb bbbb bbbb bbbb ' ' ' , ' ' ' <style> @page { size: 8px; margin: 2px; background: #fff; } div { transform: translate(1px , 2px); font size: 0 } </style> <div><img src= " pattern . png " ></div> ' ' ' )
name , expected width , expected height , expected pixels , html if isinstance ( expected pixels , str ) : expected pixels = parse pixels ( expected pixels ) assert len ( expected pixels ) == expected height assert len ( expected pixels [ 0 ] ) == expected width * 4 expected raw = b ' ' . join ( expected pixels ) doc , pixels = html to pixels ( name , expected width , expected height , html ) assert pixels equal ( name , expected width , expected height , pixels , expected raw )
expected width , expected height , documents , tolerance = 0 pixels list = [ ] for name , html in documents : doc , pixels = html to pixels ( name , expected width , expected height , html ) pixels list . append ( ( name , pixels ) ) name , reference = pixels list [ 0 ] for name , pixels in pixels list [ 1 : ] : assert pixels equal ( name , expected width , expected height , reference , pixels , tolerance )
@ assert pixels ( ' block image ' , 8 , 8 , centered image , ' ' ' <style> @page { size: 8px } body { margin: 0; background: #fff; font size: 0 } img { display: block; margin: 2px auto 0 } </style> <div><img src= " pattern . png " ></div> ' ' ' sert pixels ( ' block image ' , 8 , 8 , centered image , ' ' ' <style> @page { size: 8px } body { margin: 0; background: #fff; font size: 0 } img { display: block; margin: 2px auto 0 } </style> <div><img src= " pattern . png " ></div> ' ' ' )
@ assert pixels ( ' visibility reference ' , 12 , 7 , ' ' ' r bbb r bbb bbbb bbbb bbbb bbbb bbbb bbbb ' ' ' , visibility source % { ' extra css ' : ' ' } sert pixels ( ' visibility reference ' , 12 , 7 , ' ' ' r bbb r bbb bbbb bbbb bbbb bbbb bbbb bbbb ' ' ' , visibility source % { ' extra css ' : ' ' } )
@ page , = parse ( ' ' ' <article style= " overflow: auto " > <div style= " float: left; height: 50px; margin: 10px " >bla bla bla</div> toto toto ' ' ' ) html , = page . children body , = html . children article , = body . children assert article . height == 50 + 10 + 1ge , = parse ( ' ' ' <article style= " overflow: auto " > <div style= " float: left; height: 50px; margin: 10px " >bla bla bla</div> toto toto ' ' ' ) html , = page . children body , = html . children article , = body . children assert article . height == 50 + 10 + 10
style , width , height page , = render pages ( ' <style>@page { %s }</style> ' % style ) assert page . margin width ( ) == width assert page . margin height ( ) == heighe , width , height page , = render pages ( ' <style>@page { %s }</style> ' % style ) assert page . margin width ( ) == width assert page . margin height ( ) == height
widths return ' ' . join ( ' url(\\ ' data:image/svg+xml , <svg width= " %i " height= " 10 " ></svg>\\ ' ) ' % width for width in widths hs return ' ' . join ( ' url(\\ ' data:image/svg+xml , <svg width= " %i " height= " 10 " ></svg>\\ ' ) ' % width for width in widths )
@ page , = render pages ( ' ' ' <table> <tr> <td> <table> <tr> <td style= " width: 100%; " ></td> <td style= " width: 48px; " > <img src= " icon . png " > </td> </tr> </table> </td> </tr> </table> ' ' ' ge , = render pages ( ' ' ' <table> <tr> <td> <table> <tr> <td style= " width: 100%; " ></td> <td style= " width: 48px; " > <img src= " icon . png " > </td> </tr> </table> </td> </tr> </table> ' ' ' )
x , keep prob , is training return tf . contrib . layers . dropout ( x , keep prob = keep prob , is training = is training )
self return self . num unit return self . num units
signal , coefficient = 0 . 95 ' ' ' pre emphasis . args: signal: 1 d numpy array . coefficient: coefficient for pre emphasis . defauted to 0 . 95 . returns: pre emphasis signal . ' ' ' return numpy . append ( signal [ 0 ] , signal [ 1 : ] coefficient * signal [ : 1 ] al , coefficient = 0 . 95 ' ' ' pre emphasis . args: signal: 1 d numpy array . coefficient: coefficient for pre emphasis . defauted to 0 . 95 . returns: pre emphasis signal . ' ' ' return numpy . append ( signal [ 0 ] , signal [ 1 : ] coefficient * signal [ : 1 ] )
self return self . format . format ( * self . message return self . format . format ( * self . message )
self return self . widt return self . width
self , serializer , value name , program serializer . emit indent ( ) serializer . append format ( " /* no body for {0} */ " , self . name ) serializer . newline ( , serializer , value name , program serializer . emit indent ( ) serializer . append format ( " /* no body for {0} */ " , self . name ) serializer . newline ( )
self , serializer assert isinstance ( serializer , program serializer . program serializer ) serializer . emit indent ( ) serializer . append format ( " struct {0} {1} " , self . metadata struct type name , self . metadata struct name , serializer assert isinstance ( serializer , program serializer . program serializer ) serializer . emit indent ( ) serializer . append format ( " struct {0} {1} " , self . metadata struct type name , self . metadata struct name )
self , serializer assert isinstance ( serializer , program serializer . program serializer ) for t in self . tables : assert isinstance ( t , ebpf table . ebpf table ) serializer . emit indent ( ) serializer . append format ( " {0}: " , t . name ) serializer . newline ( , serializer assert isinstance ( serializer , program serializer . program serializer ) for t in self . tables : assert isinstance ( t , ebpf table . ebpf table ) serializer . emit indent ( ) serializer . append format ( " {0}: " , t . name ) serializer . newline ( )
self , serializer raise compilation exception ( true , " method must be overridden " , serializer raise compilation exception ( true , " method must be overridden " )
self , serializer raise compilation exception ( true , " method must be overridden " , serializer raise compilation exception ( true , " method must be overridden " )
self , serializer , license string assert isinstance ( serializer , program serializer ) serializer . emit indent ( ) serializer . append format ( " char license[] {0}(\\ " license\\ " ) = \\ " {1}\\ " ; " , self . config . section , license string ) serializer . newline ( , serializer , license string assert isinstance ( serializer , program serializer ) serializer . emit indent ( ) serializer . append format ( " char license[] {0}(\\ " license\\ " ) = \\ " {1}\\ " ; " , self . config . section , license string ) serializer . newline ( )
self , serializer , table name , key , value serializer . append format ( " {0} = {1} . lookup(&{2}); " , value , table name , key , serializer , table name , key , value serializer . append format ( " {0} = {1} . lookup(&{2}); " , value , table name , key )
self , program table = program . get table ( self . hlircounter . binding [ 1 ] . name ) assert isinstance ( table , ebpf table . ebpf table ) return tabl , program table = program . get table ( self . hlircounter . binding [ 1 ] . name ) assert isinstance ( table , ebpf table . ebpf table ) return table
self , serializer , action assert isinstance ( serializer , program serializer ) assert isinstance ( action , ebpf action . ebpf action base ) action . serialize arguments as struct ( serializer , serializer , action assert isinstance ( serializer , program serializer ) assert isinstance ( action , ebpf action . ebpf action base ) action . serialize arguments as struct ( serializer )
self , parent assert isinstance ( parent , node ) self . parent = paren , parent assert isinstance ( parent , node ) self . parent = parent
self , node assert isinstance ( node , node ) self . nodes . append ( node , node assert isinstance ( node , node ) self . nodes . append ( node )
self , probe name , arg index return lib . bcc usdt get probe argctype ( self . context , probe name . encode ( ' ascii ' ) , arg index ) . decode ( , probe name , arg index return lib . bcc usdt get probe argctype ( self . context , probe name . encode ( ' ascii ' ) , arg index ) . decode ( )
self for prefix in self . syscall prefixes : if self . ksymname ( b " %sbpf " % prefix ) != 1 : return prefix return self . syscall prefixes [ 0 for prefix in self . syscall prefixes : if self . ksymname ( b " %sbpf " % prefix ) != 1 : return prefix return self . syscall prefixes [ 0 ]
self , tp = b " " , fn name = b " " tp = assert is bytes ( tp ) if tp in self . raw tracepoint fds : raise exception ( " raw tracepoint %s has been attached " % tp ) fn name = assert is bytes ( fn name ) fn = self . load func ( fn name , bpf . raw tracepoint ) fd = lib . bpf attach raw tracepoint ( fn . fd , tp ) if fd < 0 : raise exception ( " failed to attach bpf to raw tracepoint " ) self . raw tracepoint fds [ tp ] = fd ; return self
name , sym re return set ( [ address for ( , address ) in bpf . get user functions and addresses ( name , sym re ) ] )
self , name = b " " , sym = b " " , addr = none , pid = 1 name = assert is bytes ( name ) sym = assert is bytes ( sym ) ( path , addr ) = bpf . check path symbol ( name , sym , addr , pid ) ev name = self . get uprobe evname ( b " r " , path , addr , pid ) self . detach uprobe event ( ev name )
self , nonblocking = false if not self . tracefile : self . tracefile = open ( " %s/trace pipe " % tracefs , " rb " ) if nonblocking : fd = self . tracefile . fileno ( ) fl = fcntl . fcntl ( fd , fcntl . f getfl ) fcntl . fcntl ( fd , fcntl . f setfl , fl | os . o nonblock ) return self . tracefile
self , key str key = self . key ( ) res = lib . bpf table key sscanf ( self . bpf . module , self . map id , key str , ct . byref ( key ) ) if res < 0 : raise exception ( " could not scanf key " ) return ke , key str key = self . key ( ) res = lib . bpf table key sscanf ( self . bpf . module , self . map id , key str , ct . byref ( key ) ) if res < 0 : raise exception ( " could not scanf key " ) return key
self for key in self : try : yield ( key , self [ key ] ) except key error : pas for key in self : try : yield ( key , self [ key ] ) except key error : pass
self self . i += 1 if self . i == len ( self . table ) : raise stop iteration ( ) return self . key ( self . i self . i += 1 if self . i == len ( self . table ) : raise stop iteration ( ) return self . key ( self . i )
self , node self . adjacency map . pop ( node , none ) for , neighbors in self . adjacency map . items ( ) : neighbors . discard ( node , node self . adjacency map . pop ( node , none ) for , neighbors in self . adjacency map . items ( ) : neighbors . discard ( node )
s ' ' ' given a comma separated string , returns a list of substrings ' ' ' return s . strip ( ) . split ( ' , ' ' ' given a comma separated string , returns a list of substrings ' ' ' return s . strip ( ) . split ( ' , ' )
x return x << ( page shift 10 turn x << ( page shift 10 )
def result = dict ( ) for line in open ( ' /proc/meminfo ' ) : k = line . split ( ' : ' , 3 ) v = k [ 1 ] . split ( ) result [ k [ 0 ] ] = int ( v [ 0 ] ) return resulresult = dict ( ) for line in open ( ' /proc/meminfo ' ) : k = line . split ( ' : ' , 3 ) v = k [ 1 ] . split ( ) result [ k [ 0 ] ] = int ( v [ 0 ] ) return result
signal , frame print ( al , frame print ( )
self , exprs if len ( exprs ) == 0 : self . bail ( " no exprs specified " ) self . exprs = exprs . split ( ' , ' , exprs if len ( exprs ) == 0 : self . bail ( " no exprs specified " ) self . exprs = exprs . split ( ' , ' )
self self . usdt ctx = usdt ( path = self . library , pid = self . pid ) self . usdt ctx . enable probe ( self . function , self . probe func name self . usdt ctx = usdt ( path = self . library , pid = self . pid ) self . usdt ctx . enable probe ( self . function , self . probe func name )
self if self . pid is not none and not self . is user : return " if ( tgid != %d) { return 0; } " % self . pid else : return " " if self . pid is not none and not self . is user : return " if ( tgid != %d) { return 0; } " % self . pid else : return " "
pid try : return open ( " /proc/%d/comm " % pid , " rb " ) . read ( ) . strip ( ) except exception : return b " [unknown] "try : return open ( " /proc/%d/comm " % pid , " rb " ) . read ( ) . strip ( ) except exception : return b " [unknown] "
key if args . process : return b " % 6d % 15s " % ( key . value , comm for pid ( key . value ) ) else : return syscall name ( key . value if args . process : return b " % 6d % 15s " % ( key . value , comm for pid ( key . value ) ) else : return syscall name ( key . value )
error print ( " error: " + error ) exit ( 1 r print ( " error: " + error ) exit ( 1 )
cpu , data , size event = b [ " events " ] . event ( data ) print ( " % 8s % 16s % 6s %14s " % ( strftime ( " % h:% m:% s " ) , event . task , event . pid , event . delta us ) , data , size event = b [ " events " ] . event ( data ) print ( " % 8s % 16s % 6s %14s " % ( strftime ( " % h:% m:% s " ) , event . task , event . pid , event . delta us ) )
self , filt self . filter = self . rewrite expr ( filt , filt self . filter = self . rewrite expr ( filt )
signal , frame print ( al , frame print ( )
self usdt . enable probe or bail ( self . begin , " trace %s " % self . begin ) usdt . enable probe or bail ( self . end , " trace %s " % self . end usdt . enable probe or bail ( self . begin , " trace %s " % self . begin ) usdt . enable probe or bail ( self . end , " trace %s " % self . end )
self , data return self . formatter ( data , data return self . formatter ( data )
event " gen %d gc collected %d objects " % ( event . field1 , event . field2 t " gen %d gc collected %d objects " % ( event . field1 , event . field2 )
self self . find targets ( ) self . enable probes ( ) return self . generate tables ( ) + self . generate functions ( self . find targets ( ) self . enable probes ( ) return self . generate tables ( ) + self . generate functions ( )
self self . usdts = non self . usdts = none
v , oldv return stats . leaf ( v . tx pkts oldv . tx pkts , v . rx pkts oldv . rx pkts , v . tx bytes oldv . tx bytes , v . rx bytes oldv . rx bytes oldv return stats . leaf ( v . tx pkts oldv . tx pkts , v . rx pkts oldv . rx pkts , v . tx bytes oldv . tx bytes , v . rx bytes oldv . rx bytes )
k return " %s , %s , %d , %s , %s " % ( ip address ( k . outer sip ) , ip address ( k . outer dip ) , k . vni , ip address ( k . inner sip ) , ip address ( k . inner dip ) turn " %s , %s , %d , %s , %s " % ( ip address ( k . outer sip ) , ip address ( k . outer dip ) , k . vni , ip address ( k . inner sip ) , ip address ( k . inner dip ) )
self test prog1 = b = bpf ( text = test prog1 ) t = b [ " lru " ] self . assert equal ( t . flags , 2 ) ;
major , minor version = distutils . version . loose version ( os . uname ( ) [ 2 ] ) . version if version [ 0 ] > major : return true if version [ 0 ] < major : return false if minor and version [ 1 ] < minor : return false return trur , minor version = distutils . version . loose version ( os . uname ( ) [ 2 ] ) . version if version [ 0 ] > major : return true if version [ 0 ] < major : return false if minor and version [ 1 ] < minor : return false return true
self text = b = bpf ( text = text , cflags = [ " dmyflag " ] )
self text = with self . assert raises ( exception ) : b = bpf ( text = text )
self text = b = bpf ( text = text ) t = b [ " jmp " ] self . assert equal ( len ( t ) , 32 ) ;
self bpf text = b = bpf ( text = bpf text ) b . load func ( " trace entry " , bpf . kprobe ) b . load func ( " trace exit " , bpf . kprobe )
self text = b = bpf ( text = text ) fn = b . load func ( " test " , bpf . kprobe )
self self . b . cleanup ( self . b . cleanup ( )
self self . b . cleanup ( self . b . cleanup ( )
self self . b . cleanup ( self . b . cleanup ( )
self self . app . kill ( ) self . app . wait ( ) os . unlink ( self . ftemp . name self . app . kill ( ) self . app . wait ( ) os . unlink ( self . ftemp . name )
self self . process . kill ( ) self . process . wait ( ) self . process . stdout . close ( ) self . process = non self . process . kill ( ) self . process . wait ( ) self . process . stdout . close ( ) self . process = none
self subprocess . check output ( ' mkdir p /usr/lib/debug/ . build id/12 ' . split ( ) ) subprocess . check output ( ( ' mv dummy . debug /usr/lib/debug/ . build id ' + ' /12/3456789abcdef0123456789abcdef012345678 . debug ' ) . split ( ) subprocess . check output ( ' mkdir p /usr/lib/debug/ . build id/12 ' . split ( ) ) subprocess . check output ( ( ' mv dummy . debug /usr/lib/debug/ . build id ' + ' /12/3456789abcdef0123456789abcdef012345678 . debug ' ) . split ( ) )
self self . assert equal ( cfg . leaking amount , self . run leaker ( " valloc " ) self . assert equal ( cfg . leaking amount , self . run leaker ( " valloc " ) )
self self . run with int ( " fileslower . py " self . run with int ( " fileslower . py " )
self self . run with duration ( " hardirqs . py 1 1 " self . run with duration ( " hardirqs . py 1 1 " )
self self . run with int ( " mountsnoop . py " self . run with int ( " mountsnoop . py " )
self self . run with duration ( " runqlen . py 1 1 " self . run with duration ( " runqlen . py 1 1 " )
self self . run with int ( " tcpconnlat . py " self . run with int ( " tcpconnlat . py " )
self import pytest rcode = pytest . main ( self . test args ) sys . exit ( rcode import pytest rcode = pytest . main ( self . test args ) sys . exit ( rcode )
self , * types if type ( self ) in types : return [ self ] return sum ( [ child . flat ( * types ) for child in self . children ] , [ ] , * types if type ( self ) in types : return [ self ] return sum ( [ child . flat ( * types ) for child in self . children ] , [ ] )
tokens , options seq = parse seq ( tokens , options ) if tokens . current ( ) != ' | ' : return seq result = [ required ( * seq ) ] if len ( seq ) > 1 else seq while tokens . current ( ) == ' | ' : tokens . move ( ) seq = parse seq ( tokens , options ) result += [ required ( * seq ) ] if len ( seq ) > 1 else seq return [ either ( * result ) ] if len ( result ) > 1 else result
def assert option ( ' h ' , none ) . name == ' h ' assert option ( ' h ' , ' help ' ) . name == ' help ' assert option ( none , ' help ' ) . name == ' help 'assert option ( ' h ' , none ) . name == ' h ' assert option ( ' h ' , ' help ' ) . name == ' help ' assert option ( none , ' help ' ) . name == ' help '
def with raises ( system exit ) : # i . e . shows help docopt ( ' usage: prog help commands | help ' , ' help ' ) assert docopt ( ' usage: prog aabb | aa ' , ' aa ' ) == { ' aabb ' : false , ' aa ' : true with raises ( system exit ) : # i . e . shows help docopt ( ' usage: prog help commands | help ' , ' help ' ) assert docopt ( ' usage: prog aabb | aa ' , ' aa ' ) == { ' aabb ' : false , ' aa ' : true }
def try : assert docopt ( eval ( " u ' usage: prog [ o <a>] ' " ) , ' ' ) == { ' o ' : false , ' <a> ' : none } except syntax error : pastry : assert docopt ( eval ( " u ' usage: prog [ o <a>] ' " ) , ' ' ) == { ' o ' : false , ' <a> ' : none } except syntax error : pass
self , arg print ( ' good bye! ' ) exit ( )
dict 1 , dict 2 return dict ( ( str ( key ) , dict 1 . get ( key ) or dict 2 . get ( key ) ) for key in set ( dict 2 ) | set ( dict 1 ) )
root dir , ext = ' . jpg ' files = [ ] for root , dirnames , filenames in os . walk ( root dir ) : for filename in fnmatch . filter ( filenames , ' * ' + ext ) : files . append ( os . path . join ( root , filename ) ) return file dir , ext = ' . jpg ' files = [ ] for root , dirnames , filenames in os . walk ( root dir ) : for filename in fnmatch . filter ( filenames , ' * ' + ext ) : files . append ( os . path . join ( root , filename ) ) return files
self , x x = self . features ( x ) x = x . mean ( 3 ) . mean ( 2 ) x = self . classifier ( x ) return , x x = self . features ( x ) x = x . mean ( 3 ) . mean ( 2 ) x = self . classifier ( x ) return x
pretrained = false , ** kwargs model = hr net v2 ( n class = 1000 , ** kwargs ) if pretrained : model . load state dict ( load url ( model urls [ ' hrnetv2 ' ] ) , strict = false ) return moderained = false , ** kwargs model = hr net v2 ( n class = 1000 , ** kwargs ) if pretrained : model . load state dict ( load url ( model urls [ ' hrnetv2 ' ] ) , strict = false ) return model
self , result with self . lock : assert self . result is none , ' previous result has\\ ' t been fetched . ' self . result = result self . cond . notify ( , result with self . lock : assert self . result is none , ' previous result has\\ ' t been fetched . ' self . result = result self . cond . notify ( )
self , msg self . queue . put ( ( self . identifier , msg ) ) ret = self . result . get ( ) self . queue . put ( true ) return re , msg self . queue . put ( ( self . identifier , msg ) ) ret = self . result . get ( ) self . queue . put ( true ) return ret
a , unbias = true n = a . size ( 0 ) asum = a . sum ( dim = 0 ) as sum = ( a ** 2 ) . sum ( dim = 0 ) sumvar = as sum asum * asum / n if unbias : return sumvar / ( n 1 ) else : return sumvar / unbias = true n = a . size ( 0 ) asum = a . sum ( dim = 0 ) as sum = ( a ** 2 ) . sum ( dim = 0 ) sumvar = as sum asum * asum / n if unbias : return sumvar / ( n 1 ) else : return sumvar / n
self bn = nn . batch norm1d ( 10 ) sync bn = synchronized batch norm1d ( 10 ) self . check batch norm result ( bn , sync bn , torch . rand ( 16 , 10 ) , false bn = nn . batch norm1d ( 10 ) sync bn = synchronized batch norm1d ( 10 ) self . check batch norm result ( bn , sync bn , torch . rand ( 16 , 10 ) , false )
code , prefix = " tmp " , delete = true , ** kwargs py = tempfile . named temporary file ( prefix = prefix , delete = delete ) code = code . format ( ** kwargs ) if is py3 : code = code . encode ( " utf 8 " ) py . write ( code ) py . flush ( ) st = os . stat ( py . name ) os . chmod ( py . name , st . st mode | stat . s iexec ) return py
self from sh import ls , which actual location = which ( " ls " ) out = str ( ls ) self . assert equal ( out , actual location from sh import ls , which actual location = which ( " ls " ) out = str ( ls ) self . assert equal ( out , actual location )
self from sh import sed self . assert equal ( sed ( in = " one test three " , e = " s/test/two/ " ) . strip ( ) , " one two three " from sh import sed self . assert equal ( sed ( in = " one test three " , e = " s/test/two/ " ) . strip ( ) , " one two three " )
self py = create tmp test ( ) self . assert true ( python ( py . name , long option = true ) . strip ( ) == " true " ) self . assert true ( python ( py . name ) . strip ( ) == " false " )
self from sh import ls , wc c1 = int ( wc ( ls ( " a1 " ) , l = true ) ) c2 = len ( os . listdir ( " . " ) ) self . assert equal ( c1 , c2 from sh import ls , wc c1 = int ( wc ( ls ( " a1 " ) , l = true ) ) c2 = len ( os . listdir ( " . " ) ) self . assert equal ( c1 , c2 )
self import tempfile file obj = tempfile . named temporary file ( ) py = create tmp test ( ) stdout = python ( " u " , py . name , err = file obj . name ) . wait ( ) file obj . seek ( 0 ) stderr = file obj . read ( ) . decode ( ) file obj . close ( ) self . assert true ( stdout == " stdout " ) self . assert true ( stderr == " stderr " )
self py = create tmp test ( ) stdout = [ ] def agg ( line ) : stdout . append ( line ) p = python ( " u " , py . name , out = agg ) p . wait ( ) self . assert true ( len ( stdout ) == 5 )
self return raise not implemented error ( " what ' s the best way to test a different \\ ' encoding ' special keyword argument? " return raise not implemented error ( " what ' s the best way to test a different \\ ' encoding ' special keyword argument? " )
self orig = os . getcwd ( ) my dir = os . path . expanduser ( " ~ " ) sh . cd ( ) self . assert not equal ( orig , os . getcwd ( ) ) self . assert equal ( my dir , os . getcwd ( ) orig = os . getcwd ( ) my dir = os . path . expanduser ( " ~ " ) sh . cd ( ) self . assert not equal ( orig , os . getcwd ( ) ) self . assert equal ( my dir , os . getcwd ( ) )
self , f self . register ( f , select . pollin | select . pollpri , f self . register ( f , select . pollin | select . pollpri )
out return isinstance ( out , basestring return isinstance ( out , basestring )
self , buf self . stdin stream . stream bufferer . change buffering ( buf , buf self . stdin stream . stream bufferer . change buffering ( buf )
self return os . getsid ( self . pid )
self return self . stream
handler def process ( chunk ) : handler . write ( chunk ) return false def finish ( ) : pass return process , finisler def process ( chunk ) : handler . write ( chunk ) return false def finish ( ) : pass return process , finish
self , mod fullname parent frame = inspect . currentframe ( ) . f back while in importlib ( parent frame ) : parent frame = parent frame . f back module = fetch module from frame ( mod fullname , parent frame ) sys . modules [ mod fullname ] = module module . loader = self return modul , mod fullname parent frame = inspect . currentframe ( ) . f back while in importlib ( parent frame ) : parent frame = parent frame . f back module = fetch module from frame ( mod fullname , parent frame ) sys . modules [ mod fullname ] = module module . loader = self return module
pieces if pieces [ " closest tag " ] : rendered = pieces [ " closest tag " ] if pieces [ " distance " ] or pieces [ " dirty " ] : rendered += " . post%d " % pieces [ " distance " ] if pieces [ " dirty " ] : rendered += " . dev0 " else : # exception #1 rendered = " 0 . post%d " % pieces [ " distance " ] if pieces [ " dirty " ] : rendered += " . dev0 " return rendered
args , ** kwargs collections , repack = unpack collections ( * args , ** kwargs ) if not collections : return args dsk = collections to dsk ( collections , ** kwargs ) postpersists = [ a . dask postpersist ( ) if is dask collection ( a ) else ( none , a ) for a in args ] keys , postpersists = [ ] , [ ] for a in collections : keys . extend ( flatten ( a . dask keys ( ) ) ) postpersists . append ( a . dask postpersist ( ) ) return repack ( [ r ( dsk , * s ) for r , s in postpersists ] )
buf return mmh3 . hash bytes ( buf )
dependencies , dependents result = dict ( ) num needed = { k : len ( v ) for k , v in dependencies . items ( ) } current = { k for k , v in num needed . items ( ) if v == 0 } while current : key = current . pop ( ) result [ key ] = 1 + sum ( result [ child ] for child in dependencies [ key ] ) for parent in dependents [ key ] : num needed [ parent ] = 1 if num needed [ parent ] == 0 : current . add ( parent ) return result
x return type ( x ) is tuple and x and callable ( x [ 0 ] )
d terms = list ( d . keys ( ) ) + list ( chain . from iterable ( d . values ( ) ) ) result = { t : set ( ) for t in terms } for k , vals in d . items ( ) : for val in vals : result [ val ] . add ( k ) return result
dsk , dependencies = none return toposort ( dsk , dependencies = dependencies )
q return q . get ( turn q . get ( )
dsk , keys , ** kwargs kwargs . pop ( " num workers " , none ) return get async ( apply sync , 1 , dsk , keys , ** kwargs )
x return x turn x 1
func , varargs = true if func in one arity builtins : return false elif func in multi arity builtins : return true try : spec = getargspec ( func ) except exception : return false try : is constructor = spec . args [ 0 ] == " self " and isinstance ( func , type ) except exception : is constructor = false if varargs and spec . varargs : return true ndefaults = 0 if spec . defaults is none else len ( spec . defaults ) return len ( spec . args ) ndefaults is constructor > 1
self , toplevel , func = none def wrapper ( func ) : self . lazy [ toplevel ] = func return func return wrapper ( func ) if func is not none else wrapper
s return [ int ( part ) if part . isdigit ( ) else part for part in re . split ( r " (\\d+) " , s ) ]
n seq = ( [ i , n // i ] for i in range ( 1 , int ( pow ( n , 0 . 5 ) + 1 ) ) if n % i == 0 ) return set ( functools . reduce ( list . add , seq ) )
seq if not isinstance ( seq , ( list , tuple ) ) : return 0 elif not seq : return 1 else : return 1 + ndimlist ( seq [ 0 ] if not isinstance ( seq , ( list , tuple ) ) : return 0 elif not seq : return 1 else : return 1 + ndimlist ( seq [ 0 ] )
k , config try : if k in config : return k except type error : # config is not a mapping , return the same name as provided return k altk = k . replace ( " " , " " ) if " " in k else k . replace ( " " , " " ) if altk in config : return altk return k
head , ind , values , dummies if not ind : return head if ind [ 0 ] not in dummies : return lol tuples ( head + ( values [ ind [ 0 ] ] , ) , ind [ 1 : ] , values , dummies ) else : return [ lol tuples ( head + ( v , ) , ind [ 1 : ] , values , dummies ) for v in dummies [ ind [ 0 ] ] ]
task if istask ( task ) : return task [ 0 ] elif isinstance ( task , list ) : return list else : return task
self , term for rule , sd in self . iter matches ( term ) : # we use for ( . . . ) because it ' s fast in all cases for getting the # first element from the match iterator . as we only want that # element , we break here term = rule . subs ( sd ) break return term
net , term return net . rewrite ( term , term return net . rewrite ( term )
tb return " " . join ( traceback . format tb ( tb ) eturn " " . join ( traceback . format tb ( tb ) )
dsk , keys , ** kwargs dsk = ensure dict ( dsk ) dsk2 , = cull ( dsk , keys ) return dsk , keys , ** kwargs dsk = ensure dict ( dsk ) dsk2 , = cull ( dsk , keys ) return dsk2
cls , op , inv = false method = delayed ( right ( op ) if inv else op , pure = true ) return lambda * args , ** kwargs : method ( * args , ** kwargs , op , inv = false method = delayed ( right ( op ) if inv else op , pure = true ) return lambda * args , ** kwargs : method ( * args , ** kwargs )
pieces if " + " in pieces . get ( " closest tag " , " " ) : return " . " return " + "
pieces if pieces [ " closest tag " ] : rendered = pieces [ " closest tag " ] if pieces [ " distance " ] : rendered += " %d g%s " % ( pieces [ " distance " ] , pieces [ " short " ] ) else : # exception #1 rendered = pieces [ " short " ] if pieces [ " dirty " ] : rendered += " dirty " return rendered
cls , op , inv = false return lambda self , other : scalar binary ( op , self , other , inv = inv , op , inv = false return lambda self , other : scalar binary ( op , self , other , inv = inv )
self , axis = none , limit = none return self . fillna ( method = " bfill " , limit = limit , axis = axis , axis = none , limit = none return self . fillna ( method = " bfill " , limit = limit , axis = axis )
self , axis = none , skipna = true , split every = false , out = none return self . reduction agg ( " max " , axis = axis , skipna = skipna , split every = split every , out = out , axis = none , skipna = true , split every = false , out = none return self . reduction agg ( " max " , axis = axis , skipna = skipna , split every = split every , out = out )
self return self . map partitions ( m . notnull return self . map partitions ( m . notnull )
x , funcname if isinstance ( x , series ) and hasattr ( x , " dtype " ) and x . dtype == object : raise value error ( " `%s` not supported with object series " % funcname )
self , decimals = 0 return elemwise ( m . round , self , decimals , decimals = 0 return elemwise ( m . round , self , decimals )
self , npartitions , upsample = 1 . 0 from . partitionquantiles import partition quantiles return partition quantiles ( self , npartitions , upsample = upsample )
self , values return super ( series , self ) . isin ( values , values return super ( series , self ) . isin ( values )
self , lower = none , upper = none , out = none if out is not none : raise value error ( " ' out ' must be none " ) return self . map partitions ( m . clip , lower = lower , upper = upper , lower = none , upper = none , out = none if out is not none : raise value error ( " ' out ' must be none " ) return self . map partitions ( m . clip , lower = lower , upper = upper )
self , other , join = " outer " , axis = none , fill value = none return super ( series , self ) . align ( other , join = join , axis = axis , fill value = fill value , other , join = " outer " , axis = none , fill value = none return super ( series , self ) . align ( other , join = join , axis = axis , fill value = fill value )
self , other , func , fill value = none return self . map partitions ( m . combine , other , func , fill value = fill value , other , func , fill value = none return self . map partitions ( m . combine , other , func , fill value = fill value )
cls , name , op def meth ( self , other , level = none , fill value = none , axis = 0 ) : if level is not none : raise not implemented error ( " level must be none " ) axis = self . validate axis ( axis ) meta = emulate ( op , self , other , axis = axis , fill value = fill value ) return map partitions ( op , self , other , meta = meta , axis = axis , fill value = fill value ) meth . doc = skip doctest ( op . doc ) setattr ( cls , name , meth )
self return self . meta . column return self . meta . columns
self , expr , ** kwargs return self . map partitions ( m . query , expr , ** kwargs )
g , levels return g . groupby ( level = levels , sort = false ) . sum ( levels return g . groupby ( level = levels , sort = false ) . sum ( )
self , axis = 0 if axis : return self . obj . cumsum ( axis = axis ) else : return self . cum agg ( " cumsum " , chunk = m . cumsum , aggregate = m . add , initial = 0 , axis = 0 if axis : return self . obj . cumsum ( axis = axis ) else : return self . cum agg ( " cumsum " , chunk = m . cumsum , aggregate = m . add , initial = 0 )
divisions , val if divisions [ 0 ] is none : msg = " can not use loc on data frame without known divisions " raise value error ( msg ) val = coerce loc index ( divisions , val ) i = bisect . bisect right ( divisions , val ) return min ( len ( divisions ) 2 , max ( 0 , i 1 ) )
a " compute the position of the first nonzero bit for each int in an array . " bits = np . bitwise and . outer ( a , 1 << np . arange ( 32 ) ) bits = bits . cumsum ( axis = 1 ) . astype ( np . bool ) return 33 bits . sum ( axis = 1 compute the position of the first nonzero bit for each int in an array . " bits = np . bitwise and . outer ( a , 1 << np . arange ( 32 ) ) bits = bits . cumsum ( axis = 1 ) . astype ( np . bool ) return 33 bits . sum ( axis = 1 )
self if not self . known : return self . series out = self . series . copy ( ) out . meta = clear known categories ( out . meta ) return out
self if not self . known : msg = ( " `df . column . cat . categories` with unknown categories is not " " supported . please use `column . cat . as known()` or " " `df . categorize()` beforehand to ensure known categories " ) raise not implemented error ( msg ) return self . delegate property ( self . series . meta , " cat " , " categories " )
func , keys , token level = 0 prev width = len ( keys ) prev keys = iter ( keys ) rv = { } while prev width > 1 : width = tree width ( prev width ) groups = tree groups ( prev width , width ) keys = [ ( token , level , i ) for i in range ( width ) ] rv . update ( ( key , ( func , list ( take ( num , prev keys ) ) ) ) for num , key in zip ( groups , keys ) ) prev width = width prev keys = iter ( keys ) level += 1 return rv
df , rolling kwargs , name , * args , ** kwargs rolling = df . rolling ( ** rolling kwargs ) return getattr ( rolling , name ) ( * args , ** kwargs , rolling kwargs , name , * args , ** kwargs rolling = df . rolling ( ** rolling kwargs ) return getattr ( rolling , name ) ( * args , ** kwargs )
self return self . call method ( " median " return self . call method ( " median " )
self , func , args = ( ) , kwargs = { } , ** kwds return self . call method ( " agg " , func , args = args , kwargs = kwargs , ** kwds , func , args = ( ) , kwargs = { } , ** kwds return self . call method ( " agg " , func , args = args , kwargs = kwargs , ** kwds )
self return self . agg ( " prod " return self . agg ( " prod " )
self return self . agg ( " sem " return self . agg ( " sem " )
self return self . agg ( " sum " return self . agg ( " sum " )
tmpdir , engine fn = str ( tmpdir ) with pytest . raises ( type error ) : ddf . to parquet ( fn , engine = engine , unknown key = " unknown value " ir , engine fn = str ( tmpdir ) with pytest . raises ( type error ) : ddf . to parquet ( fn , engine = engine , unknown key = " unknown value " )
def blocksize = auto blocksize ( 1000000000000 , 3 ) assert blocksize == int ( 64e6 ) assert isinstance ( blocksize , int blocksize = auto blocksize ( 1000000000000 , 3 ) assert blocksize == int ( 64e6 ) assert isinstance ( blocksize , int )
def with filetext ( csv text ) as fn : try : dd . read csv ( fn , blocksize = 30 , index col = " name " ) assert false except value error as e : assert " set index " in str ( e with filetext ( csv text ) as fn : try : dd . read csv ( fn , blocksize = 30 , index col = " name " ) assert false except value error as e : assert " set index " in str ( e )
df , before , after , c = 0 a = df . shift ( before . seconds ) b = df . shift ( after . seconds ) return df + a + b + , before , after , c = 0 a = df . shift ( before . seconds ) b = df . shift ( after . seconds ) return df + a + b + c
@ with pytest . raises ( type error ) : df . rolling ( 2 ) . apply ( mad , raw = true th pytest . raises ( type error ) : df . rolling ( 2 ) . apply ( mad , raw = true )
def assert shuffle ( d , d . b ) . npartitions == d . npartitionassert shuffle ( d , d . b ) . npartitions == d . npartitions
def import partd f = maybe buffered partd ( ) p1 = f ( ) assert isinstance ( p1 . partd , partd . buffer ) f2 = pickle . loads ( pickle . dumps ( f ) ) assert not f2 . buffer p2 = f2 ( ) assert isinstance ( p2 . partd , partd . file import partd f = maybe buffered partd ( ) p1 = f ( ) assert isinstance ( p1 . partd , partd . buffer ) f2 = pickle . loads ( pickle . dumps ( f ) ) assert not f2 . buffer p2 = f2 ( ) assert isinstance ( p2 . partd , partd . file )
df , * args , ** kwargs return df . set index ( * args , ** kwargs ) . division, * args , ** kwargs return df . set index ( * args , ** kwargs ) . divisions
shuffle df = pd . data frame ( { " x " : np . random . random ( 100 ) } ) ddf = dd . from pandas ( df , npartitions = 50 ) ddf2 = ddf . set index ( " x " , shuffle = shuffle , npartitions = " auto " ) assert ddf2 . npartitions < 1fle df = pd . data frame ( { " x " : np . random . random ( 100 ) } ) ddf = dd . from pandas ( df , npartitions = 50 ) ddf2 = ddf . set index ( " x " , shuffle = shuffle , npartitions = " auto " ) assert ddf2 . npartitions < 10
def with pytest . warns ( future warning ) : assert eq ( d . loc [ [ 3 , 4 , 3 ] , [ " a " ] ] , full . loc [ [ 3 , 4 , 3 ] , [ " a " ] ] with pytest . warns ( future warning ) : assert eq ( d . loc [ [ 3 , 4 , 3 ] , [ " a " ] ] , full . loc [ [ 3 , 4 , 3 ] , [ " a " ] ] )
def idx = pd . u int64 index ( [ 1 ] , name = " foo " ) res = meta nonempty ( idx ) assert type ( res ) is pd . u int64 index assert res . name == idx . namidx = pd . u int64 index ( [ 1 ] , name = " foo " ) res = meta nonempty ( idx ) assert type ( res ) is pd . u int64 index assert res . name == idx . name
def assert ( d . dtypes == full . dtypes ) . all ( assert ( d . dtypes == full . dtypes ) . all ( )
self , ** kwargs from . profile visualize import visualize return visualize ( self , ** kwargs )
def bp = import required ( " bokeh . plotting " , bokeh missing msg ) o = bp . figure . properties ( ) o . add ( " tools " ) return bp = import required ( " bokeh . plotting " , bokeh missing msg ) o = bp . figure . properties ( ) o . add ( " tools " ) return o
p , title return getattr ( p . title , " text " , p . title ) == titl title return getattr ( p . title , " text " , p . title ) == title
dir server root = " http://localhost:8999/ " fs = open files ( root + " /* " ) assert fs [ 0 ] . path == " http://localhost:8999/a " assert fs [ 1 ] . path == " http://localhost:8999/b "server root = " http://localhost:8999/ " fs = open files ( root + " /* " ) assert fs [ 0 ] . path == " http://localhost:8999/a " assert fs [ 1 ] . path == " http://localhost:8999/b "
def test filepath = os . path . join ( " path " , " to " , " file . txt " ) path = pathlib . path ( test filepath ) assert stringify path ( path ) == test filepath class custom fs path : def init ( self , path ) : self . path = path def fspath ( self ) : return self . path path = custom fs path ( test filepath ) assert stringify path ( path ) == test filepath path = ( 1 , 2 , 3 ) assert stringify path ( path ) is path
dsk , keys , dependencies = none if dependencies is none : dependencies = { k : get dependencies ( dsk , task = v ) for k , v in dsk . items ( ) } dependents = reverse dict ( dependencies ) inline keys = { k for k , v in dsk . items ( ) if istask ( v ) and v and v [ 0 ] is list and len ( dependents [ k ] ) == 1 } inline keys . difference update ( flatten ( keys ) ) dsk = inline ( dsk , inline keys , inline constants = false ) for k in inline keys : del dsk [ k ] return dsk
self , split every = none return self . reduction ( any , any , split every = split every )
seq if isinstance ( seq , iterator ) : seq = list ( seq ) if seq and isinstance ( seq [ 0 ] , iterator ) : seq = list ( map ( list , seq ) ) return seif isinstance ( seq , iterator ) : seq = list ( seq ) if seq and isinstance ( seq [ 0 ] , iterator ) : seq = list ( map ( list , seq ) ) return seq
kwargs kwargs2 = { } dependencies = [ ] for k , v in kwargs . items ( ) : vv , collections = unpack collections ( v ) if not collections : kwargs2 [ k ] = v else : kwargs2 [ k ] = vv dependencies . extend ( collections ) if dependencies : kwargs2 = ( dict , ( zip , list ( kwargs2 ) , list ( kwargs2 . values ( ) ) ) ) return kwargs2 , dependencies
seq , columns , dtypes import pandas as pd seq = reify ( seq ) if not isinstance ( seq , list ) : seq = list ( seq ) res = pd . data frame ( seq , columns = list ( columns ) ) return res . astype ( dtypes , copy = false , columns , dtypes import pandas as pd seq = reify ( seq ) if not isinstance ( seq , list ) : seq = list ( seq ) res = pd . data frame ( seq , columns = list ( columns ) ) return res . astype ( dtypes , copy = false )
nin , nout b = db . from sequence ( range ( 100 ) , npartitions = nin ) c = b . repartition ( npartitions = nout ) assert c . npartitions == nout assert eq ( b , c ) results = dask . get ( c . dask , c . dask keys ( ) ) assert all ( results , nout b = db . from sequence ( range ( 100 ) , npartitions = nin ) c = b . repartition ( npartitions = nout ) assert c . npartitions == nout assert eq ( b , c ) results = dask . get ( c . dask , c . dask keys ( ) ) assert all ( results )
def list ( db . from sequence ( [ ] ) ) == [ list ( db . from sequence ( [ ] ) ) == [ ]
def f = lambda : none b = db . from sequence ( [ f ] ) assert eq ( b , [ f ] f = lambda : none b = db . from sequence ( [ f ] ) assert eq ( b , [ f ] )
def async def f ( ) : x = dask . delayed ( inc ) ( 1 ) y = x + 1 z = await y . persist ( ) assert len ( z . dask ) == 1 asyncio . get event loop ( ) . run until complete ( f ( ) async def f ( ) : x = dask . delayed ( inc ) ( 1 ) y = x + 1 z = await y . persist ( ) assert len ( z . dask ) == 1 asyncio . get event loop ( ) . run until complete ( f ( ) )
request return request . paraest return request . param
abcde r a , b , c , d , e = abcde dsk = { a : ( f , b , c , d ) , b : ( f , d , e ) , c : ( f , d ) , d : 1 , e : 2 } o = order ( dsk ) assert o [ e ] < o [ d ] assert o [ d ] < o [ b ] or o [ d ] < o [ c ]
abcde a , b , c , d , e = abcde dsk = { a : 1 , ( a , 1 ) : 2 , ( a , b , 1 ) : 3 } order ( dsk e a , b , c , d , e = abcde dsk = { a : 1 , ( a , 1 ) : 2 , ( a , b , 1 ) : 3 } order ( dsk )
def assert task label ( ( partial ( add , 1 ) , 1 ) ) == " add " assert task label ( ( add , 1 ) ) == " add " assert task label ( ( add , ( add , 1 , 2 ) ) ) == " add( . . . ) "assert task label ( ( partial ( add , 1 ) , 1 ) ) == " add " assert task label ( ( add , 1 ) ) == " add " assert task label ( ( add , ( add , 1 , 2 ) ) ) == " add( . . . ) "
@ assert get context ( ) is multiprocessing . get context ( none ) with dask . config . set ( { " multiprocessing . context " : " forkserver " } ) : assert get context ( ) is multiprocessing . get context ( " forkserver " ) with dask . config . set ( { " multiprocessing . context " : " spawn " } ) : assert get context ( ) is multiprocessing . get context ( " spawn " )
def dsk = { " foo " : none } assert get dependencies ( dsk , task = dsk [ " foo " ] ) == set ( dsk = { " foo " : none } assert get dependencies ( dsk , task = dsk [ " foo " ] ) == set ( )
def for power , mem repr in enumerate ( [ " 1 . 0 bytes " , " 1 . 0 kb " , " 1 . 0 mb " , " 1 . 0 gb " ] ) : assert memory repr ( 1024 ** power ) == mem repfor power , mem repr in enumerate ( [ " 1 . 0 bytes " , " 1 . 0 kb " , " 1 . 0 mb " , " 1 . 0 gb " ] ) : assert memory repr ( 1024 ** power ) == mem repr
def assert partial by order ( 5 , function = operator . add , other = [ ( 1 , 20 ) ] ) == 2assert partial by order ( 5 , function = operator . add , other = [ ( 1 , 20 ) ] ) == 25
x flag . append ( x ) return x + ag . append ( x ) return x + 1
def flag = [ false ] class my callback ( callback ) : def start ( self , dsk ) : flag [ 0 ] = true with my callback ( ) : get sync ( { " x " : 1 } , " x " ) assert flag [ 0 ] is truflag = [ false ] class my callback ( callback ) : def start ( self , dsk ) : flag [ 0 ] = true with my callback ( ) : get sync ( { " x " : 1 } , " x " ) assert flag [ 0 ] is true
a , b = 1 , c = 2 pas b = 1 , c = 2 pass
@ tokenize ( np . random . random ( 8 ) [ : : 2 ] kenize ( np . random . random ( 8 ) [ : : 2 ] )
@ assert tokenize ( np . sin ) == " 02106e2c67daf452fb480d264e0dac21 " assert tokenize ( np . cos ) == " c99e52e912e4379882a9a4b387957a0b " inc = np . frompyfunc ( lambda x : x + 1 , 1 , 1 ) assert tokenize ( inc ) == tokenize ( inc sert tokenize ( np . sin ) == " 02106e2c67daf452fb480d264e0dac21 " assert tokenize ( np . cos ) == " c99e52e912e4379882a9a4b387957a0b " inc = np . frompyfunc ( lambda x : x + 1 , 1 , 1 ) assert tokenize ( inc ) == tokenize ( inc )
def for i in [ 1 , 1 . 1 , " 1 " , slice ( 1 , 2 , 3 ) ] : assert normalize token ( i ) is for i in [ 1 , 1 . 1 , " 1 " , slice ( 1 , 2 , 3 ) ] : assert normalize token ( i ) is i
def assert tokenize ( { " x " : 1 , 1 : " x " } ) == tokenize ( { " x " : 1 , 1 : " x " } assert tokenize ( { " x " : 1 , 1 : " x " } ) == tokenize ( { " x " : 1 , 1 : " x " } )
results if not results : return concatenate3 ( results ) results2 = results while isinstance ( results2 , ( tuple , list ) ) : if len ( results2 ) > 1 : return concatenate3 ( results ) else : results2 = results2 [ 0 ] return unpack singleton ( results lts if not results : return concatenate3 ( results ) results2 = results while isinstance ( results2 , ( tuple , list ) ) : if len ( results2 ) > 1 : return concatenate3 ( results ) else : results2 = results2 [ 0 ] return unpack singleton ( results )
self , columns = none , index = none from . . dataframe import from dask array return from dask array ( self , columns = columns , index = index )
self , cast type if self . size > 1 : raise type error ( " only length 1 arrays can be converted to python scalars " ) else : return cast type ( self . compute ( ) , cast type if self . size > 1 : raise type error ( " only length 1 arrays can be converted to python scalars " ) else : return cast type ( self . compute ( ) )
self , * shape from . reshape import reshape if len ( shape ) == 1 and not isinstance ( shape [ 0 ] , number ) : shape = shape [ 0 ] return reshape ( self , shape , * shape from . reshape import reshape if len ( shape ) == 1 and not isinstance ( shape [ 0 ] , number ) : shape = shape [ 0 ] return reshape ( self , shape )
self , axis = none , keepdims = false , split every = none , out = none from . reductions import min return min ( self , axis = axis , keepdims = keepdims , split every = split every , out = out , axis = none , keepdims = false , split every = none , out = none from . reductions import min return min ( self , axis = axis , keepdims = keepdims , split every = split every , out = out )
self , decimals = 0 from . routines import round return round ( self , decimals = decimals , decimals = 0 from . routines import round return round ( self , decimals = decimals )
x while isinstance ( x , ( list , tuple ) ) : try : x = x [ 0 ] except ( index error , type error , key error ) : break return x
arrays if not arrays : return ( ) result = [ ] dim = 0 def shape ( x ) : try : return x . shape except attribute error : return ( 1 , ) while isinstance ( arrays , ( list , tuple ) ) : result . append ( tuple ( [ shape ( deepfirst ( a ) ) [ dim ] for a in arrays ] ) ) arrays = arrays [ 0 ] dim += 1 return tuple ( result )
locations , values locations = list ( map ( list , locations ) ) values = list ( values ) n = sum ( map ( len , locations ) ) shape = list ( values [ 0 ] . shape ) shape [ 0 ] = n shape = tuple ( shape ) dtype = values [ 0 ] . dtype x = np . empty ( shape , dtype = dtype ) ind = [ slice ( none , none ) for i in range ( x . ndim ) ] for loc , val in zip ( locations , values ) : ind [ 0 ] = loc x [ tuple ( ind ) ] = val return x
x data = normalize token ( x . data ) mask = normalize token ( x . mask ) fill value = normalize token ( x . fill value ) return ( data , mask , fill value ta = normalize token ( x . data ) mask = normalize token ( x . mask ) fill value = normalize token ( x . fill value ) return ( data , mask , fill value )
chunks return reduce ( mul , map ( max , chunks ) ks return reduce ( mul , map ( max , chunks ) )
plan return [ format chunks ( c ) for c in plan ]
def class a : def array function ( self , * args , ** kwargs ) : return true try : return np . concatenate ( [ a ( ) ] ) except value error : return falsclass a : def array function ( self , * args , ** kwargs ) : return true try : return np . concatenate ( [ a ( ) ] ) except value error : return false
m , n k 0 = min ( [ m , n ] ) k 1 = m if np . isnan ( n ) else n return k 1 if np . isnan ( k 0 ) else k n k 0 = min ( [ m , n ] ) k 1 = m if np . isnan ( n ) else n return k 1 if np . isnan ( k 0 ) else k 0
a , lower = false l , u = cholesky ( a ) if lower : return l else : return u
df , t prob = ( delayed ( distributions . t . sf ) ( da . absolute ( t ) , df ) * 2 ) if t . ndim == 0 : t = t [ ( ) ] return t , prob
m , axis m = asanyarray ( m ) sl = m . ndim * [ slice ( none ) ] try : sl [ axis ] = slice ( none , none , 1 ) except index error : raise value error ( " `axis` of %s invalid for %s d array " % ( str ( axis ) , str ( m . ndim ) ) ) sl = tuple ( sl ) return m [ sl ]
ar1 , ar2 return unique ( concatenate ( ( ar1 . ravel ( ) , ar2 . ravel ( ) ) ) , ar2 return unique ( concatenate ( ( ar1 . ravel ( ) , ar2 . ravel ( ) ) ) )
x , decimals = 0 return map blocks ( partial ( np . around , decimals = decimals ) , x , dtype = x . dtype decimals = 0 return map blocks ( partial ( np . around , decimals = decimals ) , x , dtype = x . dtype )
a , axis = none , weights = none , returned = false return average ( a , axis , weights , returned , is masked = false axis = none , weights = none , returned = false return average ( a , axis , weights , returned , is masked = false )
target , source = none target . doc = skip doctest ( source . doc ) return targeet , source = none target . doc = skip doctest ( source . doc ) return target
ind if isinstance ( ind , number ) : ind2 = int ( ind ) if ind2 != ind : raise index error ( " bad index . must be integer like: %s " % ind ) else : return ind2 elif ind is none : return none else : raise type error ( " invalid index type " , type ( ind ) , ind )
seq if len ( seq ) == 0 : return true return np . all ( seq [ : 1 ] <= seq [ 1 : ] )
idx , dim if isinstance ( idx , slice ) : if math . isnan ( dim ) : return idx start , stop , step = idx . indices ( dim ) if step > 0 : if start == 0 : start = none if stop >= dim : stop = none if step == 1 : step = none if stop is not none and start is not none and stop < start : stop = start elif step < 0 : if start >= dim 1 : start = none if stop < 0 : stop = none return slice ( start , stop , step ) return idx
seq , initial zero = false if isinstance ( seq , tuple ) : # look up by identity first , to avoid a linear time hash # if we ' ve seen this tuple object before . result = cumsum ( hash id wrapper ( seq ) ) else : # construct a temporary tuple , and look up by value . result = cumsum ( tuple ( seq ) ) if not initial zero : result = result [ 1 : ] return result
a , axis = none , keepdims = false , split every = none , out = none return reduction ( a , chunk . all , chunk . all , axis = axis , keepdims = keepdims , dtype = " bool " , split every = split every , out = out , axis = none , keepdims = false , split every = none , out = none return reduction ( a , chunk . all , chunk . all , axis = axis , keepdims = keepdims , dtype = " bool " , split every = split every , out = out , )
x , axis , dtype = none , out = none return cumreduction ( chunk . nancumprod , operator . mul , 1 , x , axis , dtype , out = out axis , dtype = none , out = none return cumreduction ( chunk . nancumprod , operator . mul , 1 , x , axis , dtype , out = out )
func , argfunc , data , axis = none , ** kwargs arg , vals = arg combine ( data , axis , argfunc , keepdims = false ) if np . any ( np . isnan ( vals ) ) : raise value error ( " all na n slice encountered " ) return ar , argfunc , data , axis = none , ** kwargs arg , vals = arg combine ( data , axis , argfunc , keepdims = false ) if np . any ( np . isnan ( vals ) ) : raise value error ( " all na n slice encountered " ) return arg
a , k , axis , keepdims assert keepdims is true axis = axis [ 0 ] if abs ( k ) >= a . shape [ axis ] : return a a = np . partition ( a , k , axis = axis ) k slice = slice ( k , none ) if k > 0 else slice ( k ) return a [ tuple ( k slice if i == axis else slice ( none ) for i in range ( a . ndim ) ) ]
a plus idx , k , axis , keepdims assert keepdims is true a , idx = argtopk ( a plus idx , k , axis , keepdims ) axis = axis [ 0 ] idx2 = np . argsort ( a , axis = axis ) idx = take along axis ( idx , idx2 , axis ) if k < 0 : return idx return idx [ tuple ( slice ( none , none , 1 ) if i == axis else slice ( none ) for i in range ( idx . ndim ) ) ]
self , seed = none self . numpy state . seed ( seed , seed = none self . numpy state . seed ( seed )
self , dfnum , dfden , nonc , size = none , chunks = " auto " return self . wrap ( " noncentral f " , dfnum , dfden , nonc , size = size , chunks = chunks , dfnum , dfden , nonc , size = none , chunks = " auto " return self . wrap ( " noncentral f " , dfnum , dfden , nonc , size = size , chunks = chunks )
self , low = 0 . 0 , high = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " uniform " , low , high , size = size , chunks = chunks , low = 0 . 0 , high = 1 . 0 , size = none , chunks = " auto " return self . wrap ( " uniform " , low , high , size = size , chunks = chunks )
def assert " mean " in da . random . random state ( 5 ) . normal . doc assert " mean " in da . random . random state ( 5 ) . normal . doc
def assert da . ones ( 20 , chunks = 5 ) [ : : 2 ] . chunks == ( ( 3 , 2 , 3 , 2 ) , assert da . ones ( 20 , chunks = 5 ) [ : : 2 ] . chunks == ( ( 3 , 2 , 3 , 2 ) , )
def def crash ( ) : raise not implemented error ( ) x = da . arange ( 5 , chunks = 1 ) idx = da . array ( { ( " x " , 0 ) : ( crash , ) } , name = " x " , chunks = ( ( 2 , ) , ) , dtype = np . int64 ) result = x [ idx ] with pytest . raises ( not implemented error ) : result . compute ( )
output dtypes def foo ( x ) : return y x = np . random . randn ( 10 ) y = x . astype ( int ) dy = apply gufunc ( foo , " () >() " , x , output dtypes = output dtypes ) assert eq ( y , dy ut dtypes def foo ( x ) : return y x = np . random . randn ( 10 ) y = x . astype ( int ) dy = apply gufunc ( foo , " () >() " , x , output dtypes = output dtypes ) assert eq ( y , dy )
steps , expected assert len ( steps ) == len ( expected ) assert steps == expectes , expected assert len ( steps ) == len ( expected ) assert steps == expected
def nan = float ( " nan " ) with pytest . raises ( value error ) as record : old to new ( ( ( nan , nan ) , ( 4 , 4 ) ) , ( ( nan , nan , nan ) , ( 4 , 4 ) ) ) assert " unchanging " in str ( record . value nan = float ( " nan " ) with pytest . raises ( value error ) as record : old to new ( ( ( nan , nan ) , ( 4 , 4 ) ) , ( ( nan , nan , nan ) , ( 4 , 4 ) ) ) assert " unchanging " in str ( record . value )
def y = da . asarray ( xr . data array ( [ 1 , 2 , 3 . 0 ] ) ) assert isinstance ( y , da . array ) assert eq ( y , y y = da . asarray ( xr . data array ( [ 1 , 2 , 3 . 0 ] ) ) assert isinstance ( y , da . array ) assert eq ( y , y )
self , * args , ** kwargs self . acquire count += 1 return self . lock . acquire ( * args , ** kwargs , * args , ** kwargs self . acquire count += 1 return self . lock . acquire ( * args , ** kwargs )
@ d = da . ones ( ( 10 , 10 ) , chunks = ( 2 , 2 ) ) a = d + 1 at = np . zeros ( shape = ( 10 , 10 ) ) st = a . store ( at , scheduler = " processes " , num workers = 10 ) assert st is non= da . ones ( ( 10 , 10 ) , chunks = ( 2 , 2 ) ) a = d + 1 at = np . zeros ( shape = ( 10 , 10 ) ) st = a . store ( at , scheduler = " processes " , num workers = 10 ) assert st is none
x , chunks dx = da . from array ( my array ( x ) , chunks = chunks , asarray = false ) assert eq ( x , dx chunks dx = da . from array ( my array ( x ) , chunks = chunks , asarray = false ) assert eq ( x , dx )
x dx = da . from array ( x , chunks = 1 ) assert eq ( np . array ( x ) , dx ) assert isinstance ( dx . dask [ dx . name , 0 ] , np . ndarray ) dx = da . from array ( x , chunks = 1 ) assert eq ( np . array ( x ) , dx ) assert dx . dask [ dx . name , 0 ] [ 0 ] == operator . getitem assert isinstance ( dx . dask [ dx . name . replace ( " array " , " array original " ) ] , np . ndarray )
type if type == np . datetime64 : x = np . datetime64 ( " 2000 01 01 " ) else : x = type ( 1 ) dx = da . from array ( x , chunks = 1 ) assert eq ( np . array ( x ) , dx ) assert isinstance ( dx . dask [ dx . name , ] , np . ndarray )
def x = np . array ( [ " 2000 01 01 " ] , dtype = " datetime64 " ) dx = da . asanyarray ( x ) assert isinstance ( dx , da . array ) assert eq ( x , dx x = np . array ( [ " 2000 01 01 " ] , dtype = " datetime64 " ) dx = da . asanyarray ( x ) assert isinstance ( dx , da . array ) assert eq ( x , dx )
def x = da . ones ( 5 , chunks = ( 2 , ) ) assert x . a is x = da . ones ( 5 , chunks = ( 2 , ) ) assert x . a is x
def from pickle import loads , dumps a = da . arange ( 100 , chunks = 25 ) a2 = loads ( dumps ( a ) ) assert eq ( a , a2 from pickle import loads , dumps a = da . arange ( 100 , chunks = 25 ) a2 = loads ( dumps ( a ) ) assert eq ( a , a2 )
shape , chunks , reps x = np . random . random ( shape ) d = da . from array ( x , chunks = chunks ) assert eq ( np . tile ( x , reps ) , da . tile ( d , reps ) e , chunks , reps x = np . random . random ( shape ) d = da . from array ( x , chunks = chunks ) assert eq ( np . tile ( x , reps ) , da . tile ( d , reps ) )
def with dask . config . set ( { " array . chunk size " : " 50 mi b " } ) : x = da . ones ( ( 10000 , 10000 ) ) assert 4 < x . npartitions < 3with dask . config . set ( { " array . chunk size " : " 50 mi b " } ) : x = da . ones ( ( 10000 , 10000 ) ) assert 4 < x . npartitions < 32
def x = np . array ( list ( " hello world " ) ) d = da . from array ( x , chunks = ( 4 , ) ) x c = np . count nonzero ( x ) d c = da . count nonzero ( d ) assert x c == d c . compute ( x = np . array ( list ( " hello world " ) ) d = da . from array ( x , chunks = ( 4 , ) ) x c = np . count nonzero ( x ) d c = da . count nonzero ( d ) assert x c == d c . compute ( )
arg return " : " in arreturn " : " in arg
self self . controller . quit ( ) self . sc2 proc . close ( ) print ( " apm name " ) for name , info in self . summary : print ( " %4d %s " % ( info . player info [ 0 ] . player apm , name ) self . controller . quit ( ) self . sc2 proc . close ( ) print ( " apm name " ) for name , info in self . summary : print ( " %4d %s " % ( info . player info [ 0 ] . player apm , name ) )
data print ( " buffs . py " . center ( 60 , " " ) ) print ( " class buffs(enum . int enum): " ) print ( ' """ the list of buffs , as returned from request data . """ ' ) for buff in sorted ( data . buffs , key = lambda a : a . name ) : if buff . name and buff . buff id in static data . buffs : print ( " %s = %s " % ( buff . name , buff . buff id ) ) print ( " \ " )
def app . run ( main app . run ( main )
self , version = none , ** kwargs raise not implemented error ( )
self return self . observation spec
self return self . step type is step type . las return self . step type is step type . last
self , env expected = env . next timestep [ 0 ] . replace ( step type = environment . step type . first , reward = 0 , discount = 0 ) timestep = env . reset ( ) self . assert equal ( timestep , [ expected ] , env expected = env . next timestep [ 0 ] . replace ( step type = environment . step type . first , reward = 0 , discount = 0 ) timestep = env . reset ( ) self . assert equal ( timestep , [ expected ] )
arg return arg if isinstance ( arg , list ) else [ arg return arg if isinstance ( arg , list ) else [ arg ]
self , replay dir , prefix = none if prefix is none : prefix = self . map name replay path = self . run config . save replay ( self . controllers [ 0 ] . save replay ( ) , replay dir , prefix ) logging . info ( " wrote replay to: %s " , replay path ) return replay pat , replay dir , prefix = none if prefix is none : prefix = self . map name replay path = self . run config . save replay ( self . controllers [ 0 ] . save replay ( ) , replay dir , prefix ) logging . info ( " wrote replay to: %s " , replay path ) return replay path
self self . assert equal ( self . env . action spec ( ) , self . mock env . action spec ( ) self . assert equal ( self . env . action spec ( ) , self . mock env . action spec ( ) )
self , * args , ** kwargs return self . env . observation spec ( * args , ** kwargs , * args , ** kwargs return self . env . observation spec ( * args , ** kwargs )
self if hasattr ( self , " controller " ) and self . controller : self . controller . quit ( ) self . controller . close ( ) self . controller = none self . shutdown ( ) if hasattr ( self , " port " ) and self . port : if not flags . sc2 port : portpicker . return port ( self . port ) self . port = none if hasattr ( self , " tmp dir " ) and os . path . exists ( self . tmp dir ) : shutil . rmtree ( self . tmp dir )
self return self . controlle return self . controller
self return self . por return self . port
cls return cls ( random . random ( ) , random . random ( ) )
self , min size return self * ( min size / self ) . max dim ( )
self , angle return point ( self . x * math . cos ( angle ) self . y * math . sin ( angle ) , self . x * math . sin ( angle ) + self . y * math . cos ( angle ) , angle return point ( self . x * math . cos ( angle ) self . y * math . sin ( angle ) , self . x * math . sin ( angle ) + self . y * math . cos ( angle ) )
self , pt return ( self . l < pt . x and self . r > pt . x and self . t < pt . y and self . b > pt . y )
self , pt , radius return ( self . l < pt . x radius and self . r > pt . x + radius and self . t < pt . y radius and self . b > pt . y + radius )
self with self . assert raises ( value error ) : features . to point ( ( 32 , ) with self . assert raises ( value error ) : features . to point ( ( 32 , ) )
self with self . assert raises ( value error ) : features . dimensions ( screen = ( 0 , 0 ) , minimap = ( 0 , 0 ) with self . assert raises ( value error ) : features . dimensions ( screen = ( 0 , 0 ) , minimap = ( 0 , 0 ) )
self , action spec , func id args = [ [ numpy . random . randint ( 0 , size ) for size in arg . sizes ] # pylint: disable=g complex comprehension for arg in action spec . functions [ func id ] . args ] return actions . function call ( func id , args , action spec , func id args = [ [ numpy . random . randint ( 0 , size ) for size in arg . sizes ] # pylint: disable=g complex comprehension for arg in action spec . functions [ func id ] . args ] return actions . function call ( func id , args )
ports for port in ports : if port in contiguous ports : contiguous ports . discard ( port ) else : portpicker . return port ( port )
self return self . rgb dimension return self . rgb dimensions
self return self . valid functions
error enum def decorator ( func ) : @ functools . wraps ( func ) def check error ( * args , ** kwargs ) : return check error ( func ( * args , ** kwargs ) , error enum ) return check error return decorator
self , req join game return self . client . send ( join game = req join game )
self , debug commands if isinstance ( debug commands , sc debug . debug command ) : debug commands = [ debug commands ] return self . client . send ( debug = sc pb . request debug ( debug = debug commands ) )
self return 0 if self . num == 0 else self . sum / self . nu return 0 if self . num == 0 else self . sum / self . num
self , other for k , v in six . iteritems ( other . times ) : self . times [ k ] . merge ( v , other for k , v in six . iteritems ( other . times ) : self . times [ k ] . merge ( v )
action , action space , select add , screen , screen2 select = spatial ( action , action space ) . unit selection rect out rect = select . selection screen coord . add ( ) screen rect = point . rect ( screen , screen2 ) screen rect . tl . assign to ( out rect . p0 ) screen rect . br . assign to ( out rect . p1 ) select . selection add = bool ( select add )
action , action space , ability id , queued , minimap action cmd = spatial ( action , action space ) . unit command action cmd . ability id = ability id action cmd . queue command = queued minimap . assign to ( action cmd . target minimap coord )
self , color , start loc , end loc , thickness = 1 pygame . draw . line ( self . surf , color , self . world to surf . fwd pt ( start loc ) . round ( ) , self . world to surf . fwd pt ( end loc ) . round ( ) , max ( 1 , thickness ) )
self , color , world rect , thickness = 0 tl = self . world to surf . fwd pt ( world rect . tl ) . round ( ) br = self . world to surf . fwd pt ( world rect . br ) . round ( ) rect = pygame . rect ( tl , br tl ) pygame . draw . rect ( self . surf , color , rect , thickness )
self return self . surf . world to surf . fwd pt ( self . world pos return self . surf . world to surf . fwd pt ( self . world pos )
self , surf select start = self . select start if select start : mouse pos = self . get mouse pos ( ) if ( mouse pos and mouse pos . surf . surf type & surf type . screen and mouse pos . surf . surf type == select start . surf . surf type ) : rect = point . rect ( select start . world pos , mouse pos . world pos ) surf . draw rect ( colors . green , rect , 1 )
self now = time . time ( ) for act in self . past actions : if act . pos and now < act . deadline : remain = ( act . deadline now ) / ( act . deadline act . time ) if isinstance ( act . pos , point . point ) : size = remain / 3 self . all surfs ( surface . draw circle , act . color , act . pos , size , 1 ) else : # fade with alpha would be nice , but doesn ' t seem to work . self . all surfs ( surface . draw rect , act . color , act . pos , 1 )
self , surf surf . blit np array ( features . feature . unpack rgb image ( self . obs . observation . render data . map ) )
self , surf , from obs , name , color if from obs : layer = getattr ( self . obs . observation . raw data . map state , name ) else : layer = getattr ( self . game info . start raw , name ) layer = features . feature . unpack layer ( layer ) if layer is not none : surf . blit np array ( color [ layer ] ) else : # ignore layers that aren ' t in this version of sc2 . surf . surf . fill ( colors . black )
self pool = run parallel . run parallel ( ) out = pool . run ( ( max , 0 , i 2 ) for i in range ( 5 ) ) self . assert list equal ( out , [ 0 , 0 , 0 , 1 , 2 ] pool = run parallel . run parallel ( ) out = pool . run ( ( max , 0 , i 2 ) for i in range ( 5 ) ) self . assert list equal ( out , [ 0 , 0 , 0 , 1 , 2 ] )
self return self . abilitie return self . abilities
self self . assert equal ( 5 , point . point ( 5 , 10 ) . min dim ( ) self . assert equal ( 5 , point . point ( 5 , 10 ) . min dim ( ) )
self self . assert equal ( point . point ( 4 , 3 ) , point . point ( 3 , 4 ) . transpose ( ) self . assert equal ( point . point ( 4 , 3 ) , point . point ( 3 , 4 ) . transpose ( ) )
self , pt for transform in reversed ( self . transforms ) : pt = transform . back pt ( pt ) return p , pt for transform in reversed ( self . transforms ) : pt = transform . back pt ( pt ) return pt
self , pt return pt . floor ( ) + 0 . , pt return pt . floor ( ) + 0 . 5
str1 , str2 assert len ( str1 ) == len ( str2 ) return sum ( c1 != c2 for c1 , c2 in zip ( str1 , str2 ) )
self sw = stopwatch . stop watch ( ) self . assert equal ( round , sw . decorate ( round ) ) self . assert equal ( round , sw . decorate ( " name " ) ( round ) sw = stopwatch . stop watch ( ) self . assert equal ( round , sw . decorate ( round ) ) self . assert equal ( round , sw . decorate ( " name " ) ( round ) )
self , count = 4 return self . parallel . run ( ( c . step , count ) for c in self . controllers , count = 4 return self . parallel . run ( ( c . step , count ) for c in self . controllers )
self , layer , x , y , bits self . assert equal ( layer . size . x , x ) self . assert equal ( layer . size . y , y ) self . assert equal ( layer . bits per pixel , bits , layer , x , y , bits self . assert equal ( layer . size . x , x ) self . assert equal ( layer . size . y , y ) self . assert equal ( layer . bits per pixel , bits )
self if self . controller : self . controller . quit ( ) self . controller = none if self . sc2 proc : self . sc2 proc . close ( ) self . sc2 proc = none
text , default = none if default : text += ( ' [%s] ' % default ) result = raw input ( text ) if ( result == ' ' ) : return ( none if ( default is none ) else str ( default ) ) else : return resul , default = none if default : text += ( ' [%s] ' % default ) result = raw input ( text ) if ( result == ' ' ) : return ( none if ( default is none ) else str ( default ) ) else : return result
self return str ( trch . parameter u16 get value ( self . param ) return str ( trch . parameter u16 get value ( self . param ) )
self , value trch . parameter u32 set value ( self . param , int ( value ) , value trch . parameter u32 set value ( self . param , int ( value ) )
self return self . tcp port list get value ( return self . tcp port list get value ( )
self , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter s32 list set value ( self . param , tokens , value tokens = [ int ( x ) for x in self . tokenize barelist ( value ) ] trch . parameter s32 list set value ( self . param , tokens )
self , value arg = self . tokenize list ( value ) trch . parameter string list set value ( self . param , arg , value arg = self . tokenize list ( value ) trch . parameter string list set value ( self . param , arg )
self return trch . paramgroup get name ( self . group return trch . paramgroup get name ( self . group )
self return trch . paramgroup get num parameters ( self . group return trch . paramgroup get num parameters ( self . group )
self return [ return [ ]
self , name return trch . paramchoice match name ( self . choice , str ( name ) , name return trch . paramchoice match name ( self . choice , str ( name ) )
self return self . nam return self . name
self , name param = self . find option ( name ) return param . has value ( , name param = self . find option ( name ) return param . has value ( )
self , current ' ' ' search backward starting at the current line and moving up through the history as necessary using a non incremental search for a string supplied by the user . ' ' ' return self . non i search ( 1 , current , current ' ' ' search backward starting at the current line and moving up through the history as necessary using a non incremental search for a string supplied by the user . ' ' ' return self . non i search ( 1 , current )
str , ch result = [ ] index = 0 while index >= 0 : index = str . find ( ch , index ) if index >= 0 : result . append ( index ) index += 1 return resul , ch result = [ ] index = 0 while index >= 0 : index = str . find ( ch , index ) if index >= 0 : result . append ( index ) index += 1 return result
str , iswordfun return [ x for x in word pattern . split ( markwords ( str , iswordfun ) ) if x != " " , iswordfun return [ x for x in word pattern . split ( markwords ( str , iswordfun ) ) if x != " " ]
str , is segment def mark start ( s ) : if s [ 0 : 1 ] == " x " : return s [ : 1 ] + " s " else : return s return " " . join ( map ( mark start , split words ( str , is segment ) ) , is segment def mark start ( s ) : if s [ 0 : 1 ] == " x " : return s [ : 1 ] + " s " else : return s return " " . join ( map ( mark start , split words ( str , is segment ) ) )
self , text raise not implemented erro , text raise not implemented error
argv dsz . control . echo . off ( ) local file = argv [ 1 ] proc name = argv [ 2 ] return demi . windows . module . upgrade ( " pc " , local file , " " , demi . registry . pc . id , ask = false dsz . control . echo . off ( ) local file = argv [ 1 ] proc name = argv [ 2 ] return demi . windows . module . upgrade ( " pc " , local file , " " , demi . registry . pc . id , ask = false )
str dsz . ui . echo ( str , dsz . good , check for stop = false dsz . ui . echo ( str , dsz . good , check for stop = false )
def import sys import re procedure = 0 for arg in sys . argv : match obj = re . match ( ' procedure=( . *) ' , arg ) if match obj != none : procedure = int ( match obj . group ( 1 ) ) return procedurimport sys import re procedure = 0 for arg in sys . argv : match obj = re . match ( ' procedure=( . *) ' , arg ) if match obj != none : procedure = int ( match obj . group ( 1 ) ) return procedure
str import mcl platform . tasking mcl platform . tasking . echo warning ( str import mcl platform . tasking mcl platform . tasking . echo warning ( str )
def import mcl platform . tasking return mcl platform . tasking . get context ( import mcl platform . tasking return mcl platform . tasking . get context ( )
xml import mcl platform . tasking mcl platform . tasking . output xml ( xml import mcl platform . tasking mcl platform . tasking . output xml ( xml )
self self . task info disable = tru self . task info disable = true
self , param self . m xml . add sub element with text ( ' search param ' , ' %s ' % param , param self . m xml . add sub element with text ( ' search param ' , ' %s ' % param )
relative path if relative path == ' * ' : return relative path else : import mcl platform . tasking . virtualdir return mcl platform . tasking . virtualdir . get full path ( relative path tive path if relative path == ' * ' : return relative path else : import mcl platform . tasking . virtualdir return mcl platform . tasking . virtualdir . get full path ( relative path )
self , text self . m text = xml output . clean text ( text , text self . m text = xml output . clean text ( text )
self return self . m typ return self . m type
self return self . m nanosecond return self . m nanoseconds
def import uuid from md5 import md5 simple uuid = uuid . uuid1 ( ) final uuid = uuid . uuid ( md5 ( simple uuid . bytes ) . hexdigest ( ) ) return str ( final uuid import uuid from md5 import md5 simple uuid = uuid . uuid1 ( ) final uuid = uuid . uuid ( md5 ( simple uuid . bytes ) . hexdigest ( ) ) return str ( final uuid )
self , endian = big endian val = self . get u64 ( endian ) if val & 9223372036854775808 : val = ( val & 9223372036854775807 ) 9223372036854775808 return va , endian = big endian val = self . get u64 ( endian ) if val & 9223372036854775808 : val = ( val & 9223372036854775807 ) 9223372036854775808 return val
int addr return ' z%u . %u . %u . %u ' % ( int addr >> 24 & 255 , int addr >> 16 & 255 , int addr >> 8 & 255 , int addr & 255 ddr return ' z%u . %u . %u . %u ' % ( int addr >> 24 & 255 , int addr >> 16 & 255 , int addr >> 8 & 255 , int addr & 255 )
self return ( self . address , self . bits , self . mask return ( self . address , self . bits , self . mask )
self , key , instance = 1 return self . get cache entry data ( key , msg type s32 , instance , key , instance = 1 return self . get cache entry data ( key , msg type s32 , instance )
self , key , instance = 1 return self . get cache entry data ( key , msg type u8 , instance , key , instance = 1 return self . get cache entry data ( key , msg type u8 , instance )
self , key = msg key invalid if key == msg key invalid : return self . m total entries else : if self . m cache . has key ( key ) : return len ( self . m cache [ key ] ) return , key = msg key invalid if key == msg key invalid : return self . m total entries else : if self . m cache . has key ( key ) : return len ( self . m cache [ key ] ) return 0
self , data self . m cache = dict ( ) self . m num retrieved = 0 self . m total entries = 0 if data != none : self . parse data ( data ) retur , data self . m cache = dict ( ) self . m num retrieved = 0 self . m total entries = 0 if data != none : self . parse data ( data ) return
self raise runtime error ( ' data handler output . end must be overriden ' raise runtime error ( ' data handler output . end must be overriden ' )
self , status raise runtime error ( ' data handler output . set task status must be overriden ' , status raise runtime error ( ' data handler output . set task status must be overriden ' )
self return self . m des return self . m dest
self , priority self . m priority = priorit , priority self . m priority = priority
self , status self . m status = statu , status self . m status = status
name , global value = false import mcl platform . data . env mcl platform . data . env . delete value ( name , global value , global value = false import mcl platform . data . env mcl platform . data . env . delete value ( name , global value )
self return self . m nam return self . m name
self return self . m int valu return self . m int value
self return self . m int valu return self . m int value
self import copy return copy . deepcopy ( self . m data import copy return copy . deepcopy ( self . m data )
self return self . m default display parameters . copy ( return self . m default display parameters . copy ( )
self return self . m default display . encode ( ' utf 8 ' return self . m default display . encode ( ' utf 8 ' )
self return self . m required arg return self . m required args
self , arg index return self . m arguments [ arg index ] . get data name ( , arg index return self . m arguments [ arg index ] . get data name ( )
self return self . m valid value return self . m valid values
tool name import mcl platform . tools return mcl platform . tools . get version ( tool name name import mcl platform . tools return mcl platform . tools . get version ( tool name )
def dsz . dsz obj . flags save ( dsz . dsz obj . flags save ( )
def dsz . dsz obj . flags restore ( dsz . dsz obj . flags restore ( )
dir , name dom1 = xml . dom . minidom . parse ( ' %s/payload info . xml ' % dir ) element = dom1 . get elements by tag name ( name ) return get node text ( element [ 0 ] , name dom1 = xml . dom . minidom . parse ( ' %s/payload info . xml ' % dir ) element = dom1 . get elements by tag name ( name ) return get node text ( element [ 0 ] )
self , name if name == ' item ' : return false return data bean . should display ( self , name , name if name == ' item ' : return false return data bean . should display ( self , name )
self b changed = false files = self . get logs ( ) if len ( files ) > len ( self . files ) : self . files = files b changed = true return b change b changed = false files = self . get logs ( ) if len ( files ) > len ( self . files ) : self . files = files b changed = true return b changed
self , attributes , key try : value = ' ' . join ( attributes . get value ( unicode ( key ) ) . encode ( ' utf 8 ' ) ) return value except exception as err : return none return non , attributes , key try : value = ' ' . join ( attributes . get value ( unicode ( key ) ) . encode ( ' utf 8 ' ) ) return value except exception as err : return none return none
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params target , self . dict [ ' target ' ] ) mmsg . add message ( msg key params , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key params target , self . dict [ ' target ' ] ) mmsg . add message ( msg key params , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result taskservicejob trigger registration delay , self . dict [ ' delay ' ] ) mmsg . add message ( msg key result taskservicejob trigger registration , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add string utf8 ( msg key result taskservicejob trigger registration delay , self . dict [ ' delay ' ] ) mmsg . add message ( msg key result taskservicejob trigger registration , submsg )
self self . throttle item = list ( ) try : for x in dsz . cmd . data . get ( ' throttle item ' , dsz . type object ) : self . throttle item . append ( throttle . throttle item ( x ) ) except : pas self . throttle item = list ( ) try : for x in dsz . cmd . data . get ( ' throttle item ' , dsz . type object ) : self . throttle item . append ( throttle . throttle item ( x ) ) except : pass
self self . drive = list ( ) try : for x in dsz . cmd . data . get ( ' drive ' , dsz . type object ) : self . drive . append ( disk space . drive ( x ) ) except : pas self . drive = list ( ) try : for x in dsz . cmd . data . get ( ' drive ' , dsz . type object ) : self . drive . append ( disk space . drive ( x ) ) except : pass
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result process id , self . dict [ ' process id ' ] ) mmsg . add message ( msg key result , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add u32 ( msg key result process id , self . dict [ ' process id ' ] ) mmsg . add message ( msg key result , submsg )
command , addr = dsz . script . env [ ' target address ' ] return process command ( ' disable ' , command , addr and , addr = dsz . script . env [ ' target address ' ] return process command ( ' disable ' , command , addr )
self , dest self . dst = des , dest self . dst = dest
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' win9x ' : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' win9x ' : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 5 and ver . minor == 0 : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major == 5 and ver . minor == 0 : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major >= 5 : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ver . major >= 5 : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ( ver . major == 5 and ver . minor >= 2 or ver . major > 5 ) : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' winnt ' and ( ver . major == 5 and ver . minor >= 2 or ver . major > 5 ) : return true else : return false
addr = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' linux se ' : return true else : return fals = dsz . script . env [ ' target address ' ] ver = dsz . version . info ( addr ) if ver . os == ' linux se ' : return true else : return false
self , key if self . type dict . has key ( key ) : return self . type dict [ key ] else : return none return non , key if self . type dict . has key ( key ) : return self . type dict [ key ] else : return none return none
self , header if self . header dict . has key ( header ) : return self . header dict [ header ] . items ( ) else : return [ , header if self . header dict . has key ( header ) : return self . header dict [ header ] . items ( ) else : return [ ]
self return self . actual path return self . actual paths
msg = none print impl ( ' failed ' , msg , dsz . error = none print impl ( ' failed ' , msg , dsz . error )
b state , msg = none if b state : print success ( msg ) else : print failure ( msg te , msg = none if b state : print success ( msg ) else : print failure ( msg )
def good = false try : ops . db . copy target db files ( ) good = true except : pass return googood = false try : ops . db . copy target db files ( ) good = true except : pass return good
ipstring try : ipsplit = ipstring . split ( ' . ' ) if ( len ( ipsplit ) != 4 ) : return false for oct in ipsplit : if ( ( int ( oct ) > 255 ) or ( int ( oct ) < 0 ) ) : return false except : return false return truring try : ipsplit = ipstring . split ( ' . ' ) if ( len ( ipsplit ) != 4 ) : return false for oct in ipsplit : if ( ( int ( oct ) > 255 ) or ( int ( oct ) < 0 ) ) : return false except : return false return true
def return ' netconnections 'return ' netconnections '
def return ' scanner 'return ' scanner '
def return ' daputouch\\\\|* 'return ' daputouch\\\\|* '
self , job if ( ( not ( len ( job ) == 2 ) ) or ( not ( int ( job [ 1 ] ) in [ 139 , 445 ] ) ) ) : return false return tru , job if ( ( not ( len ( job ) == 2 ) ) or ( not ( int ( job [ 1 ] ) in [ 139 , 445 ] ) ) ) : return false return true
self , escalation rule netbios = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return fals , escalation rule netbios = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return false
self return [ ' internet address ' , ' physical address ' , ' oui ' , ' name ' , ' group name ' , ' services ' , ' target id ' , ' time stamp ' return [ ' internet address ' , ' physical address ' , ' oui ' , ' name ' , ' group name ' , ' services ' , ' target id ' , ' time stamp ' ]
self return ( ' rpc2 response for %s ' % self . target return ( ' rpc2 response for %s ' % self . target )
self , escalation rule rpc2 = self try : if eval ( escalation rule ) : return true else : return false except : return fals , escalation rule rpc2 = self try : if eval ( escalation rule ) : return true else : return false except : return false
self , escalation rule ping = self try : if eval ( escalation rule ) : return true else : return false except : return fals , escalation rule ping = self try : if eval ( escalation rule ) : return true else : return false except : return false
self , escalation rule ping = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return fals , escalation rule ping = self try : eval res = eval ( escalation rule ) if ( ( eval res == true ) or ( eval res == false ) ) : return true else : return false except : return false
garbage return yakinstall ( ' is ' age return yakinstall ( ' is ' )
ipstring try : ipsplit = ipstring . split ( ' . ' ) if ( len ( ipsplit ) != 4 ) : return false for oct in ipsplit : if ( ( int ( oct ) > 255 ) or ( int ( oct ) < 0 ) ) : return false except : return false return truring try : ipsplit = ipstring . split ( ' . ' ) if ( len ( ipsplit ) != 4 ) : return false for oct in ipsplit : if ( ( int ( oct ) > 255 ) or ( int ( oct ) < 0 ) ) : return false except : return false return true
file to read , output dir handler ( file to read , parse arp , output dir to read , output dir handler ( file to read , parse arp , output dir )
def return ' gets files listed in a file 'return ' gets files listed in a file '
self l files = self . list files ( ) size = 0 for f in l files : size += f . size print ( ' about to get %d files totalling %d bytes . will prompt for individual files > %d bytes ' % ( len ( l files ) , size , self . get max size ( ) ) l files = self . list files ( ) size = 0 for f in l files : size += f . size print ( ' about to get %d files totalling %d bytes . will prompt for individual files > %d bytes ' % ( len ( l files ) , size , self . get max size ( ) ) )
name , data = none return set ( name , data , db handle = ops . db . database ( db = ops . db . target db , isolation level = none ) , data = none return set ( name , data , db handle = ops . db . database ( db = ops . db . target db , isolation level = none ) )
env , cmdid = 0 , addr = dsz . script . env [ ' target address ' ] value = get ( env , cmdid , addr ) return ( value . lower ( ) if value else value , cmdid = 0 , addr = dsz . script . env [ ' target address ' ] value = get ( env , cmdid , addr ) return ( value . lower ( ) if value else value )
self set ( test , 5 ) self . assert equal ( numeric ( test ) , 5 set ( test , 5 ) self . assert equal ( numeric ( test ) , 5 )
self set ( test , lower ) self . assert equal ( upper ( test ) , upper set ( test , lower ) self . assert equal ( upper ( test ) , upper )
self return ( self . friendly local time self . friendly gmt time return ( self . friendly local time self . friendly gmt time )
def ops . survey . print header ( ' av check!!! ' ) psp cmd = ops . cmd . get dsz command ( ' python ' , arglist = [ ' windows\\\\checkpsp . py ' ] , project = ' ops ' , dszquiet = false ) psp cmd . execute ( ) save donuts ( ops . survey . print header ( ' av check!!! ' ) psp cmd = ops . cmd . get dsz command ( ' python ' , arglist = [ ' windows\\\\checkpsp . py ' ] , project = ' ops ' , dszquiet = false ) psp cmd . execute ( ) save donuts ( )
value mark ( value , redo e mark ( value , redo )
value s = state ( value ) if ( s is none ) : return false elif ( s [ 0 ] == redo ) : return true else : return false s = state ( value ) if ( s is none ) : return false elif ( s [ 0 ] == redo ) : return true else : return false
self enforce ( false , ( lambda : ( " xml element handler ' process ' not implemented for %s " % self . class ) ) enforce ( false , ( lambda : ( " xml element handler ' process ' not implemented for %s " % self . class ) ) )
self , attrib , default = none value = self . element . get ( attrib , default = default ) if ( ( value is not none ) and ( type ( value ) is not bool ) ) : value = ( value . lower ( ) == ' true ' ) return valu , attrib , default = none value = self . element . get ( attrib , default = default ) if ( ( value is not none ) and ( type ( value ) is not bool ) ) : value = ( value . lower ( ) == ' true ' ) return value
self , validate = false msg = self . element . text if ( not validate ) : ops . pause ( msg ) return tru , validate = false msg = self . element . text if ( not validate ) : ops . pause ( msg ) return true
self return self . handle ( return self . handle ( )
self if ( ' after ' in self . optdict ) : return self . optdict [ ' after ' ] else : return non if ( ' after ' in self . optdict ) : return self . optdict [ ' after ' ] else : return none
self if ( ' target ' in self . optdict ) : return self . optdict [ ' target ' ] else : return non if ( ' target ' in self . optdict ) : return self . optdict [ ' target ' ] else : return none
self , object number assert ( ( object number is none ) or ( ( type ( object number ) is int ) and ( object number >= 0 ) ) ) , ' object number must be a positive integer or zero; or none to clear this option . ' self . opt object number = object numbe , object number assert ( ( object number is none ) or ( ( type ( object number ) is int ) and ( object number >= 0 ) ) ) , ' object number must be a positive integer or zero; or none to clear this option . ' self . opt object number = object number
self return self . opt dat return self . opt data
command string , dszquiet = true , norecord = false com obj = get dsz command ( command string , dszquiet , norecord ) return com obj . execute ( and string , dszquiet = true , norecord = false com obj = get dsz command ( command string , dszquiet , norecord ) return com obj . execute ( )
self , value for prefix in self . prefixes : if ( prefix . find ( ' user ' ) == 0 ) : self . prefixes . remove ( prefix ) if ( value is none ) : return self . prefixes . append ( ( ' user=%s ' % value ) , value for prefix in self . prefixes : if ( prefix . find ( ' user ' ) == 0 ) : self . prefixes . remove ( prefix ) if ( value is none ) : return self . prefixes . append ( ( ' user=%s ' % value ) )
self return self . resul return self . result
self if ( self . direction == implantlisten ) : retval = str ( self . listen port ) if ( self . bind address != ' 0 . 0 . 0 . 0 ' ) : retval += ( ' %s ' % self . bind address ) return retval else : return non if ( self . direction == implantlisten ) : retval = str ( self . listen port ) if ( self . bind address != ' 0 . 0 . 0 . 0 ' ) : retval += ( ' %s ' % self . bind address ) return retval else : return none
self , value try : value = int ( value ) except value error : raise ops command exception ( ' invalid target port , must be an integer between 0 65535 ' ) self . target port = valu , value try : value = int ( value ) except value error : raise ops command exception ( ' invalid target port , must be an integer between 0 65535 ' ) self . target port = value
self return self . limit mas return self . limit mask
self if ( self . limit address != ' 0 . 0 . 0 . 0 ' ) : return ( ' %s %s ' % ( self . limit address , self . limit mask ) ) else : return non if ( self . limit address != ' 0 . 0 . 0 . 0 ' ) : return ( ' %s %s ' % ( self . limit address , self . limit mask ) ) else : return none
self if ( ' packetsize ' in self . optdict ) : return self . optdict [ ' packetsize ' ] else : return if ( ' packetsize ' in self . optdict ) : return self . optdict [ ' packetsize ' ] else : return 0
self , monitor assert ( ( type ( monitor ) is bool ) or ( ( type ( monitor ) is int ) and ( monitor > 0 ) ) ) , ' monitor option must be boolean or a positive non zero integer . ' self . opt monitor = monito , monitor assert ( ( type ( monitor ) is bool ) or ( ( type ( monitor ) is int ) and ( monitor > 0 ) ) ) , ' monitor option must be boolean or a positive non zero integer . ' self . opt monitor = monitor
self , ignore assert ( type ( ignore ) is type ( [ ] ) ) , ' ignore must be a list . ' assert ( len ( ignore ) <= 9 ) , ' ignore list cannont exceed 9 items . ' self . opt ignore = ignor , ignore assert ( type ( ignore ) is type ( [ ] ) ) , ' ignore must be a list . ' assert ( len ( ignore ) <= 9 ) , ' ignore list cannont exceed 9 items . ' self . opt ignore = ignore
maxage = timedelta ( 0 ) , target id = none status cmd = ops . cmd . get dsz command ( ' audit status ' ) return ops . project . generic cache get ( status cmd , cache tag = audit tag , cache size = max cache size , maxage = maxage , target id = target id ge = timedelta ( 0 ) , target id = none status cmd = ops . cmd . get dsz command ( ' audit status ' ) return ops . project . generic cache get ( status cmd , cache tag = audit tag , cache size = max cache size , maxage = maxage , target id = target id )
cmd , uniqid , val datacache [ ' {0} {1} ' . format ( cmd , uniqid ) ] = va , uniqid , val datacache [ ' {0} {1} ' . format ( cmd , uniqid ) ] = val
myst if ( not isinstance ( myst , list ) ) : return myst if ( len ( myst ) == 2 ) : return shallow ( myst [ 1 ] ) return [ shallow ( a ) for a in myst [ 1 : ] if ( not isinstance ( myst , list ) ) : return myst if ( len ( myst ) == 2 ) : return shallow ( myst [ 1 ] ) return [ shallow ( a ) for a in myst [ 1 : ] ]
self action . execute ( self ) pathnmask = self . execparams [ ' filepath ' ] pattern = self . execparams [ ' pattern ' ] self . result = get file grep ( pathnmask = pathnmask , pattern = pattern ) return ( self . result is not none action . execute ( self ) pathnmask = self . execparams [ ' filepath ' ] pattern = self . execparams [ ' pattern ' ] self . result = get file grep ( pathnmask = pathnmask , pattern = pattern ) return ( self . result is not none )
self action . execute ( self ) swtype = self . execparams . get ( ' type ' ) if ( swtype == ' psp ' ) : res = psp ( ) else : res = none self . result = res self . actmgr . add psp ( self . result , self ) return ( self . result is not none action . execute ( self ) swtype = self . execparams . get ( ' type ' ) if ( swtype == ' psp ' ) : res = psp ( ) else : res = none self . result = res self . actmgr . add psp ( self . result , self ) return ( self . result is not none )
input success = dll u ( ( ' %s\\\\ uploads\\\\msgki . dll ' % grok path ) ) if ( not success ) : return false return trut success = dll u ( ( ' %s\\\\ uploads\\\\msgki . dll ' % grok path ) ) if ( not success ) : return false return true
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add bool ( msg key result available available , self . dict [ ' available ' ] ) mmsg . add message ( msg key result available , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add bool ( msg key result available available , self . dict [ ' available ' ] ) mmsg . add message ( msg key result available , submsg )
self , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add data ( msg key result raw data , self . dict [ ' mem dump ' ] ) mmsg . add message ( msg key result , submsg , mmsg from mcl . object . message import marshal message submsg = marshal message ( ) submsg . add data ( msg key result raw data , self . dict [ ' mem dump ' ] ) mmsg . add message ( msg key result , submsg )
namespace import mcl . tasking procedure = mcl . tasking . get procedure number ( ) if procedure == 0 : return handle ge zu kernel memory ( namespace ) else : import mcl . tasking mcl . tasking . echo error ( ' unknown procedure (%u) ' % procedure ) return falsspace import mcl . tasking procedure = mcl . tasking . get procedure number ( ) if procedure == 0 : return handle ge zu kernel memory ( namespace ) else : import mcl . tasking mcl . tasking . echo error ( ' unknown procedure (%u) ' % procedure ) return false
self return [ ' processes list ' return [ ' processes list ' ]
self self . cond . acquire ( ) try : self . flag . acquire ( false ) self . flag . release ( ) self . cond . notify all ( ) finally : self . cond . release ( self . cond . acquire ( ) try : self . flag . acquire ( false ) self . flag . release ( ) self . cond . notify all ( ) finally : self . cond . release ( )
conn , handle , destination pid process handle = win32 . open process ( win32 . process all access , false , destination pid ) try : new handle = duplicate ( handle , process handle ) conn . send ( new handle ) finally : close ( process handle , handle , destination pid process handle = win32 . open process ( win32 . process all access , false , destination pid ) try : new handle = duplicate ( handle , process handle ) conn . send ( new handle ) finally : close ( process handle )
conn , handle , destination pid multiprocessing . sendfd ( conn . fileno ( ) , handle , handle , destination pid multiprocessing . sendfd ( conn . fileno ( ) , handle )
def ' ' ' returns a recursive lock object ' ' ' from multiprocessing . synchronize import r lock return r lock ( ' ' ' returns a recursive lock object ' ' ' from multiprocessing . synchronize import r lock return r lock ( )
maxsize = 0 ' ' ' returns a queue object ' ' ' from multiprocessing . queues import joinable queue return joinable queue ( maxsize ize = 0 ' ' ' returns a queue object ' ' ' from multiprocessing . queues import joinable queue return joinable queue ( maxsize )
typecode or type , size or initializer ' ' ' returns a shared array ' ' ' from multiprocessing . sharedctypes import raw array return raw array ( typecode or type , size or initializer code or type , size or initializer ' ' ' returns a shared array ' ' ' from multiprocessing . sharedctypes import raw array return raw array ( typecode or type , size or initializer )
self events = self . queue [ : ] return map ( heapq . heappop , [ events ] * len ( events ) )
p i = p . rfind ( ' / ' ) + 1 head , tail = p [ : i ] , p [ i : ] if head and head != ' / ' * len ( head ) : head = head . rstrip ( ' / ' ) return ( head , tail )
fp1 , fp2 s1 = os . fstat ( fp1 ) s2 = os . fstat ( fp2 ) return samestat ( s1 , s2 )
path try : st = os . stat ( path ) except os . error : return false return st . st mode & 73 != 0
handler class = cgihttp request handler , server class = base http server . http server simple http server . test ( handler class , server class ler class = cgihttp request handler , server class = base http server . http server simple http server . test ( handler class , server class )
path item try : importer = sys . path importer cache [ path item ] except key error : for path hook in sys . path hooks : try : importer = path hook ( path item ) break except import error : pass else : importer = none sys . path importer cache . setdefault ( path item , importer ) if importer is none : try : importer = imp importer ( path item ) except import error : importer = none return importer
self , arg = none if hasattr ( arg , ' iteritems ' ) : source = arg . iteritems ( ) elif hasattr ( arg , ' items ' ) : source = arg . items ( ) else : source = arg bad key = false for key , message in source : try : self [ key ] = message except key error : bad key = true if bad key : raise key error ( ' no message with key(s) ' )
self , key = none if self . toc is none : self . generate toc ( ) if key is not none : try : return self . toc [ key ] except key error : raise key error ( ' no message with key: %s ' % key ) return
self , key , from = false start , stop = self . lookup ( key ) self . file . seek ( start ) if not from : self . file . readline ( ) string = self . file . read ( stop self . file . tell ( ) ) return string . replace ( os . linesep , ' \ ' )
self , f f . write ( ' \\x01\\x01\\x01\\x01 ' + os . linesep )
self , message key = singlefile mailbox . add ( self , message ) if isinstance ( message , babyl message ) : self . labels [ key ] = message . get labels ( ) return key
self , flags self . info = ' 2 , ' + ' ' . join ( sorted ( flags ) )
self return self . from
self , flag self . set flags ( ' ' . join ( set ( self . get flags ( ) ) | set ( flag ) ) )
